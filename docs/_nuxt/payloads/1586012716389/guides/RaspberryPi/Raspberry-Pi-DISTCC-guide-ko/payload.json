{"data":[{"page":{"entry":{"name":"Raspberry-Pi-DISTCC-guide-ko","filename":"Raspberry-Pi-DISTCC-guide.ko.md","absolute":"/Users/Gilbert/Code/openFrameworks/ofSite/content/setup/RaspberryPi/Raspberry-Pi-DISTCC-guide.ko.md","path":"/guides/RaspberryPi/Raspberry-Pi-DISTCC-guide-ko","route":"/guides/RaspberryPi/Raspberry-Pi-DISTCC-guide.ko.md","dir":"../ofSite/content/setup/RaspberryPi","ext":"md","type":"page","id":1930,"parent":1919,"breadcrumbs":[1919,1795],"siblings":[],"translations":{}},"description":{},"document":"<h2>-<em>- coding: utf-8 -</em>-</h2>\n<p>.. title: raspberry pi</p>\n<h1>라즈베리파이 DISTCC 가이드</h1>\n<p>##distcc\n<em>이 가이드는 많은 소스파일로 이루어진 프로젝트나 오픈프레임웍스 코어를 갖고 작업하는 개발자들에게 추천됩니다. 일반 유저들에게는, 라즈베리파이의 빌드 속도(시작하기 가이드에 의할 경우)가 아마 문제 없을겁니다. 속도가 더 필요하신 분들은, 아래를 봐주세요!</em></p>\n<p><code>distcc</code>는 하나의 &quot;마스터&quot; 컴퓨터(우리의 경우 라즈베리파이)가 컴파일하는 부하를 다른 &quot;헬퍼&quot; 머신(멀티코어 우분투 리눅스 머신)으로 네트워크를 통해 분산시킬 수 있도록 해주는 프로그램입니다. 일반적인 모드에서, 소스파일은 라즈베리파이상에서 사전처리(preprocessed)된 뒤, 압축되어 컴파일을 위해 다른 헬퍼 머신으로 보내어집니다. 이 경우 헬퍼 머신에서는 arm호환 크로스 컴파일러가 동작하여, object파일(.o file)을 컴파일하고, 이것을 다시 라즈베리파이로 되돌려줍니다. 라즈베리파이가 object 파일을 모두 받으면, 이것들을 연결하어 라이브리나 실행가능한 파일로 만듭니다.</p>\n<p><code>distcc-pump</code> 명령어를 사용하여 분산 사전처리를 수행할 수도 있지만, 이 기능은 제외하였습니다.</p>\n<p>_노트: 맥 OS X에서는, 페러럴즈 8을 이용해 우분투 &quot;헬퍼&quot; 머신을 구동할 수 있습니다. 우분투 인스턴스를 <em>BRIDGED_로 네트워크 세팅을 하면 같은 네트워크상에서 라즈베리파이로 접근할 수 있습니다. 윈도우즈에서는 vmware나 virtualbox같은 가상머신 도구로 비슷한 세팅을 할 수 있습니다. 리눅스의 경우에는 가상머신을 설치할 필요 없이 바로 다음 단계로 넘어가시면 되며, 컴파일러는 리눅스 머신에서 직접 구동됩니다.</em></p>\n<h3><strong>우분투 머신에서</strong></h3>\n<ul>\n<li>\n<p>의존성 패키지 설치하기</p>\n<ul>\n<li><code>sudo apt-get install mercurial bison flex texinfo automake curl</code></li>\n<li><code>sudo apt-get install build-essential libncurses-dev libtool gawk gperf</code></li>\n<li>만약 64비트 리눅스 배포판을 사용한다면, 하단의  명령어를 추가로 설치해줘야 합니다:</li>\n<li><code>sudo aptitude install ia32-libs</code></li>\n</ul>\n</li>\n<li>\n<p>리눅스를 위한 라즈베리파이 컴파일러 다운받기</p>\n<ul>\n<li><a href=\"https://github.com/raspberrypi/tools/\">https://github.com/raspberrypi/tools/</a>에서 zip파일로 받거나 clone할 수 있습니다.</li>\n<li>rpi-tools와 같은 구별될 수 있는 이름으로 폴더이름을 변경합니다. 이 폴더는 이제부터 <code>$RPI_TOOLS</code>로 조회될 것입니다.</li>\n</ul>\n</li>\n<li>\n<p>우분투 헬퍼머신에 <code>distcc</code>를 설치하고 설정하기</p>\n<ul>\n<li><code>sudo apt-get install distcc</code></li>\n<li><code>/etc/default/distcc</code>를 편집한다 (예시: <code>sudo vi /etc/default/distcc</code>)\n<ul>\n<li>Change <code>STARTDISTCC=&quot;false&quot;</code>를 <code>STARTDISTCC=&quot;true&quot;</code>로 변경한다.</li>\n<li><code>ALLOWEDNETS=&quot;127.0.0.1&quot;</code>를 라즈베리파이의 네트워크 IP주소가 포함되도록 한다.\n<ul>\n<li><em>노트: 주소들은 CIDR 표기법을 따릅니다. <code>localhost</code> 와 <code>192.168.1.0-192.168.1.255</code> 범위내의 IP 주소들을 허용하려면, <code>ALLOWEDNETS=&quot;127.0.0.1 192.168.1.0/24</code>로 작성합니다.</em></li>\n<li><em>노트: 만약 CIRD 표기에 도움이 필요하면, <a href=\"http://www.subnet-calculator.com/cidr.php\">이곳</a>의 계산기를 사용할 수 있습니다.</em></li>\n</ul>\n</li>\n<li><code>ZEROCONF=&quot;false&quot;</code>를 <code>ZEROCONF=&quot;true&quot;</code>로 변경한다.</li>\n<li>(<code>localhost/127.0.0.1</code>뿐만 아니라) 모든 네트워크 인터페이스에서 들어오는 접속을 허용하도록 <code>LISTENER=&quot;127.0.0.1&quot;</code>를 <code>LISTENER=&quot;&quot;</code>로 수정합니다.</li>\n</ul>\n</li>\n<li><code>/etc/init.d/distcc</code>룰 편집한다 (예시: <code>sudo vi /etc/init.d/distcc</code>)\n<ul>\n<li><code>PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin</code>을 <code>PATH=$RPI_TOOLS/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin</code>로 변경한다.\n<ul>\n<li><em>노트: $RPI_TOOLS는 이전에 라즈베리파이를 설치할때 지정했던 경로가 되어야 합니다.</em></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>우분투 머신에서 <code>distcc</code>를 시작한다.</p>\n<ul>\n<li><code>sudo service distcc start</code> (실패할 경우, 재부팅을 해야 합니다.)</li>\n<li>실패할경우, 아래 명령어를 시도해보세요:</li>\n<li><code>sudo service distcc restart</code></li>\n</ul>\n</li>\n</ul>\n<h3><strong>라즈베리파이에서</strong></h3>\n<ul>\n<li>\n<p><code>distcc</code> 설치하기</p>\n<ul>\n<li><code>sudo apt-get install distcc</code></li>\n</ul>\n</li>\n<li>\n<p>방금 설정한 우분투 헬퍼 머신을 사용하기 위해 라즈베리파이를 설정합니다.</p>\n<ul>\n<li>디렉토리를 만듭니다 <code>mkdir $HOME/.distcc/</code></li>\n<li><code>$HOME/.distcc/hosts</code>파일을 편집하고(예시: <code>vi $HOME/.distcc/hosts</code>), rpi_tools가 인스톨된 컴퓨터들의 IP주소(들)을 추가한다.</li>\n<li>컴파일을 하기 위해서 (마침내!)\n<ul>\n<li>우선, 각 우분투 머신(들)에서 몇개의 프로세서가 가능한지 <code>nproc</code>명령어를 이용하여 확인합니다. 그 다음 헐퍼 프로세서의 최종 합계를 계산합니다. 추후 distcc로 분산 컴파일을 할 때, 얼마나 많은 작업을 할지 <code>-j</code> 플래그를 이용해 알려줄 수 있습니다. distcc 문서에 의하면, 클러스터에서 최종 프로세서 X 2의 값으로 make를 수행할 수 있습니다. 따라서 만약 8코어를 갖는 하나의 헬퍼 머신이 있다면 <code>8x2=16</code>이 되므로, <code>make -j 16</code>이라고 실행할 수 있습니다. 만약 같은 머신에서 수행할 경우 낮은 숫자를 사용해야 할텐데, 이 플래그는 이 때도 사용 가능합니다.</li>\n<li>다음으로, makefile에게 일반 RPI gcc가 아닌, (예를 들어) <code>/usr/lib/distcc</code>에 위치한 gcc를 사용하라고 알려줘야 합니다. 명령어은 일반 <code>g++</code>가 아닌, <code>/usr/lib/distcc/g++</code>나 <code>distcc g++</code>가 되어야 합니다.  따라서 오픈프레임웍스 코어 나 프로젝트를 컴파일할때 최종 make는 아래와 같습니다:\n<ul>\n<li><code>make -j 6 CXX=/usr/lib/distcc/arm-linux-gnueabihf-g++ CC=/usr/lib/distcc/arm-linux-gnueabihf-gcc</code></li>\n</ul>\n</li>\n<li>만약 명령을 단축하고 싶다면, 아래의 명령어로 <code>MAKEFLAGS</code>를 설정할 수 있습니다.\n<ul>\n<li><code>export MAKEFLAGS=&quot;-s -j 6 CXX=/usr/lib/distcc/arm-linux-gnueabihf-g++ CC=/usr/lib/distcc/arm-linux-gnueabihf-gcc&quot;</code></li>\n<li><code>make</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","raw":"## -*- coding: utf-8 -*-\n.. title: raspberry pi\n\n\n라즈베리파이 DISTCC 가이드\n============\n\n##distcc\n_이 가이드는 많은 소스파일로 이루어진 프로젝트나 오픈프레임웍스 코어를 갖고 작업하는 개발자들에게 추천됩니다. 일반 유저들에게는, 라즈베리파이의 빌드 속도(시작하기 가이드에 의할 경우)가 아마 문제 없을겁니다. 속도가 더 필요하신 분들은, 아래를 봐주세요!_ \n\n`distcc`는 하나의 \"마스터\" 컴퓨터(우리의 경우 라즈베리파이)가 컴파일하는 부하를 다른 \"헬퍼\" 머신(멀티코어 우분투 리눅스 머신)으로 네트워크를 통해 분산시킬 수 있도록 해주는 프로그램입니다. 일반적인 모드에서, 소스파일은 라즈베리파이상에서 사전처리(preprocessed)된 뒤, 압축되어 컴파일을 위해 다른 헬퍼 머신으로 보내어집니다. 이 경우 헬퍼 머신에서는 arm호환 크로스 컴파일러가 동작하여, object파일(.o file)을 컴파일하고, 이것을 다시 라즈베리파이로 되돌려줍니다. 라즈베리파이가 object 파일을 모두 받으면, 이것들을 연결하어 라이브리나 실행가능한 파일로 만듭니다.\n\n`distcc-pump` 명령어를 사용하여 분산 사전처리를 수행할 수도 있지만, 이 기능은 제외하였습니다.\n\n_노트: 맥 OS X에서는, 페러럴즈 8을 이용해 우분투 \"헬퍼\" 머신을 구동할 수 있습니다. 우분투 인스턴스를 _BRIDGED_로 네트워크 세팅을 하면 같은 네트워크상에서 라즈베리파이로 접근할 수 있습니다. 윈도우즈에서는 vmware나 virtualbox같은 가상머신 도구로 비슷한 세팅을 할 수 있습니다. 리눅스의 경우에는 가상머신을 설치할 필요 없이 바로 다음 단계로 넘어가시면 되며, 컴파일러는 리눅스 머신에서 직접 구동됩니다._\n\n### __우분투 머신에서__  \n\n* 의존성 패키지 설치하기\n    * `sudo apt-get install mercurial bison flex texinfo automake curl`\n    * `sudo apt-get install build-essential libncurses-dev libtool gawk gperf`\n    * 만약 64비트 리눅스 배포판을 사용한다면, 하단의  명령어를 추가로 설치해줘야 합니다:\n    * `sudo aptitude install ia32-libs`\n    \n* 리눅스를 위한 라즈베리파이 컴파일러 다운받기\n    * [https://github.com/raspberrypi/tools/](https://github.com/raspberrypi/tools/)에서 zip파일로 받거나 clone할 수 있습니다.\n    * rpi-tools와 같은 구별될 수 있는 이름으로 폴더이름을 변경합니다. 이 폴더는 이제부터 `$RPI_TOOLS`로 조회될 것입니다.\n\n* 우분투 헬퍼머신에 `distcc`를 설치하고 설정하기\n    * `sudo apt-get install distcc`\n    *  `/etc/default/distcc`를 편집한다 (예시: `sudo vi /etc/default/distcc`)\n        * Change `STARTDISTCC=\"false\"`를 `STARTDISTCC=\"true\"`로 변경한다.\n        * `ALLOWEDNETS=\"127.0.0.1\"`를 라즈베리파이의 네트워크 IP주소가 포함되도록 한다.\n            * _노트: 주소들은 CIDR 표기법을 따릅니다. `localhost` 와 `192.168.1.0-192.168.1.255` 범위내의 IP 주소들을 허용하려면, `ALLOWEDNETS=\"127.0.0.1 192.168.1.0/24`로 작성합니다._\n            * _노트: 만약 CIRD 표기에 도움이 필요하면, [이곳](http://www.subnet-calculator.com/cidr.php)의 계산기를 사용할 수 있습니다._\n        * `ZEROCONF=\"false\"`를 `ZEROCONF=\"true\"`로 변경한다.\n        * (`localhost/127.0.0.1`뿐만 아니라) 모든 네트워크 인터페이스에서 들어오는 접속을 허용하도록 `LISTENER=\"127.0.0.1\"`를 `LISTENER=\"\"`로 수정합니다.\n    * `/etc/init.d/distcc`룰 편집한다 (예시: `sudo vi /etc/init.d/distcc`)\n        * `PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin`을 `PATH=$RPI_TOOLS/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin`로 변경한다.\n            * _노트: $RPI_TOOLS는 이전에 라즈베리파이를 설치할때 지정했던 경로가 되어야 합니다._\n            \n* 우분투 머신에서 `distcc`를 시작한다.\n    * `sudo service distcc start` (실패할 경우, 재부팅을 해야 합니다.)\n    * 실패할경우, 아래 명령어를 시도해보세요:\n    * `sudo service distcc restart`\n\n### __라즈베리파이에서__\n\n* `distcc` 설치하기\n    * `sudo apt-get install distcc`\n    \n* 방금 설정한 우분투 헬퍼 머신을 사용하기 위해 라즈베리파이를 설정합니다.\n    * 디렉토리를 만듭니다 `mkdir $HOME/.distcc/`\n    * `$HOME/.distcc/hosts`파일을 편집하고(예시: `vi $HOME/.distcc/hosts`), rpi_tools가 인스톨된 컴퓨터들의 IP주소(들)을 추가한다.\n    * 컴파일을 하기 위해서 (마침내!)\n        * 우선, 각 우분투 머신(들)에서 몇개의 프로세서가 가능한지 `nproc`명령어를 이용하여 확인합니다. 그 다음 헐퍼 프로세서의 최종 합계를 계산합니다. 추후 distcc로 분산 컴파일을 할 때, 얼마나 많은 작업을 할지 `-j` 플래그를 이용해 알려줄 수 있습니다. distcc 문서에 의하면, 클러스터에서 최종 프로세서 X 2의 값으로 make를 수행할 수 있습니다. 따라서 만약 8코어를 갖는 하나의 헬퍼 머신이 있다면 `8x2=16`이 되므로, `make -j 16`이라고 실행할 수 있습니다. 만약 같은 머신에서 수행할 경우 낮은 숫자를 사용해야 할텐데, 이 플래그는 이 때도 사용 가능합니다.\n        * 다음으로, makefile에게 일반 RPI gcc가 아닌, (예를 들어) `/usr/lib/distcc`에 위치한 gcc를 사용하라고 알려줘야 합니다. 명령어은 일반 `g++`가 아닌, `/usr/lib/distcc/g++`나 `distcc g++`가 되어야 합니다.  따라서 오픈프레임웍스 코어 나 프로젝트를 컴파일할때 최종 make는 아래와 같습니다:\n            * `make -j 6 CXX=/usr/lib/distcc/arm-linux-gnueabihf-g++ CC=/usr/lib/distcc/arm-linux-gnueabihf-gcc`\n        * 만약 명령을 단축하고 싶다면, 아래의 명령어로 `MAKEFLAGS`를 설정할 수 있습니다.\n            * `export MAKEFLAGS=\"-s -j 6 CXX=/usr/lib/distcc/arm-linux-gnueabihf-g++ CC=/usr/lib/distcc/arm-linux-gnueabihf-gcc\"`\n            * `make`\n\n\n","type":"page","static":true}}],"fetch":[]}