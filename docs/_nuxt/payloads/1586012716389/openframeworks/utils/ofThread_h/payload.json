{"data":[{"page":{"entry":{"name":"ofThread.h","filename":"ofThread.h","absolute":"/Users/Gilbert/Code/openFrameworks/libs/openFrameworks/utils/ofThread.h","path":"/openframeworks/utils/ofThread_h","route":"/openframeworks/utils/ofThread.h","dir":"../libs/openFrameworks/utils","ext":"h","type":"source","id":313,"parent":298,"breadcrumbs":[298,164],"siblings":[],"translations":{}},"document":"<span class=\"token macro property\">#<span class=\"token directive keyword\">pragma</span> once</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">\"ofConstants.h\"</span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">ifndef</span> TARGET_NO_THREADS</span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;atomic></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;thread></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;mutex></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;condition_variable></span></span>\n\n\n<span class=\"token comment\" spellcheck=\"true\">/// \\class ofThread</span>\n<span class=\"token comment\" spellcheck=\"true\">/// \\brief A threaded base class with a built in mutex for convenience.</span>\n<span class=\"token comment\" spellcheck=\"true\">///</span>\n<span class=\"token comment\" spellcheck=\"true\">/// Users can extend this base class by public inheritance like this:</span>\n<span class=\"token comment\" spellcheck=\"true\">///</span>\n<span class=\"token comment\" spellcheck=\"true\">///     class MyThreadedClass: public ofThread</span>\n<span class=\"token comment\" spellcheck=\"true\">///     {</span>\n<span class=\"token comment\" spellcheck=\"true\">///         public:</span>\n<span class=\"token comment\" spellcheck=\"true\">///         /// ...</span>\n<span class=\"token comment\" spellcheck=\"true\">///         void threadedFunction()</span>\n<span class=\"token comment\" spellcheck=\"true\">///         {</span>\n<span class=\"token comment\" spellcheck=\"true\">///             while(isThreadRunning())</span>\n<span class=\"token comment\" spellcheck=\"true\">///             {</span>\n<span class=\"token comment\" spellcheck=\"true\">///                 /// Threaded function here.</span>\n<span class=\"token comment\" spellcheck=\"true\">///             }</span>\n<span class=\"token comment\" spellcheck=\"true\">///         }</span>\n<span class=\"token comment\" spellcheck=\"true\">///     };</span>\n<span class=\"token comment\" spellcheck=\"true\">///</span>\n<span class=\"token comment\" spellcheck=\"true\">/// ofThread is a convenient wrapper for Poco::Thread, Poco::Runnable and</span>\n<span class=\"token comment\" spellcheck=\"true\">/// Poco::Mutex.  It represents a simplified (sometimes overly simplified -</span>\n<span class=\"token comment\" spellcheck=\"true\">/// or simplified in ways that might not make sense for your project)</span>\n<span class=\"token comment\" spellcheck=\"true\">/// pathway for quickly writing threaded classes.  Poco::Runnable represents</span>\n<span class=\"token comment\" spellcheck=\"true\">/// a class that can be \"run\" via its void run() method.  Poco::Thread is</span>\n<span class=\"token comment\" spellcheck=\"true\">/// able to spawn a thread and \"run\" the contents of a class that extends</span>\n<span class=\"token comment\" spellcheck=\"true\">/// the Poco::Runnable interface (which ofThread does).  Poco::FastMutex,</span>\n<span class=\"token comment\" spellcheck=\"true\">/// (aka ofMutex) is a \"mutual exclusion\" object that prevents two threads</span>\n<span class=\"token comment\" spellcheck=\"true\">/// from accessing the same data at the same time.  It is important to know</span>\n<span class=\"token comment\" spellcheck=\"true\">/// that Poco::FastMutex (aka ofMutex) is not \"recursive\" while Poco::Mutex</span>\n<span class=\"token comment\" spellcheck=\"true\">/// is. This means that if the same thread attempts to lock a thread while</span>\n<span class=\"token comment\" spellcheck=\"true\">/// it ALREADY has a lock on the mutex, the program will lock up and go</span>\n<span class=\"token comment\" spellcheck=\"true\">/// nowhere.  Thus, it is important that ofThread subclasses carefully</span>\n<span class=\"token comment\" spellcheck=\"true\">/// their use of the mutex.  Currently ofThread does not lock its own mutex</span>\n<span class=\"token comment\" spellcheck=\"true\">/// at any point (e.g. ofThread's internal variables are not thread safe).</span>\n<span class=\"token comment\" spellcheck=\"true\">/// This is a somewhat dangerous convenience that is (theoretically)</span>\n<span class=\"token comment\" spellcheck=\"true\">/// supposed to make it easier for subclasses to avoid the recursive mutex</span>\n<span class=\"token comment\" spellcheck=\"true\">/// \"problem\". The situation that arises from two threads simultanously</span>\n<span class=\"token comment\" spellcheck=\"true\">/// reading or writing from the same shared data (shared data</span>\n<span class=\"token comment\" spellcheck=\"true\">/// occupies the same physical location in memory) leads to something</span>\n<span class=\"token comment\" spellcheck=\"true\">/// called a \"race condition\", which can lead to deadlocks.</span>\n<span class=\"token comment\" spellcheck=\"true\">/// A deadlock is as bad as it sounds.  It means your program</span>\n<span class=\"token comment\" spellcheck=\"true\">/// just stops.  ofMutex prevents race conditions, deadlocks and crashes by</span>\n<span class=\"token comment\" spellcheck=\"true\">/// permitting only one thread access to shared data at a time.  When using</span>\n<span class=\"token comment\" spellcheck=\"true\">/// mutexes to protect data, the trick is to always be sure to unlock the</span>\n<span class=\"token comment\" spellcheck=\"true\">/// mutex when finished.  This problem can often be avoided by using</span>\n<span class=\"token comment\" spellcheck=\"true\">/// an Poco::FastMutex::ScopedLock (aka ofScopedLock).  See the</span>\n<span class=\"token comment\" spellcheck=\"true\">/// the documentation for more information.  Finally, there are many cases</span>\n<span class=\"token comment\" spellcheck=\"true\">/// where it might make more sense to use Poco::Thread, Poco::Runnable and</span>\n<span class=\"token comment\" spellcheck=\"true\">/// Poco::FastMutex directly rather than using ofThread.  Further, cross</span>\n<span class=\"token comment\" spellcheck=\"true\">/// platform thread management will be alleviated with the std::thread</span>\n<span class=\"token comment\" spellcheck=\"true\">/// support library included with C++11.</span>\n<span class=\"token comment\" spellcheck=\"true\">///</span>\n<span class=\"token comment\" spellcheck=\"true\">/// Uncaught Exceptions throw from within ofThread will cause the thread to stop</span>\n<span class=\"token comment\" spellcheck=\"true\">/// and the Exception will be delivered to the default ofBaseThreadErrorHandler.</span>\n<span class=\"token comment\" spellcheck=\"true\">/// The ofBaseThreadErrorHandler will print the exception details, if available.</span>\n<span class=\"token comment\" spellcheck=\"true\">/// The ofBaseThreadErrorHandler offers no opportunity to take corrective action</span>\n<span class=\"token comment\" spellcheck=\"true\">/// and only allows the user to receive more valuable debugging information</span>\n<span class=\"token comment\" spellcheck=\"true\">/// about the uncaught exception.  Users should design ofThread subclasses to</span>\n<span class=\"token comment\" spellcheck=\"true\">/// catch and respond to all anticipated exceptions.</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">ofThread</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// \\brief Create an ofThread.</span>\n    <span class=\"token function\">ofThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/// \\brief Check the running status of the thread.</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// \\returns true iff the thread is currently running.</span>\n    <span class=\"token keyword\">bool</span> <span class=\"token function\">isThreadRunning</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/// \\brief Get the unique thread id.</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// \\note This is NOT the the same as the operating thread id!</span>\n    std<span class=\"token operator\">::</span>thread<span class=\"token operator\">::</span>id <span class=\"token function\">getThreadId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/// \\brief Get the unique thread name, in the form of \"Thread id#\"</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// \\returns the Thread ID string.</span>\n    std<span class=\"token operator\">::</span>string <span class=\"token function\">getThreadName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">setThreadName</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> std<span class=\"token operator\">::</span>string <span class=\"token operator\">&amp;</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token comment\" spellcheck=\"true\">/// \\brief Start the thread.</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// \\note Subclasses can directly access the mutex and employ thier</span>\n    <span class=\"token comment\" spellcheck=\"true\">///       own locking strategy.</span>\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">startThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token comment\" spellcheck=\"true\">/// \\brief Start the thread with options.</span>\n\t<span class=\"token comment\" spellcheck=\"true\">/// \\param mutexBlocks Set blocking to true if you want the mutex to</span>\n\t<span class=\"token comment\" spellcheck=\"true\">///        block when lock() is called.</span>\n\t<span class=\"token comment\" spellcheck=\"true\">/// \\note Subclasses can directly access the mutex and employ thier</span>\n\t<span class=\"token comment\" spellcheck=\"true\">///       own locking strategy.</span>\n\t<span class=\"token function\">OF_DEPRECATED_MSG</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Use tryLock instead of setting the type of lock on startThread\"</span><span class=\"token punctuation\">,</span>\n\t\t\t\t  <span class=\"token keyword\">void</span> <span class=\"token function\">startThread</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">bool</span> mutexBlocks<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token comment\" spellcheck=\"true\">/// \\brief Lock the mutex.</span>\n    <span class=\"token comment\" spellcheck=\"true\">///</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// If the thread was started startThread(true), then this call will wait</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// until the mutex is available and return true.  If the thread was started</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// startThread(false), this call will return true iff the mutex is</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// was successfully acquired.</span>\n    <span class=\"token comment\" spellcheck=\"true\">///</span>\n\t<span class=\"token comment\" spellcheck=\"true\">/// \\returns true if the lock was successfully acquired.</span>\n    <span class=\"token keyword\">bool</span> <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token comment\" spellcheck=\"true\">/// \\brief Tries to lock the mutex.</span>\n\t<span class=\"token comment\" spellcheck=\"true\">///</span>\n\t<span class=\"token comment\" spellcheck=\"true\">/// If the thread was started startThread(true), then this call will wait</span>\n\t<span class=\"token comment\" spellcheck=\"true\">/// until the mutex is available and return true.  If the thread was started</span>\n\t<span class=\"token comment\" spellcheck=\"true\">/// startThread(false), this call will return true iff the mutex is</span>\n\t<span class=\"token comment\" spellcheck=\"true\">/// was successfully acquired.</span>\n\t<span class=\"token comment\" spellcheck=\"true\">///</span>\n\t<span class=\"token comment\" spellcheck=\"true\">/// \\returns true if the lock was successfully acquired.</span>\n\t<span class=\"token keyword\">bool</span> <span class=\"token function\">tryLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/// \\brief Unlock the mutex.</span>\n    <span class=\"token comment\" spellcheck=\"true\">///</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// This will only unlocks the mutex if it was previously by the same</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// calling thread.</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/// \\brief Stop the thread.</span>\n    <span class=\"token comment\" spellcheck=\"true\">///</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// This does immediately stop the thread from processing, but</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// will only set a flag that must be checked from within your</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// threadedFunction() by calling isThreadRunning().  If the user wants</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// to both stop the thread AND wait for the thread to finish</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// processing, the user should call waitForThread(true, ...).</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">stopThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/// \\brief Wait for the thread to exit (aka \"joining\" the thread).</span>\n    <span class=\"token comment\" spellcheck=\"true\">///</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// This method waits for a thread will \"block\" and wait for the</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// thread (aka \"join\" the thread) before it returns.  This allows the</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// user to be sure that the thread is properly cleaned up.  An example</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// of when this might be particularly important is if the</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// threadedFunction() is opening a set of network sockets, or</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// downloading data from the web.  Destroying an ofThread subclass</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// without releasing those sockets (or other resources), may result in</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// segmentation faults, error signals or other undefined behaviors.</span>\n    <span class=\"token comment\" spellcheck=\"true\">///</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// \\param callStopThread Set stop to true if you want to signal the thread</span>\n    <span class=\"token comment\" spellcheck=\"true\">///     to exit before waiting.  This is the equivalent to calling</span>\n    <span class=\"token comment\" spellcheck=\"true\">///     stopThread(). If you your threadedFunction uses a while-loop that</span>\n    <span class=\"token comment\" spellcheck=\"true\">///     depends on isThreadRunning() and you do not call stopThread() or set</span>\n    <span class=\"token comment\" spellcheck=\"true\">///     stop == true, waitForThread will hang indefinitely.  Set stop ==</span>\n    <span class=\"token comment\" spellcheck=\"true\">///     false ONLY if you have already called stopThread() and you simply</span>\n    <span class=\"token comment\" spellcheck=\"true\">///     need to be sure your thread has finished its tasks.</span>\n    <span class=\"token comment\" spellcheck=\"true\">///</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// \\param milliseconds If millseconds is set to INFINITE_JOIN_TIMEOUT, the</span>\n    <span class=\"token comment\" spellcheck=\"true\">///     waitForThread will wait indefinitely for the thread to complete.  If</span>\n    <span class=\"token comment\" spellcheck=\"true\">///     milliseconds is set to a lower number (e.g. 10000 for 10 seconds),</span>\n    <span class=\"token comment\" spellcheck=\"true\">///     waitForThread will wait for 10000 milliseconds and if the thread has</span>\n    <span class=\"token comment\" spellcheck=\"true\">///     not yet stopped it will return and log an error message.  Users are</span>\n    <span class=\"token comment\" spellcheck=\"true\">///     encouraged to use the default INFINITE_JOIN_TIMEOUT.  If the user is</span>\n    <span class=\"token comment\" spellcheck=\"true\">///     unhappy with the amount of time it takes to join a thread, the user</span>\n    <span class=\"token comment\" spellcheck=\"true\">///     is encouraged to seek more expedient ways of signalling their desire</span>\n    <span class=\"token comment\" spellcheck=\"true\">///     for a thread to complete via other signalling methods such as</span>\n    <span class=\"token comment\" spellcheck=\"true\">///     Poco::Event, Poco::Condition, or Poco::Semaphore.</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// \\sa http://pocoproject.org/slides/090-NotificationsEvents.pdf</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// \\sa http://pocoproject.org/docs/Poco.Condition.html</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// \\sa http://pocoproject.org/docs/Poco.Event.html</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// \\sa http://pocoproject.org/docs/Poco.Semaphore.html</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">waitForThread</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">bool</span> callStopThread <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n                       <span class=\"token keyword\">long</span> milliseconds <span class=\"token operator\">=</span> INFINITE_JOIN_TIMEOUT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/// \\brief Tell the thread to sleep for a certain amount of milliseconds.</span>\n    <span class=\"token comment\" spellcheck=\"true\">///</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// This is useful inside the threadedFunction() when a thread is waiting</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// for input to process:</span>\n    <span class=\"token comment\" spellcheck=\"true\">///</span>\n    <span class=\"token comment\" spellcheck=\"true\">///     void MyThreadedClass::threadedFunction()</span>\n    <span class=\"token comment\" spellcheck=\"true\">///     {</span>\n    <span class=\"token comment\" spellcheck=\"true\">///\t\t    // start</span>\n    <span class=\"token comment\" spellcheck=\"true\">///\t\t    while(isThreadRunning())</span>\n    <span class=\"token comment\" spellcheck=\"true\">///         {</span>\n    <span class=\"token comment\" spellcheck=\"true\">///             // bReadyToProcess can be set from outside the threadedFuntion.</span>\n    <span class=\"token comment\" spellcheck=\"true\">///             // perhaps by another thread that downloads data, or loads</span>\n    <span class=\"token comment\" spellcheck=\"true\">///             // some media, etc.</span>\n    <span class=\"token comment\" spellcheck=\"true\">///</span>\n    <span class=\"token comment\" spellcheck=\"true\">///\t\t    \tif(bReadyToProcess == true)</span>\n    <span class=\"token comment\" spellcheck=\"true\">///             {</span>\n    <span class=\"token comment\" spellcheck=\"true\">///\t\t    \t\t// do some time intensive processing</span>\n    <span class=\"token comment\" spellcheck=\"true\">///\t\t    \t\tbReadyToProcess = false;</span>\n    <span class=\"token comment\" spellcheck=\"true\">///\t\t    \t}</span>\n    <span class=\"token comment\" spellcheck=\"true\">///             else</span>\n    <span class=\"token comment\" spellcheck=\"true\">///             {</span>\n    <span class=\"token comment\" spellcheck=\"true\">///\t\t    \t\t// sleep the thread to give up some cpu</span>\n    <span class=\"token comment\" spellcheck=\"true\">///\t\t    \t\tsleep(20);</span>\n    <span class=\"token comment\" spellcheck=\"true\">///\t\t    \t}</span>\n    <span class=\"token comment\" spellcheck=\"true\">///\t\t    }</span>\n    <span class=\"token comment\" spellcheck=\"true\">///\t\t    // done</span>\n    <span class=\"token comment\" spellcheck=\"true\">///     }</span>\n    <span class=\"token comment\" spellcheck=\"true\">///</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// If the user does not give the thread a chance to sleep, the</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// thread may take 100% of the CPU core while it's looping as it</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// waits for something to do.  This may lead to poor application</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// performance.</span>\n    <span class=\"token comment\" spellcheck=\"true\">///</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// \\param milliseconds The number of milliseconds to sleep.</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> milliseconds<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/// \\brief Tell the thread to give up its CPU time other threads.</span>\n    <span class=\"token comment\" spellcheck=\"true\">///</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// This method is similar to sleep() and can often be used in</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// the same way.  The main difference is that 1 millisecond</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// (the minimum sleep time available with sleep()) is a very</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// long time on modern processors and yield() simply gives up</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// processing time to the next thread, instead of waiting for</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// number of milliseconds. In some cases, this behavior will</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// be preferred.</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">yield</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/// \\brief Query whether the current thread is active.</span>\n    <span class=\"token comment\" spellcheck=\"true\">///</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// In multithreaded situations, it can be useful to know which</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// thread is currently running some code in order to make sure</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// only certain threads can do certain things.  For example,</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// OpenGL can only run in the main execution thread.  Thus,</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// situations where a thread is responsible for interacting</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// with graphics resources may need to prevent graphics updates</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// unless the main thread is accessing or updating resources</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// shared with this ofThread (or its subclass).</span>\n    <span class=\"token comment\" spellcheck=\"true\">///</span>\n    <span class=\"token comment\" spellcheck=\"true\">///     if(myThread.isCurrentThread())</span>\n    <span class=\"token comment\" spellcheck=\"true\">///     {</span>\n    <span class=\"token comment\" spellcheck=\"true\">///         // do some myThread things,</span>\n    <span class=\"token comment\" spellcheck=\"true\">///         // but keep your hands off my resources!</span>\n    <span class=\"token comment\" spellcheck=\"true\">///     }</span>\n    <span class=\"token comment\" spellcheck=\"true\">///     else if(ofThread::isMainThread())</span>\n    <span class=\"token comment\" spellcheck=\"true\">///     {</span>\n    <span class=\"token comment\" spellcheck=\"true\">///         // pheew! ok, update those graphics resources</span>\n    <span class=\"token comment\" spellcheck=\"true\">///     }</span>\n    <span class=\"token comment\" spellcheck=\"true\">///</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// By way of another example, a subclass of ofThread may have</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// an update() method that is called from ofBaseApp during the</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// execution of the main application thread.  In these cases,</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// the ofThread subclass might want to ask itself whether it</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// can, for instance, call update() on an ofImage, in order to</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// send copy some ofPixels to an ofTexture on the graphics</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// card.</span>\n    <span class=\"token comment\" spellcheck=\"true\">///</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// \\returns True iff this ofThread the currently active thread.</span>\n    <span class=\"token keyword\">bool</span> <span class=\"token function\">isCurrentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/// \\brief Get a reference to the underlying Poco thread.</span>\n    <span class=\"token comment\" spellcheck=\"true\">///</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// Poco::Thread provides a clean cross-platform wrapper for</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// threads.  On occasion, it may be useful to interact with the</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// underlying Poco::Thread directly.</span>\n    <span class=\"token comment\" spellcheck=\"true\">///</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// \\returns A reference to the backing Poco thread.</span>\n    std<span class=\"token operator\">::</span>thread<span class=\"token operator\">&amp;</span> <span class=\"token function\">getNativeThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/// \\brief Get a const reference to the underlying Poco thread.</span>\n    <span class=\"token comment\" spellcheck=\"true\">///</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// Poco::Thread provides a clean cross-platform wrapper for</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// threads.  On occasion, it may be useful to interact with the</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// underlying Poco::Thread directly.</span>\n    <span class=\"token comment\" spellcheck=\"true\">///</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// \\returns A reference to the backing Poco thread.</span>\n    <span class=\"token keyword\">const</span> std<span class=\"token operator\">::</span>thread <span class=\"token operator\">&amp;</span> <span class=\"token function\">getNativeThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span>\n\n\n    <span class=\"token keyword\">enum</span> <span class=\"token punctuation\">{</span>\n        INFINITE_JOIN_TIMEOUT <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span>\n            <span class=\"token comment\" spellcheck=\"true\">///&lt; \\brief A sentinal value for an infinite join timeout.</span>\n            <span class=\"token comment\" spellcheck=\"true\">///&lt;</span>\n            <span class=\"token comment\" spellcheck=\"true\">///&lt; Primarily used with the waitForThread() method.</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">protected</span><span class=\"token operator\">:</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// \\brief The thread's run function.</span>\n    <span class=\"token comment\" spellcheck=\"true\">///</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// Users must overide this in your their derived class</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// and then implement their threaded activity inside the loop.</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// If the the users's threadedFunction does not have a loop,</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// the contents of the threadedFunction will be executed once</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// and the thread will then exit.</span>\n    <span class=\"token comment\" spellcheck=\"true\">///</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// For tasks that must be repeated, the user can use a while</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// loop that will run repeatedly until the thread's</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// threadRunning is set to false via the stopThread() method.</span>\n    <span class=\"token comment\" spellcheck=\"true\">///</span>\n    <span class=\"token comment\" spellcheck=\"true\">///     void MyThreadedClass::threadedFunction()</span>\n    <span class=\"token comment\" spellcheck=\"true\">///     {</span>\n    <span class=\"token comment\" spellcheck=\"true\">///         // Start the loop and continue until</span>\n    <span class=\"token comment\" spellcheck=\"true\">///         // isThreadRunning() returns false.</span>\n    <span class=\"token comment\" spellcheck=\"true\">///         while(isThreadRunning())</span>\n    <span class=\"token comment\" spellcheck=\"true\">///         {</span>\n    <span class=\"token comment\" spellcheck=\"true\">///             // Do activity repeatedly here:</span>\n    <span class=\"token comment\" spellcheck=\"true\">///</span>\n    <span class=\"token comment\" spellcheck=\"true\">///             // int j = 1 + 1;</span>\n    <span class=\"token comment\" spellcheck=\"true\">///</span>\n    <span class=\"token comment\" spellcheck=\"true\">///             // This while loop will run as fast as it possibly</span>\n    <span class=\"token comment\" spellcheck=\"true\">///             // can, consuming as much processor speed as it can.</span>\n    <span class=\"token comment\" spellcheck=\"true\">///             // To help the processor stay cool, users are</span>\n    <span class=\"token comment\" spellcheck=\"true\">///             // encouraged to let the while loop sleep via the</span>\n    <span class=\"token comment\" spellcheck=\"true\">///             // sleep() method, or call the yield() method to let</span>\n    <span class=\"token comment\" spellcheck=\"true\">///             // other threads have a turn.  See the sleep() and</span>\n    <span class=\"token comment\" spellcheck=\"true\">///             // yield() methods for more information.</span>\n    <span class=\"token comment\" spellcheck=\"true\">///</span>\n    <span class=\"token comment\" spellcheck=\"true\">///             // sleep(100);</span>\n    <span class=\"token comment\" spellcheck=\"true\">///         }</span>\n    <span class=\"token comment\" spellcheck=\"true\">///     }</span>\n    <span class=\"token comment\" spellcheck=\"true\">///</span>\n    <span class=\"token keyword\">virtual</span> <span class=\"token keyword\">void</span> <span class=\"token function\">threadedFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/// \\brief The Poco::Thread that runs the Poco::Runnable.</span>\n    std<span class=\"token operator\">::</span>thread thread<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/// \\brief The internal mutex called through lock() &amp; unlock().</span>\n    <span class=\"token comment\" spellcheck=\"true\">///</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// This mutext can also be used with std::unique_lock or lock_guard</span>\n    <span class=\"token comment\" spellcheck=\"true\">/// within the threaded function by calling:</span>\n    <span class=\"token comment\" spellcheck=\"true\">///</span>\n    <span class=\"token comment\" spellcheck=\"true\">///     std::unique_lock&lt;std::mutex> lock(mutex);</span>\n    <span class=\"token comment\" spellcheck=\"true\">///</span>\n    <span class=\"token keyword\">mutable</span> std<span class=\"token operator\">::</span>mutex mutex<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n    <span class=\"token comment\" spellcheck=\"true\">///&lt; \\brief Implements Poco::Runnable::run().</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">///&lt; \\brief Is the thread running?</span>\n    std<span class=\"token operator\">::</span>atomic<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token operator\">></span> threadRunning<span class=\"token punctuation\">;</span>\n    std<span class=\"token operator\">::</span>atomic<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token operator\">></span> threadDone<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">///&lt; \\brief Should the mutex block?</span>\n    std<span class=\"token operator\">::</span>atomic<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token operator\">></span> mutexBlocks<span class=\"token punctuation\">;</span>\n\n    std<span class=\"token operator\">::</span>string name<span class=\"token punctuation\">;</span>\n    std<span class=\"token operator\">::</span>condition_variable condition<span class=\"token punctuation\">;</span>\n\n\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">else</span></span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">ofThread</span><span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">startThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">stopThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">bool</span> <span class=\"token function\">isThreadRunning</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">enum</span> <span class=\"token punctuation\">{</span>\n        INFINITE_JOIN_TIMEOUT <span class=\"token operator\">=</span> LONG_MAX\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">endif</span></span>\n","type":"source","static":true}}],"fetch":[]}