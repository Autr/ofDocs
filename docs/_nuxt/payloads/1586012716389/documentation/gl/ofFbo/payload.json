{"data":[{"page":{"entry":{"name":"ofFbo","filename":"ofFbo.markdown","absolute":"/Users/Gilbert/Code/openFrameworks/ofSite/documentation/gl/ofFbo.markdown","path":"/documentation/gl/ofFbo","route":"/documentation/gl/ofFbo.markdown","dir":"../ofSite/documentation/gl","ext":"markdown","type":"page","id":2201,"parent":2192,"breadcrumbs":[2192,1968],"siblings":[],"translations":{}},"description":{"short":"","full":"<p>At it's core the ofFBO is a container for textures and an optional depth buffer. Kind of like, well, an OpenGL framebuffer, which is what you're normally rendering to. One way, conceptually correct but technically a bit loose, is that it's another renderer that you can write to. You can draw textures to it, draw 3D or 2D objects to it, render the view of cameras inside of it, all with one key difference: it's just an object stored on the graphics card that represents a rendered drawing pass. You can have multiple of them, draw all kinds of things inside of them, and then get all the textures out of them to play with in a shader or just draw them directly to the screen. They are, for most purposes, little render buffers that you can render to and store without needing to be drawing to the screen.</p>\n<p>To start working with an ofFbo, you have to allocate it, the same way that you would with an ofTexture:</p>\n<pre><code class=\"language-{.cpp}\">fbo<span class=\"token punctuation\">.</span><span class=\"token function\">allocate</span><span class=\"token punctuation\">(</span><span class=\"token number\">400</span><span class=\"token punctuation\">,</span> <span class=\"token number\">400</span><span class=\"token punctuation\">,</span> GL_RGBA<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// with alpha, 8 bits red, 8 bits green, 8 bits blue, 8 bits alpha, from 0 to 255 in 256 steps</span>\n</code></pre>\n<p>Often the FBO will contain artefacts from the memory that the graphics card has just allocated for it, so it's good to clear it before starting to draw it:</p>\n<pre><code class=\"language-{.cpp}\">    fbo<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">ofClear</span><span class=\"token punctuation\">(</span><span class=\"token number\">255</span><span class=\"token punctuation\">,</span><span class=\"token number\">255</span><span class=\"token punctuation\">,</span><span class=\"token number\">255</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    fbo<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>When you call begin() you're telling the framebuffer to store the rendered results of any drawing calls (or shaders for that matter) in the FBO:</p>\n<pre><code class=\"language-{.cpp}\"><span class=\"token keyword\">float</span> alpha <span class=\"token operator\">=</span> <span class=\"token function\">ofMap</span><span class=\"token punctuation\">(</span><span class=\"token function\">ofGetMouseX</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token function\">ofGetWidth</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">255</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nfbo<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">ofSetColor</span><span class=\"token punctuation\">(</span><span class=\"token number\">255</span><span class=\"token punctuation\">,</span><span class=\"token number\">255</span><span class=\"token punctuation\">,</span><span class=\"token number\">255</span><span class=\"token punctuation\">,</span> alpha<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">ofDrawRectangle</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">400</span><span class=\"token punctuation\">,</span><span class=\"token number\">400</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nfbo<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>When it's time to draw your FBO, you can simply call draw:</p>\n<pre><code class=\"language-{.cpp}\"><span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">draw</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\tfbo<span class=\"token punctuation\">.</span><span class=\"token function\">draw</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>If you want to pass the FBO to say, an ofShader, you do:</p>\n<pre><code class=\"language-{.cpp}\">shader<span class=\"token punctuation\">.</span><span class=\"token function\">setUniformTexture</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"fboTexture\"</span><span class=\"token punctuation\">,</span> fbo<span class=\"token punctuation\">.</span><span class=\"token function\">getTextureReference</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>You can also use the ofFbo::Settings object to create a more customized FBO that allows you to set the internal format of the depth and stencil textures, create multiple textures to render to, and use different texture targets, among other things.</p>\n<p>ofFbo can be a little confusing because it wraps two related, but distinct things in OpenGL: Textures and RenderBuffers. The difference conceptually isn't huge, but it's important if you're looking to understand deeply what's going on inside the ofFbo. RenderBuffers are good for rendering to, not drawing, whereas Textures are ok for both but slightly slower. More info on both <a href=\"http://www.opengl.org/wiki/Renderbuffer_Objects\">here</a> and <a href=\"http://www.opengl.org/wiki/Framebuffer_Object\">here</a></p>\n<h1></h1>\n"},"config":{"visible":"True","advanced":"False","istemplated":"False","extends":"ofBaseDraws, ofBaseHasTexture"},"methods":[{"syntax":"activateAllDrawBuffers()","name":"activateAllDrawBuffers","returns":"void","returns_description":null,"parameters":null,"access":"public","version_started":"0071","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>This method allows you to render the results of a shading pass to all the textures inside the FBO. It's  handy if you have many textures inside your FBO, for instance, a normals texture, a colored depth texture, a color texture, and you want to have a shader render to all of them at once. It calls glDrawBuffers() internally, which you can learn more about <a href=\"https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawBuffers.xhtml\">here</a>.</p>\n","counter":0},{"syntax":"allocate(settings)","name":"allocate","returns":"void","returns_description":null,"parameters":"ofFboSettings settings","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>You can also allocate the ofFbo using a Settings object</p>\n","counter":1},{"syntax":"allocate(width, height, internalformat, numSamples = 0)","name":"allocate","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">int</span> width<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> height<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> internalformat<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> numSamples<span class=\"token operator\">=</span><span class=\"token number\">0</span>","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Before you use the fbo you need to allocate it. This sets the width, height, and GL type of the fbo (i.e. whether it has alpha data or not) and the number of samples for MSAA. MSAA is sort of a big topic.\nMSAA is what you typically have in hardware on a modern graphics card. The graphics card renders to a surface that is larger than the final image, but in shading each &quot;cluster&quot; of samples (that will end up in a single pixel on the final screen) the pixel shader is run only once. We save a ton of fill rate, but we still burn memory bandwidth.\nThis technique does not anti-alias any effects coming out of the shader, because the shader runs at 1x, so alpha cutouts are jagged. This is the most common way to run a forward-rendering game. MSAA does not work for a deferred renderer because lighting decisions are made after the MSAA is &quot;resolved&quot; (down-sized) to its final image size.</p>\n"},{"syntax":"attachTexture(&texture, internalFormat, attachmentPoint)","name":"attachTexture","returns":"void","returns_description":null,"parameters":"ofTexture <span class=\"token operator\">&amp;</span>texture<span class=\"token punctuation\">,</span> GLenum internalFormat<span class=\"token punctuation\">,</span> GLenum attachmentPoint","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"","counter":0},{"syntax":"begin(mode)","name":"begin","returns":"void","returns_description":null,"parameters":"ofFboMode mode","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Sets up the framebuffer and binds it for rendering.</p>\n<p>The mode parameter indicates which defaults are set when binding\nthe fbo.</p>\n<p>The default OF_FBOMODE_PERSPECTIVE | OF_FBOMODE_MATRIXFLIP\nwill set the screen perspective to the OF default for the fbo size, the\ncorrect viewport to cover the full fbo and will flip the orientation\nmatrix in y so when drawing the fbo later or accesing it from a shader\nit's correctly oriented</p>\n<p>Passing OF_FBOMODE_PERSPECTIVE will only set perspective and viewport</p>\n<p>Passing OF_FBOMODE_MATRIXFLIP won't set the perspective but will flip\nthe matrix.</p>\n<p>Passing OF_FBOMODE_NODEFAULTS won't change anything and just bind the fbo\nand set it as current rendering surface in OF</p>\n<p><strong>Warning</strong>:  This is a convenience method, and is considered unsafe\nin multi-window and/or multi-renderer scenarios.\nIf you use more than one renderer, use each renderer's\nexplicit void ofBaseGLRenderer::begin(const ofFbo &amp; fbo, ofFboMode mode)\nmethod instead.</p>\n<p><strong>See also</strong>:       void ofBaseGLRenderer::begin(const ofFbo &amp; fbo, ofFboMode mode)</p>\n","desc":"<p>Any drawing that you do after begin() is drawn into the fbo rather than the screen. This is how you draw things into your ofFbo instance.</p>\n","counter":0},{"syntax":"bind()","name":"bind","returns":"void","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Bind OpenGL GL_FRAMEBUFFER target to this ofFbo</p>\n<p><strong>Warning</strong>:  If you use this method, you need to manually keep track of the\ncurrently bound framebuffer, if you ever want to restore state.\n* use ofBaseGLRenderer::getCurrentFramebuffer() to query the current\nframebuffer binding state within the renderer.\n* Better, use the renderer's explicit method:\nofBaseGLRenderer::bind(const ofFbo &amp; fbo) to bind the fbo, to allow\nthe renderer to keep track of any bound fbos.</p>\n<p><strong>See also</strong>:       unbind()</p>\n<p><strong>See also</strong>:       virtual void ofBaseGLRenderer::bind(const ofFbo &amp; fbo)</p>\n","desc":"<p>This function is internally called by ofFbo::begin() after setting up the\nviewport to draw things into your ofFbo instance.</p>\n<p>To map the fbo to ofRectangle, ofMesh, or other vertex based drawing, call</p>\n<pre><code class=\"language-cpp\">fbo<span class=\"token punctuation\">.</span><span class=\"token function\">getTextureReference</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmesh<span class=\"token punctuation\">.</span><span class=\"token function\">draw</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nfbo<span class=\"token punctuation\">.</span><span class=\"token function\">getTextureReference</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">unbind</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n","counter":0},{"syntax":"checkGLSupport()","name":"checkGLSupport","returns":"bool","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"True","visible":"True","advanced":"False","short":"","desc":"<p>This allows you quickly check whether your graphics card supports FBO objects.</p>\n","counter":0},{"syntax":"checkStatus()","name":"checkStatus","returns":"bool","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>This checks the status of your FBO object.</p>\n","counter":0},{"syntax":"clear()","name":"clear","returns":"void","returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"","counter":0},{"syntax":"clearColorBuffer(&color)","name":"clearColorBuffer","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofFloatColor <span class=\"token operator\">&amp;</span>color","access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>glClearBufferfv(GL_COLOR, 0...)</p>\n<p>@see: https://www.opengl.org/wiki/GLAPI/glClearBuffer</p>\n","desc":"","counter":1},{"syntax":"clearColorBuffer(buffer_idx, &color)","name":"clearColorBuffer","returns":"void","returns_description":null,"parameters":"size_t buffer_idx<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> ofFloatColor <span class=\"token operator\">&amp;</span>color","access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>glClearBufferfv(GL_COLOR, buffer_idx...)</p>\n<p>@see: https://www.opengl.org/wiki/GLAPI/glClearBuffer</p>\n","desc":""},{"syntax":"clearDepthBuffer(value)","name":"clearDepthBuffer","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> value","access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>glClearBufferfv(GL_DEPTH...)</p>\n<p>@see: https://www.opengl.org/wiki/GLAPI/glClearBuffer</p>\n","desc":"","counter":0},{"syntax":"clearDepthStencilBuffer(depth, stencil)","name":"clearDepthStencilBuffer","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> depth<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> stencil","access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>glClearBufferfi(GL_DEPTH_STENCIL...)</p>\n<p>@see: https://www.opengl.org/wiki/GLAPI/glClearBuffer</p>\n","desc":"","counter":0},{"syntax":"clearStencilBuffer(value)","name":"clearStencilBuffer","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">int</span> value","access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>glClearBufferiv(GL_STENCIL...)</p>\n<p>@see: https://www.opengl.org/wiki/GLAPI/glClearBuffer</p>\n","desc":"","counter":0},{"syntax":"copyTo(&buffer)","name":"copyTo","returns":"void","returns_description":null,"parameters":"ofBufferObject <span class=\"token operator\">&amp;</span>buffer","access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Copy the fbo to an ofBufferObject.</p>\n<p><strong>Parameters:</strong></p>\n<p>buffer the target buffer to copy to.</p>\n","desc":"","counter":0},{"syntax":"createAndAttachDepthStencilTexture(target, internalformat, attachment)","name":"createAndAttachDepthStencilTexture","returns":"void","returns_description":null,"parameters":"GLenum target<span class=\"token punctuation\">,</span> GLint internalformat<span class=\"token punctuation\">,</span> GLenum attachment","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>FBOs usually have two textures that are created inside of them: a color texture to hold all of the colors of objects that are rendered and a depth texture that represents all the depth values of objects that are rendered. While there are more esoteric reasons for generating a depth texture, a common one is that depth textures can be used in a vertex or fragment shader to figure out how far away from the camera (and possibly by extension a light) something is.</p>\n<p>These are created with the default ofFbo::Settings, which means that unless you don't want one, you have a depth buffer to play with that you can access with:</p>\n<pre><code class=\"language-{.cpp}\">fbo<span class=\"token punctuation\">.</span><span class=\"token function\">getDepthTexture</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>The attachment point is the index of the texture that you're going to be referring to within the FBO. By default this should just be GL_DEPTH_STENCIL but if you know what you're doing and don't want a stencil buffer you can use GL_DEPTH_ATTACHMENT or vice versa, GL_STENCIL_ATTACHMENT.</p>\n","counter":1},{"syntax":"createAndAttachDepthStencilTexture(target, internalformat, attachment, transferFormat, transferType)","name":"createAndAttachDepthStencilTexture","returns":"void","returns_description":null,"parameters":"GLenum target<span class=\"token punctuation\">,</span> GLint internalformat<span class=\"token punctuation\">,</span> GLenum attachment<span class=\"token punctuation\">,</span> GLenum transferFormat<span class=\"token punctuation\">,</span> GLenum transferType","access":"public","version_started":"0071","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>FBOs usually have two textures that are created inside of them: a color texture to hold all of the colors of objects that are rendered and a depth texture that represents all the depth values of objects that are rendered. While there are more esoteric reasons for generating a depth texture, a common one is that depth textures can be used in a vertex or fragment shader to figure out how far away from the camera (and possibly by extension a light) something is.</p>\n<p>These are created with the default ofFbo::Settings, which means that unless you don't want one, you have a depth buffer to play with that you can access with:</p>\n<pre><code class=\"language-{.cpp}\">fbo<span class=\"token punctuation\">.</span><span class=\"token function\">getDepthTexture</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>The attachment point is the index of the texture that you're going to be referring to within the FBO. By default this should just be GL_DEPTH_STENCIL but if you know what you're doing and don't want a stencil buffer you can use GL_DEPTH_ATTACHMENT or vice versa, GL_STENCIL_ATTACHMENT.</p>\n<p>The extra parameters on this method allow you to set the type of depth buffer that you want to create, which is handy if you need particular fidelity for depth, for instance, GL_DEPTH32.</p>\n"},{"syntax":"createAndAttachRenderbuffer(internalFormat, attachmentPoint)","name":"createAndAttachRenderbuffer","returns":"GLuint","returns_description":null,"parameters":"GLenum internalFormat<span class=\"token punctuation\">,</span> GLenum attachmentPoint","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>This creates a texture of the specified format and attaches it to the FBO at the index specified. Most of this can be handled for you by using the ofFbo::Settings object. RenderBuffers are slightly different than textures, more info can be found on the <a href=\"http://www.opengl.org/wiki/Renderbuffer_Objects\">OpenGL Wiki</a>.</p>\n","counter":0},{"syntax":"createAndAttachTexture(internalFormat, attachmentPoint)","name":"createAndAttachTexture","returns":"void","returns_description":null,"parameters":"GLenum internalFormat<span class=\"token punctuation\">,</span> GLenum attachmentPoint","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>This creates a texture of the specified format and attaches it to the FBO at the index specified. Most of this can be handled for you by using the ofFbo::Settings object.</p>\n","counter":0},{"syntax":"draw(x, y)","name":"draw","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> y","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>This allows you draw everything that's in your fbo to the screen using its default height and width at the x, y indicated.</p>\n","counter":1},{"syntax":"draw(x, y, width, height)","name":"draw","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> y<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> width<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> height","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>This allows you draw everything that's in your fbo to the screen using any height and width. Any stretching is up to you to handle appropriately.</p>\n"},{"syntax":"end()","name":"end","returns":"void","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Ends the current framebuffer render context.</p>\n<p><strong>See also</strong>:       void begin(bool setupScreen=true) const;</p>\n","desc":"<p>Any drawing that you do after end() is drawn to the screen rather than into the fbo buffer. This is how you stop drawing things into your ofFbo instance.</p>\n","counter":0},{"syntax":"flagDirty()","name":"flagDirty","returns":"void","returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"","counter":0},{"syntax":"getDefaultTextureIndex()","name":"getDefaultTextureIndex","returns":"int","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>If you've set the default texture reference, you can get access to it here.</p>\n","counter":0},{"syntax":"getDepthBuffer()","name":"getDepthBuffer","returns":"GLuint","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>This gives you the OpenGL id of the depth RenderBuffer that the fbo contains. The depthBuffer will only be created if you pass a Setting object with depthStencilAsTexture = false.</p>\n","counter":0},{"syntax":"getDepthTexture()","name":"getDepthTexture","returns":"ofTexture &","returns_description":null,"parameters":null,"access":"public","version_started":"0071","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>This gives you the OpenGL id of the depth Texture that the fbo contains. The depthBuffer will be created by default or if you pass a Setting object with depthStencilAsTexture = true.</p>\n","counter":1},{"syntax":"getDepthTexture()","name":"getDepthTexture","returns":"const ofTexture &","returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"getHeight()","name":"getHeight","returns":"float","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>This returns the height of the fbo. This is just like height of a texture: it sets how many pixels wide the allocated memory on the graphics card is.</p>\n","counter":0},{"syntax":"getId()","name":"getId","returns":"GLuint","returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>returns id of the underlying GL object for advanced actions</p>\n","desc":"","counter":0},{"syntax":"getIdDrawBuffer()","name":"getIdDrawBuffer","returns":"GLuint","returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>returns id of Fbo for texture attachments\nwhich is different when the fbo is using MSAA</p>\n","desc":"","counter":0},{"syntax":"getNumTextures()","name":"getNumTextures","returns":"int","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>This returns the number of textures that the fbo contains.</p>\n","counter":0},{"syntax":"getStencilBuffer()","name":"getStencilBuffer","returns":"GLuint","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>This gives you the OpenGL id of the stencil RenderBuffer that the fbo contains. The depthBuffer will only be created if you pass a Setting object with depthStencilAsTexture = false and settings.useStencil = true.</p>\n","counter":0},{"syntax":"getTexture()","name":"getTexture","returns":"ofTexture &","returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"","counter":3},{"syntax":"getTexture()","name":"getTexture","returns":"const ofTexture &","returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"getTexture(attachmentPoint)","name":"getTexture","returns":"ofTexture &","returns_description":null,"parameters":"<span class=\"token keyword\">int</span> attachmentPoint","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"getTexture(attachmentPoint)","name":"getTexture","returns":"const ofTexture &","returns_description":null,"parameters":"<span class=\"token keyword\">int</span> attachmentPoint","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"getWidth()","name":"getWidth","returns":"float","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>This returns the width of the fbo that was set when it was allocated. This is just like width of a texture: it sets how many pixels wide the allocated memory on the graphics card is.</p>\n","counter":0},{"syntax":"isAllocated()","name":"isAllocated","returns":"bool","returns_description":null,"parameters":null,"access":"public","version_started":"0071","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Returns whether your FBO is allocated or not.</p>\n","counter":0},{"syntax":"isUsingTexture()","name":"isUsingTexture","returns":"bool","returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"","counter":0},{"syntax":"maxColorAttachments()","name":"maxColorAttachments","returns":"int","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"True","visible":"True","advanced":"False","short":"","desc":"<p>This returns the max number of simultaneous max color attachments, i.e. textures that will just be used for color information.</p>\n","counter":0},{"syntax":"maxDrawBuffers()","name":"maxDrawBuffers","returns":"int","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"True","visible":"True","advanced":"False","short":"","desc":"<p>This returns the max number of simultaneous draw buffers that your graphics card supports, i.e. color buffers that can be drawn to simultaneously. This is usually 4 at present.</p>\n","counter":0},{"syntax":"maxSamples()","name":"maxSamples","returns":"int","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"True","visible":"True","advanced":"False","short":"","desc":"<p>This is the maximum number of MSAA samples that your graphic card supports.</p>\n","counter":0},{"syntax":"ofFbo(&&mom)","name":"ofFbo","returns":null,"returns_description":null,"parameters":"ofFbo <span class=\"token operator\">&amp;&amp;</span>mom","access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"","counter":2},{"syntax":"ofFbo(&mom)","name":"ofFbo","returns":null,"returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofFbo <span class=\"token operator\">&amp;</span>mom","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Copies all data from the mom fbo</p>\n"},{"syntax":"ofFbo()","name":"ofFbo","returns":null,"returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>This is the default constructor for the ofFbo.</p>\n"},{"syntax":"operator=(&&fbo)","name":"operator=","returns":"ofFbo &","returns_description":null,"parameters":"ofFbo <span class=\"token operator\">&amp;&amp;</span>fbo","access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"","counter":1},{"syntax":"operator=(&fbo)","name":"operator=","returns":"ofFbo &","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofFbo <span class=\"token operator\">&amp;</span>fbo","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>This overloaded operator allows you to set one fbo from another using the = operator. Very convenient.</p>\n"},{"syntax":"readToPixels(&pixels, attachmentPoint = 0)","name":"readToPixels","returns":"void","returns_description":null,"parameters":"ofPixels <span class=\"token operator\">&amp;</span>pixels<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> attachmentPoint<span class=\"token operator\">=</span><span class=\"token number\">0</span>","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>This allows you to get the pixels from an ofFbo and store it in an ofPixels instance. The attachmentPoint parameter allows you indicate which of the textures attached to the fbo you want to grab.</p>\n","counter":2},{"syntax":"readToPixels(&pixels, attachmentPoint = 0)","name":"readToPixels","returns":"void","returns_description":null,"parameters":"ofShortPixels <span class=\"token operator\">&amp;</span>pixels<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> attachmentPoint<span class=\"token operator\">=</span><span class=\"token number\">0</span>","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>This allows you to get the pixels from an ofFbo and store it in an ofShortPixels instance. The attachmentPoint parameter allows you indicate which of the textures attached to the fbo you want to grab. The ofShortPixels instance is useful when you want your image at short ints, or non-floating point values.</p>\n"},{"syntax":"readToPixels(&pixels, attachmentPoint = 0)","name":"readToPixels","returns":"void","returns_description":null,"parameters":"ofFloatPixels <span class=\"token operator\">&amp;</span>pixels<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> attachmentPoint<span class=\"token operator\">=</span><span class=\"token number\">0</span>","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>This allows you to get the pixels from an ofFbo and store it in an ofFloatPixels instance. The attachmentPoint parameter allows you indicate which of the textures attached to the fbo you want to grab. The ofShortPixels instance is useful when you want your image as floating point values.</p>\n"},{"syntax":"reloadFbo()","name":"reloadFbo","returns":"void","returns_description":null,"parameters":null,"access":"private","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"","counter":0},{"syntax":"resetAnchor()","name":"resetAnchor","returns":"void","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>This allows you reset the anchor position.</p>\n","counter":0},{"syntax":"setActiveDrawBuffer(i)","name":"setActiveDrawBuffer","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">int</span> i","access":"public","version_started":"0071","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>This sets which texture within your FBO is going contain the results of any drawing method or shading pass, particularly useful if you have multiple color textures, for instance, a normals texture and a color value texture. Doing multiple rendering passes on different objects is called <a href=\"http://en.wikipedia.org/wiki/Deferred_shading\">Deferred Shading</a> and is a tricky but powerful technique.</p>\n","counter":0},{"short":"","desc":"<p>This sets which texture within your FBO is going contain the results of any drawing method or shading pass, particularly useful if you have multiple color textures, for instance, a normals texture and a color value texture. Doing multiple rendering passes on different objects is called <a href=\"http://en.wikipedia.org/wiki/Deferred_shading\">Deferred Shading</a> and is a tricky but powerful technique.</p>\n"},{"syntax":"setAnchorPercent(xPct, yPct)","name":"setAnchorPercent","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> xPct<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> yPct","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>You can set the anchor position that the texture will be drawn at. This means that passing 0.5, 0.5 will draw the ofFbo center at the point you pass in to the draw() method.</p>\n","counter":0},{"syntax":"setAnchorPoint(x, y)","name":"setAnchorPoint","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> y","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>This allows you set the anchor position of the texture in the fbo when you draw it.</p>\n","counter":0},{"syntax":"setDefaultTextureIndex(defaultTexture)","name":"setDefaultTextureIndex","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">int</span> defaultTexture","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>This allows you set the default texture that your fbo will use. If you're using multiple textures, this will return the one that should be draw to, scaled, and positioned.</p>\n","counter":0},{"syntax":"setUseTexture(bool)","name":"setUseTexture","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">bool</span> ","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>This method does nothing.</p>\n","counter":0},{"syntax":"unbind()","name":"unbind","returns":"void","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Unbinds OpenGL framebuffer target and restores the OpenGL framebuffer\nrender target to whatever this ofFbo stores in previousFramebufferBinding.</p>\n<p><strong>See also</strong>:       bind()</p>\n<p><strong>See also</strong>:       void setPreviousFramebufferBinding(const GLuint&amp; previousFramebufferBinding_) const</p>\n","desc":"<p>After you bind the fbo and draw with it, call fbo to stop the fbo from being attached to vertices that are created.</p>\n","counter":0},{"syntax":"updateTexture(attachmentPoint)","name":"updateTexture","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">int</span> attachmentPoint","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Explicityl resolve MSAA render buffers into textures\n\\note     if using MSAA, we will have rendered into a colorbuffer, not directly\ninto the texture call this to blit from the colorbuffer into the texture\nso we can use the results for rendering, or input to a shader etc.\n\\note     This will get called implicitly upon getTexture();</p>\n","desc":"","counter":0},{"syntax":"~ofFbo()","name":"~ofFbo","returns":null,"returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"","counter":0},{"name":"_maxColorAttachments","type":"int","access":"private","version_started":"007","version_deprecated":null,"summary":null,"visible":"True","constant":"True","advanced":"False","short":"","desc":""},{"name":"_maxDrawBuffers","type":"int","access":"private","version_started":"007","version_deprecated":null,"summary":null,"visible":"True","constant":"True","advanced":"False","short":"","desc":""},{"name":"_maxSamples","type":"int","access":"private","version_started":"007","version_deprecated":null,"summary":null,"visible":"True","constant":"True","advanced":"False","short":"","desc":""},{"short":"<p>&lt; table of currently active color draw buffers, allocate() defaults it to size(textures), with GL_COLOR_ATTACHMENT0..n as members, in order of allocation</p>\n","desc":""},{"name":"bIsAllocated","type":"bool","access":"private","version_started":"0071","version_deprecated":null,"summary":null,"visible":"True","constant":"True","advanced":"False","short":"","desc":""},{"short":"","desc":""},{"name":"defaultTextureIndex","type":"int","access":"private","version_started":"007","version_deprecated":null,"summary":null,"visible":"True","constant":"True","advanced":"False","short":"","desc":""},{"name":"depthBuffer","type":"GLuint","access":"private","version_started":"007","version_deprecated":null,"summary":null,"visible":"True","constant":"True","advanced":"False","short":"","desc":""},{"name":"depthBufferTex","type":"ofTexture","access":"private","version_started":"0071","version_deprecated":null,"summary":null,"visible":"True","constant":"True","advanced":"False","short":"","desc":""},{"name":"dirty","type":"bool","access":"private","version_started":"007","version_deprecated":null,"summary":null,"visible":"True","constant":"True","advanced":"False","desc":""},{"name":"fbo","type":"GLuint","access":"private","version_started":"007","version_deprecated":null,"summary":null,"visible":"True","constant":"True","advanced":"False","short":"","desc":""},{"name":"fboTextures","type":"GLuint","access":"private","version_started":"007","version_deprecated":null,"summary":null,"visible":"True","constant":"True","advanced":"False","short":"","desc":""},{"name":"settings","type":"Settings","access":"private","version_started":"007","version_deprecated":null,"summary":null,"visible":"True","constant":"True","advanced":"False","short":"","desc":""},{"name":"stencilBuffer","type":"GLuint","access":"private","version_started":"007","version_deprecated":null,"summary":null,"visible":"True","constant":"True","advanced":"False","short":"","desc":""},{"name":"textures","type":"ofTexture","access":"private","version_started":"007","version_deprecated":null,"summary":null,"visible":"True","constant":"True","advanced":"False","short":"","desc":""},{}],"document":"<p>#class ofFbo</p>\n<!--\n_visible: True_\n_advanced: False_\n_istemplated: False_\n_extends: ofBaseDraws, ofBaseHasTexture_\n-->\n<p>##InlineDescription</p>\n<p>##Description</p>\n<p>At it's core the ofFBO is a container for textures and an optional depth buffer. Kind of like, well, an OpenGL framebuffer, which is what you're normally rendering to. One way, conceptually correct but technically a bit loose, is that it's another renderer that you can write to. You can draw textures to it, draw 3D or 2D objects to it, render the view of cameras inside of it, all with one key difference: it's just an object stored on the graphics card that represents a rendered drawing pass. You can have multiple of them, draw all kinds of things inside of them, and then get all the textures out of them to play with in a shader or just draw them directly to the screen. They are, for most purposes, little render buffers that you can render to and store without needing to be drawing to the screen.</p>\n<p>To start working with an ofFbo, you have to allocate it, the same way that you would with an ofTexture:</p>\n<pre><code class=\"language-{.cpp}\">fbo<span class=\"token punctuation\">.</span><span class=\"token function\">allocate</span><span class=\"token punctuation\">(</span><span class=\"token number\">400</span><span class=\"token punctuation\">,</span> <span class=\"token number\">400</span><span class=\"token punctuation\">,</span> GL_RGBA<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// with alpha, 8 bits red, 8 bits green, 8 bits blue, 8 bits alpha, from 0 to 255 in 256 steps</span>\n</code></pre>\n<p>Often the FBO will contain artefacts from the memory that the graphics card has just allocated for it, so it's good to clear it before starting to draw it:</p>\n<pre><code class=\"language-{.cpp}\">    fbo<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">ofClear</span><span class=\"token punctuation\">(</span><span class=\"token number\">255</span><span class=\"token punctuation\">,</span><span class=\"token number\">255</span><span class=\"token punctuation\">,</span><span class=\"token number\">255</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    fbo<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>When you call begin() you're telling the framebuffer to store the rendered results of any drawing calls (or shaders for that matter) in the FBO:</p>\n<pre><code class=\"language-{.cpp}\"><span class=\"token keyword\">float</span> alpha <span class=\"token operator\">=</span> <span class=\"token function\">ofMap</span><span class=\"token punctuation\">(</span><span class=\"token function\">ofGetMouseX</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token function\">ofGetWidth</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">255</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nfbo<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">ofSetColor</span><span class=\"token punctuation\">(</span><span class=\"token number\">255</span><span class=\"token punctuation\">,</span><span class=\"token number\">255</span><span class=\"token punctuation\">,</span><span class=\"token number\">255</span><span class=\"token punctuation\">,</span> alpha<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">ofDrawRectangle</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">400</span><span class=\"token punctuation\">,</span><span class=\"token number\">400</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nfbo<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>When it's time to draw your FBO, you can simply call draw:</p>\n<pre><code class=\"language-{.cpp}\"><span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">draw</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\tfbo<span class=\"token punctuation\">.</span><span class=\"token function\">draw</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>If you want to pass the FBO to say, an ofShader, you do:</p>\n<pre><code class=\"language-{.cpp}\">shader<span class=\"token punctuation\">.</span><span class=\"token function\">setUniformTexture</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"fboTexture\"</span><span class=\"token punctuation\">,</span> fbo<span class=\"token punctuation\">.</span><span class=\"token function\">getTextureReference</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>You can also use the ofFbo::Settings object to create a more customized FBO that allows you to set the internal format of the depth and stencil textures, create multiple textures to render to, and use different texture targets, among other things.</p>\n<p>ofFbo can be a little confusing because it wraps two related, but distinct things in OpenGL: Textures and RenderBuffers. The difference conceptually isn't huge, but it's important if you're looking to understand deeply what's going on inside the ofFbo. RenderBuffers are good for rendering to, not drawing, whereas Textures are ok for both but slightly slower. More info on both <a href=\"http://www.opengl.org/wiki/Renderbuffer_Objects\">here</a> and <a href=\"http://www.opengl.org/wiki/Framebuffer_Object\">here</a></p>\n<p>##Methods</p>\n<p>###void activateAllDrawBuffers()</p>\n<!--\n_syntax: activateAllDrawBuffers()_\n_name: activateAllDrawBuffers_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0071_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This method allows you to render the results of a shading pass to all the textures inside the FBO. It's  handy if you have many textures inside your FBO, for instance, a normals texture, a colored depth texture, a color texture, and you want to have a shader render to all of them at once. It calls glDrawBuffers() internally, which you can learn more about <a href=\"https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawBuffers.xhtml\">here</a>.</p>\n<!----------------------------------------------------------------------------->\n<p>###void allocate(settings)</p>\n<!--\n_syntax: allocate(settings)_\n_name: allocate_\n_returns: void_\n_returns_description: _\n_parameters: ofFboSettings settings_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>You can also allocate the ofFbo using a Settings object</p>\n<!----------------------------------------------------------------------------->\n<p>###void allocate(width, height, internalformat, numSamples = 0)</p>\n<!--\n_syntax: allocate(width, height, internalformat, numSamples = 0)_\n_name: allocate_\n_returns: void_\n_returns_description: _\n_parameters: int width, int height, int internalformat, int numSamples=0_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Before you use the fbo you need to allocate it. This sets the width, height, and GL type of the fbo (i.e. whether it has alpha data or not) and the number of samples for MSAA. MSAA is sort of a big topic.\nMSAA is what you typically have in hardware on a modern graphics card. The graphics card renders to a surface that is larger than the final image, but in shading each &quot;cluster&quot; of samples (that will end up in a single pixel on the final screen) the pixel shader is run only once. We save a ton of fill rate, but we still burn memory bandwidth.\nThis technique does not anti-alias any effects coming out of the shader, because the shader runs at 1x, so alpha cutouts are jagged. This is the most common way to run a forward-rendering game. MSAA does not work for a deferred renderer because lighting decisions are made after the MSAA is &quot;resolved&quot; (down-sized) to its final image size.</p>\n<!----------------------------------------------------------------------------->\n<p>###void attachTexture(&amp;texture, internalFormat, attachmentPoint)</p>\n<!--\n_syntax: attachTexture(&texture, internalFormat, attachmentPoint)_\n_name: attachTexture_\n_returns: void_\n_returns_description: _\n_parameters: ofTexture &texture, GLenum internalFormat, GLenum attachmentPoint_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###void begin(mode)</p>\n<!--\n_syntax: begin(mode)_\n_name: begin_\n_returns: void_\n_returns_description: _\n_parameters: ofFboMode mode_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>Sets up the framebuffer and binds it for rendering.</p>\n<p>The mode parameter indicates which defaults are set when binding\nthe fbo.</p>\n<p>The default OF_FBOMODE_PERSPECTIVE | OF_FBOMODE_MATRIXFLIP\nwill set the screen perspective to the OF default for the fbo size, the\ncorrect viewport to cover the full fbo and will flip the orientation\nmatrix in y so when drawing the fbo later or accesing it from a shader\nit's correctly oriented</p>\n<p>Passing OF_FBOMODE_PERSPECTIVE will only set perspective and viewport</p>\n<p>Passing OF_FBOMODE_MATRIXFLIP won't set the perspective but will flip\nthe matrix.</p>\n<p>Passing OF_FBOMODE_NODEFAULTS won't change anything and just bind the fbo\nand set it as current rendering surface in OF</p>\n<p><strong>Warning</strong>:  This is a convenience method, and is considered unsafe\nin multi-window and/or multi-renderer scenarios.\nIf you use more than one renderer, use each renderer's\nexplicit void ofBaseGLRenderer::begin(const ofFbo &amp; fbo, ofFboMode mode)\nmethod instead.</p>\n<p><strong>See also</strong>:       void ofBaseGLRenderer::begin(const ofFbo &amp; fbo, ofFboMode mode)</p>\n<p>_description: _</p>\n<p>Any drawing that you do after begin() is drawn into the fbo rather than the screen. This is how you draw things into your ofFbo instance.</p>\n<!----------------------------------------------------------------------------->\n<p>###void bind()</p>\n<!--\n_syntax: bind()_\n_name: bind_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>Bind OpenGL GL_FRAMEBUFFER target to this ofFbo</p>\n<p><strong>Warning</strong>:  If you use this method, you need to manually keep track of the\ncurrently bound framebuffer, if you ever want to restore state.\n* use ofBaseGLRenderer::getCurrentFramebuffer() to query the current\nframebuffer binding state within the renderer.\n* Better, use the renderer's explicit method:\nofBaseGLRenderer::bind(const ofFbo &amp; fbo) to bind the fbo, to allow\nthe renderer to keep track of any bound fbos.</p>\n<p><strong>See also</strong>:       unbind()</p>\n<p><strong>See also</strong>:       virtual void ofBaseGLRenderer::bind(const ofFbo &amp; fbo)</p>\n<p>_description: _</p>\n<p>This function is internally called by ofFbo::begin() after setting up the\nviewport to draw things into your ofFbo instance.</p>\n<p>To map the fbo to ofRectangle, ofMesh, or other vertex based drawing, call</p>\n<pre><code class=\"language-cpp\">fbo<span class=\"token punctuation\">.</span><span class=\"token function\">getTextureReference</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmesh<span class=\"token punctuation\">.</span><span class=\"token function\">draw</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nfbo<span class=\"token punctuation\">.</span><span class=\"token function\">getTextureReference</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">unbind</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<!----------------------------------------------------------------------------->\n<p>###bool checkGLSupport()</p>\n<!--\n_syntax: checkGLSupport()_\n_name: checkGLSupport_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: True_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This allows you quickly check whether your graphics card supports FBO objects.</p>\n<!----------------------------------------------------------------------------->\n<p>###bool checkStatus()</p>\n<!--\n_syntax: checkStatus()_\n_name: checkStatus_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This checks the status of your FBO object.</p>\n<!----------------------------------------------------------------------------->\n<p>###void clear()</p>\n<!--\n_syntax: clear()_\n_name: clear_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###void clearColorBuffer(&amp;color)</p>\n<!--\n_syntax: clearColorBuffer(&color)_\n_name: clearColorBuffer_\n_returns: void_\n_returns_description: _\n_parameters: const ofFloatColor &color_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>glClearBufferfv(GL_COLOR, 0...)</p>\n<p>@see: https://www.opengl.org/wiki/GLAPI/glClearBuffer</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###void clearColorBuffer(buffer_idx, &amp;color)</p>\n<!--\n_syntax: clearColorBuffer(buffer_idx, &color)_\n_name: clearColorBuffer_\n_returns: void_\n_returns_description: _\n_parameters: size_t buffer_idx, const ofFloatColor &color_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>glClearBufferfv(GL_COLOR, buffer_idx...)</p>\n<p>@see: https://www.opengl.org/wiki/GLAPI/glClearBuffer</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###void clearDepthBuffer(value)</p>\n<!--\n_syntax: clearDepthBuffer(value)_\n_name: clearDepthBuffer_\n_returns: void_\n_returns_description: _\n_parameters: float value_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>glClearBufferfv(GL_DEPTH...)</p>\n<p>@see: https://www.opengl.org/wiki/GLAPI/glClearBuffer</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###void clearDepthStencilBuffer(depth, stencil)</p>\n<!--\n_syntax: clearDepthStencilBuffer(depth, stencil)_\n_name: clearDepthStencilBuffer_\n_returns: void_\n_returns_description: _\n_parameters: float depth, int stencil_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>glClearBufferfi(GL_DEPTH_STENCIL...)</p>\n<p>@see: https://www.opengl.org/wiki/GLAPI/glClearBuffer</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###void clearStencilBuffer(value)</p>\n<!--\n_syntax: clearStencilBuffer(value)_\n_name: clearStencilBuffer_\n_returns: void_\n_returns_description: _\n_parameters: int value_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>glClearBufferiv(GL_STENCIL...)</p>\n<p>@see: https://www.opengl.org/wiki/GLAPI/glClearBuffer</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###void copyTo(&amp;buffer)</p>\n<!--\n_syntax: copyTo(&buffer)_\n_name: copyTo_\n_returns: void_\n_returns_description: _\n_parameters: ofBufferObject &buffer_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>Copy the fbo to an ofBufferObject.</p>\n<p><strong>Parameters:</strong></p>\n<p>buffer the target buffer to copy to.</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###void createAndAttachDepthStencilTexture(target, internalformat, attachment)</p>\n<!--\n_syntax: createAndAttachDepthStencilTexture(target, internalformat, attachment)_\n_name: createAndAttachDepthStencilTexture_\n_returns: void_\n_returns_description: _\n_parameters: GLenum target, GLint internalformat, GLenum attachment_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>FBOs usually have two textures that are created inside of them: a color texture to hold all of the colors of objects that are rendered and a depth texture that represents all the depth values of objects that are rendered. While there are more esoteric reasons for generating a depth texture, a common one is that depth textures can be used in a vertex or fragment shader to figure out how far away from the camera (and possibly by extension a light) something is.</p>\n<p>These are created with the default ofFbo::Settings, which means that unless you don't want one, you have a depth buffer to play with that you can access with:</p>\n<pre><code class=\"language-{.cpp}\">fbo<span class=\"token punctuation\">.</span><span class=\"token function\">getDepthTexture</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>The attachment point is the index of the texture that you're going to be referring to within the FBO. By default this should just be GL_DEPTH_STENCIL but if you know what you're doing and don't want a stencil buffer you can use GL_DEPTH_ATTACHMENT or vice versa, GL_STENCIL_ATTACHMENT.</p>\n<!----------------------------------------------------------------------------->\n<p>###void createAndAttachDepthStencilTexture(target, internalformat, attachment, transferFormat, transferType)</p>\n<!--\n_syntax: createAndAttachDepthStencilTexture(target, internalformat, attachment, transferFormat, transferType)_\n_name: createAndAttachDepthStencilTexture_\n_returns: void_\n_returns_description: _\n_parameters: GLenum target, GLint internalformat, GLenum attachment, GLenum transferFormat, GLenum transferType_\n_access: public_\n_version_started: 0071_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>FBOs usually have two textures that are created inside of them: a color texture to hold all of the colors of objects that are rendered and a depth texture that represents all the depth values of objects that are rendered. While there are more esoteric reasons for generating a depth texture, a common one is that depth textures can be used in a vertex or fragment shader to figure out how far away from the camera (and possibly by extension a light) something is.</p>\n<p>These are created with the default ofFbo::Settings, which means that unless you don't want one, you have a depth buffer to play with that you can access with:</p>\n<pre><code class=\"language-{.cpp}\">fbo<span class=\"token punctuation\">.</span><span class=\"token function\">getDepthTexture</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>The attachment point is the index of the texture that you're going to be referring to within the FBO. By default this should just be GL_DEPTH_STENCIL but if you know what you're doing and don't want a stencil buffer you can use GL_DEPTH_ATTACHMENT or vice versa, GL_STENCIL_ATTACHMENT.</p>\n<p>The extra parameters on this method allow you to set the type of depth buffer that you want to create, which is handy if you need particular fidelity for depth, for instance, GL_DEPTH32.</p>\n<!----------------------------------------------------------------------------->\n<p>###GLuint createAndAttachRenderbuffer(internalFormat, attachmentPoint)</p>\n<!--\n_syntax: createAndAttachRenderbuffer(internalFormat, attachmentPoint)_\n_name: createAndAttachRenderbuffer_\n_returns: GLuint_\n_returns_description: _\n_parameters: GLenum internalFormat, GLenum attachmentPoint_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This creates a texture of the specified format and attaches it to the FBO at the index specified. Most of this can be handled for you by using the ofFbo::Settings object. RenderBuffers are slightly different than textures, more info can be found on the <a href=\"http://www.opengl.org/wiki/Renderbuffer_Objects\">OpenGL Wiki</a>.</p>\n<!----------------------------------------------------------------------------->\n<p>###void createAndAttachTexture(internalFormat, attachmentPoint)</p>\n<!--\n_syntax: createAndAttachTexture(internalFormat, attachmentPoint)_\n_name: createAndAttachTexture_\n_returns: void_\n_returns_description: _\n_parameters: GLenum internalFormat, GLenum attachmentPoint_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This creates a texture of the specified format and attaches it to the FBO at the index specified. Most of this can be handled for you by using the ofFbo::Settings object.</p>\n<!----------------------------------------------------------------------------->\n<p>###void draw(x, y)</p>\n<!--\n_syntax: draw(x, y)_\n_name: draw_\n_returns: void_\n_returns_description: _\n_parameters: float x, float y_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This allows you draw everything that's in your fbo to the screen using its default height and width at the x, y indicated.</p>\n<!----------------------------------------------------------------------------->\n<p>###void draw(x, y, width, height)</p>\n<!--\n_syntax: draw(x, y, width, height)_\n_name: draw_\n_returns: void_\n_returns_description: _\n_parameters: float x, float y, float width, float height_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This allows you draw everything that's in your fbo to the screen using any height and width. Any stretching is up to you to handle appropriately.</p>\n<!----------------------------------------------------------------------------->\n<p>###void end()</p>\n<!--\n_syntax: end()_\n_name: end_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>Ends the current framebuffer render context.</p>\n<p><strong>See also</strong>:       void begin(bool setupScreen=true) const;</p>\n<p>_description: _</p>\n<p>Any drawing that you do after end() is drawn to the screen rather than into the fbo buffer. This is how you stop drawing things into your ofFbo instance.</p>\n<!----------------------------------------------------------------------------->\n<p>###void flagDirty()</p>\n<!--\n_syntax: flagDirty()_\n_name: flagDirty_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###int getDefaultTextureIndex()</p>\n<!--\n_syntax: getDefaultTextureIndex()_\n_name: getDefaultTextureIndex_\n_returns: int_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>If you've set the default texture reference, you can get access to it here.</p>\n<!----------------------------------------------------------------------------->\n<p>###GLuint getDepthBuffer()</p>\n<!--\n_syntax: getDepthBuffer()_\n_name: getDepthBuffer_\n_returns: GLuint_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This gives you the OpenGL id of the depth RenderBuffer that the fbo contains. The depthBuffer will only be created if you pass a Setting object with depthStencilAsTexture = false.</p>\n<!----------------------------------------------------------------------------->\n<p>###ofTexture &amp; getDepthTexture()</p>\n<!--\n_syntax: getDepthTexture()_\n_name: getDepthTexture_\n_returns: ofTexture &_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0071_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This gives you the OpenGL id of the depth Texture that the fbo contains. The depthBuffer will be created by default or if you pass a Setting object with depthStencilAsTexture = true.</p>\n<!----------------------------------------------------------------------------->\n<p>###const ofTexture &amp; getDepthTexture()</p>\n<!--\n_syntax: getDepthTexture()_\n_name: getDepthTexture_\n_returns: const ofTexture &_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###float getHeight()</p>\n<!--\n_syntax: getHeight()_\n_name: getHeight_\n_returns: float_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This returns the height of the fbo. This is just like height of a texture: it sets how many pixels wide the allocated memory on the graphics card is.</p>\n<!----------------------------------------------------------------------------->\n<p>###GLuint getId()</p>\n<!--\n_syntax: getId()_\n_name: getId_\n_returns: GLuint_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>returns id of the underlying GL object for advanced actions</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###GLuint getIdDrawBuffer()</p>\n<!--\n_syntax: getIdDrawBuffer()_\n_name: getIdDrawBuffer_\n_returns: GLuint_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>returns id of Fbo for texture attachments\nwhich is different when the fbo is using MSAA</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###int getNumTextures()</p>\n<!--\n_syntax: getNumTextures()_\n_name: getNumTextures_\n_returns: int_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This returns the number of textures that the fbo contains.</p>\n<!----------------------------------------------------------------------------->\n<p>###GLuint getStencilBuffer()</p>\n<!--\n_syntax: getStencilBuffer()_\n_name: getStencilBuffer_\n_returns: GLuint_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This gives you the OpenGL id of the stencil RenderBuffer that the fbo contains. The depthBuffer will only be created if you pass a Setting object with depthStencilAsTexture = false and settings.useStencil = true.</p>\n<!----------------------------------------------------------------------------->\n<p>###ofTexture &amp; getTexture()</p>\n<!--\n_syntax: getTexture()_\n_name: getTexture_\n_returns: ofTexture &_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###const ofTexture &amp; getTexture()</p>\n<!--\n_syntax: getTexture()_\n_name: getTexture_\n_returns: const ofTexture &_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###ofTexture &amp; getTexture(attachmentPoint)</p>\n<!--\n_syntax: getTexture(attachmentPoint)_\n_name: getTexture_\n_returns: ofTexture &_\n_returns_description: _\n_parameters: int attachmentPoint_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###const ofTexture &amp; getTexture(attachmentPoint)</p>\n<!--\n_syntax: getTexture(attachmentPoint)_\n_name: getTexture_\n_returns: const ofTexture &_\n_returns_description: _\n_parameters: int attachmentPoint_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###float getWidth()</p>\n<!--\n_syntax: getWidth()_\n_name: getWidth_\n_returns: float_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This returns the width of the fbo that was set when it was allocated. This is just like width of a texture: it sets how many pixels wide the allocated memory on the graphics card is.</p>\n<!----------------------------------------------------------------------------->\n<p>###bool isAllocated()</p>\n<!--\n_syntax: isAllocated()_\n_name: isAllocated_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0071_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Returns whether your FBO is allocated or not.</p>\n<!----------------------------------------------------------------------------->\n<p>###bool isUsingTexture()</p>\n<!--\n_syntax: isUsingTexture()_\n_name: isUsingTexture_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###int maxColorAttachments()</p>\n<!--\n_syntax: maxColorAttachments()_\n_name: maxColorAttachments_\n_returns: int_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: True_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This returns the max number of simultaneous max color attachments, i.e. textures that will just be used for color information.</p>\n<!----------------------------------------------------------------------------->\n<p>###int maxDrawBuffers()</p>\n<!--\n_syntax: maxDrawBuffers()_\n_name: maxDrawBuffers_\n_returns: int_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: True_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This returns the max number of simultaneous draw buffers that your graphics card supports, i.e. color buffers that can be drawn to simultaneously. This is usually 4 at present.</p>\n<!----------------------------------------------------------------------------->\n<p>###int maxSamples()</p>\n<!--\n_syntax: maxSamples()_\n_name: maxSamples_\n_returns: int_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: True_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This is the maximum number of MSAA samples that your graphic card supports.</p>\n<!----------------------------------------------------------------------------->\n<h3>ofFbo(&amp;&amp;mom)</h3>\n<!--\n_syntax: ofFbo(&&mom)_\n_name: ofFbo_\n_returns: _\n_returns_description: _\n_parameters: ofFbo &&mom_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<h3>ofFbo(&amp;mom)</h3>\n<!--\n_syntax: ofFbo(&mom)_\n_name: ofFbo_\n_returns: _\n_returns_description: _\n_parameters: const ofFbo &mom_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Copies all data from the mom fbo</p>\n<!----------------------------------------------------------------------------->\n<h3>ofFbo()</h3>\n<!--\n_syntax: ofFbo()_\n_name: ofFbo_\n_returns: _\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This is the default constructor for the ofFbo.</p>\n<!----------------------------------------------------------------------------->\n<p>###ofFbo &amp; operator=(&amp;&amp;fbo)</p>\n<!--\n_syntax: operator=(&&fbo)_\n_name: operator=_\n_returns: ofFbo &_\n_returns_description: _\n_parameters: ofFbo &&fbo_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###ofFbo &amp; operator=(&amp;fbo)</p>\n<!--\n_syntax: operator=(&fbo)_\n_name: operator=_\n_returns: ofFbo &_\n_returns_description: _\n_parameters: const ofFbo &fbo_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This overloaded operator allows you to set one fbo from another using the = operator. Very convenient.</p>\n<!----------------------------------------------------------------------------->\n<p>###void readToPixels(&amp;pixels, attachmentPoint = 0)</p>\n<!--\n_syntax: readToPixels(&pixels, attachmentPoint = 0)_\n_name: readToPixels_\n_returns: void_\n_returns_description: _\n_parameters: ofPixels &pixels, int attachmentPoint=0_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This allows you to get the pixels from an ofFbo and store it in an ofPixels instance. The attachmentPoint parameter allows you indicate which of the textures attached to the fbo you want to grab.</p>\n<!----------------------------------------------------------------------------->\n<p>###void readToPixels(&amp;pixels, attachmentPoint = 0)</p>\n<!--\n_syntax: readToPixels(&pixels, attachmentPoint = 0)_\n_name: readToPixels_\n_returns: void_\n_returns_description: _\n_parameters: ofShortPixels &pixels, int attachmentPoint=0_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This allows you to get the pixels from an ofFbo and store it in an ofShortPixels instance. The attachmentPoint parameter allows you indicate which of the textures attached to the fbo you want to grab. The ofShortPixels instance is useful when you want your image at short ints, or non-floating point values.</p>\n<!----------------------------------------------------------------------------->\n<p>###void readToPixels(&amp;pixels, attachmentPoint = 0)</p>\n<!--\n_syntax: readToPixels(&pixels, attachmentPoint = 0)_\n_name: readToPixels_\n_returns: void_\n_returns_description: _\n_parameters: ofFloatPixels &pixels, int attachmentPoint=0_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This allows you to get the pixels from an ofFbo and store it in an ofFloatPixels instance. The attachmentPoint parameter allows you indicate which of the textures attached to the fbo you want to grab. The ofShortPixels instance is useful when you want your image as floating point values.</p>\n<!----------------------------------------------------------------------------->\n<p>###void reloadFbo()</p>\n<!--\n_syntax: reloadFbo()_\n_name: reloadFbo_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: private_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###void resetAnchor()</p>\n<!--\n_syntax: resetAnchor()_\n_name: resetAnchor_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This allows you reset the anchor position.</p>\n<!----------------------------------------------------------------------------->\n<p>###void setActiveDrawBuffer(i)</p>\n<!--\n_syntax: setActiveDrawBuffer(i)_\n_name: setActiveDrawBuffer_\n_returns: void_\n_returns_description: _\n_parameters: int i_\n_access: public_\n_version_started: 0071_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This sets which texture within your FBO is going contain the results of any drawing method or shading pass, particularly useful if you have multiple color textures, for instance, a normals texture and a color value texture. Doing multiple rendering passes on different objects is called <a href=\"http://en.wikipedia.org/wiki/Deferred_shading\">Deferred Shading</a> and is a tricky but powerful technique.</p>\n<!----------------------------------------------------------------------------->\n<p>###void setActiveDrawBuffers(&amp;i)</p>\n<!--\n_syntax: setActiveDrawBuffers(&i)_\n_name: setActiveDrawBuffers_\n_returns: void_\n_returns_description: _\n_parameters: const vector< int > &i_\n_access: public_\n_version_started: 0071_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This sets which texture within your FBO is going contain the results of any drawing method or shading pass, particularly useful if you have multiple color textures, for instance, a normals texture and a color value texture. Doing multiple rendering passes on different objects is called <a href=\"http://en.wikipedia.org/wiki/Deferred_shading\">Deferred Shading</a> and is a tricky but powerful technique.</p>\n<!----------------------------------------------------------------------------->\n<p>###void setAnchorPercent(xPct, yPct)</p>\n<!--\n_syntax: setAnchorPercent(xPct, yPct)_\n_name: setAnchorPercent_\n_returns: void_\n_returns_description: _\n_parameters: float xPct, float yPct_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>You can set the anchor position that the texture will be drawn at. This means that passing 0.5, 0.5 will draw the ofFbo center at the point you pass in to the draw() method.</p>\n<!----------------------------------------------------------------------------->\n<p>###void setAnchorPoint(x, y)</p>\n<!--\n_syntax: setAnchorPoint(x, y)_\n_name: setAnchorPoint_\n_returns: void_\n_returns_description: _\n_parameters: float x, float y_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This allows you set the anchor position of the texture in the fbo when you draw it.</p>\n<!----------------------------------------------------------------------------->\n<p>###void setDefaultTextureIndex(defaultTexture)</p>\n<!--\n_syntax: setDefaultTextureIndex(defaultTexture)_\n_name: setDefaultTextureIndex_\n_returns: void_\n_returns_description: _\n_parameters: int defaultTexture_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This allows you set the default texture that your fbo will use. If you're using multiple textures, this will return the one that should be draw to, scaled, and positioned.</p>\n<!----------------------------------------------------------------------------->\n<p>###void setUseTexture(bool)</p>\n<!--\n_syntax: setUseTexture(bool)_\n_name: setUseTexture_\n_returns: void_\n_returns_description: _\n_parameters: bool _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This method does nothing.</p>\n<!----------------------------------------------------------------------------->\n<p>###void unbind()</p>\n<!--\n_syntax: unbind()_\n_name: unbind_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>Unbinds OpenGL framebuffer target and restores the OpenGL framebuffer\nrender target to whatever this ofFbo stores in previousFramebufferBinding.</p>\n<p><strong>See also</strong>:       bind()</p>\n<p><strong>See also</strong>:       void setPreviousFramebufferBinding(const GLuint&amp; previousFramebufferBinding_) const</p>\n<p>_description: _</p>\n<p>After you bind the fbo and draw with it, call fbo to stop the fbo from being attached to vertices that are created.</p>\n<!----------------------------------------------------------------------------->\n<p>###void updateTexture(attachmentPoint)</p>\n<!--\n_syntax: updateTexture(attachmentPoint)_\n_name: updateTexture_\n_returns: void_\n_returns_description: _\n_parameters: int attachmentPoint_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>Explicityl resolve MSAA render buffers into textures\n\\note     if using MSAA, we will have rendered into a colorbuffer, not directly\ninto the texture call this to blit from the colorbuffer into the texture\nso we can use the results for rendering, or input to a shader etc.\n\\note     This will get called implicitly upon getTexture();</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<h3>~ofFbo()</h3>\n<!--\n_syntax: ~ofFbo()_\n_name: ~ofFbo_\n_returns: _\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>##Variables</p>\n<p>###int _maxColorAttachments</p>\n<!--\n_name: _maxColorAttachments_\n_type: int_\n_access: private_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###int _maxDrawBuffers</p>\n<!--\n_name: _maxDrawBuffers_\n_type: int_\n_access: private_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###int _maxSamples</p>\n<!--\n_name: _maxSamples_\n_type: int_\n_access: private_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###vector&lt; GLenum &gt; activeDrawBuffers</p>\n<!--\n_name: activeDrawBuffers_\n_type: vector< GLenum >_\n_access: private_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: False_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>&lt; table of currently active color draw buffers, allocate() defaults it to size(textures), with GL_COLOR_ATTACHMENT0..n as members, in order of allocation</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###bool bIsAllocated</p>\n<!--\n_name: bIsAllocated_\n_type: bool_\n_access: private_\n_version_started: 0071_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###vector&lt; GLuint &gt; colorBuffers</p>\n<!--\n_name: colorBuffers_\n_type: vector< GLuint >_\n_access: private_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###int defaultTextureIndex</p>\n<!--\n_name: defaultTextureIndex_\n_type: int_\n_access: private_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###GLuint depthBuffer</p>\n<!--\n_name: depthBuffer_\n_type: GLuint_\n_access: private_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###ofTexture depthBufferTex</p>\n<!--\n_name: depthBufferTex_\n_type: ofTexture_\n_access: private_\n_version_started: 0071_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###bool dirty</p>\n<!--\n_name: dirty_\n_type: bool_\n_access: private_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>Flags used internally to keep track of MSAA renderbuffers / textures\n\\note   The dirty flags are only used when dealing if the framebuffer has MSAA\nenabled attachments, i.e. numSamples is &gt; 0 and extra Textures have\nbeen bound so that the multisampled renderbuffers can be resolved to\ntextures.\nThe flags are read whenever an attached texture is accessed. If the texture\nis dirty, i.e. it has not yet been resolved from its associated renderbuffer\nthe texture will be resolved through blitting the renderbuffer into it.</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###GLuint fbo</p>\n<!--\n_name: fbo_\n_type: GLuint_\n_access: private_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###GLuint fboTextures</p>\n<!--\n_name: fboTextures_\n_type: GLuint_\n_access: private_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###Settings settings</p>\n<!--\n_name: settings_\n_type: Settings_\n_access: private_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###GLuint stencilBuffer</p>\n<!--\n_name: stencilBuffer_\n_type: GLuint_\n_access: private_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###ofTexture textures</p>\n<!--\n_name: textures_\n_type: ofTexture_\n_access: private_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n","raw":"#class ofFbo\n\n\n<!--\n_visible: True_\n_advanced: False_\n_istemplated: False_\n_extends: ofBaseDraws, ofBaseHasTexture_\n-->\n\n##InlineDescription\n\n\n\n\n\n\n##Description\n\nAt it's core the ofFBO is a container for textures and an optional depth buffer. Kind of like, well, an OpenGL framebuffer, which is what you're normally rendering to. One way, conceptually correct but technically a bit loose, is that it's another renderer that you can write to. You can draw textures to it, draw 3D or 2D objects to it, render the view of cameras inside of it, all with one key difference: it's just an object stored on the graphics card that represents a rendered drawing pass. You can have multiple of them, draw all kinds of things inside of them, and then get all the textures out of them to play with in a shader or just draw them directly to the screen. They are, for most purposes, little render buffers that you can render to and store without needing to be drawing to the screen.\n\nTo start working with an ofFbo, you have to allocate it, the same way that you would with an ofTexture:\n\n~~~~{.cpp}\nfbo.allocate(400, 400, GL_RGBA); // with alpha, 8 bits red, 8 bits green, 8 bits blue, 8 bits alpha, from 0 to 255 in 256 steps\n~~~~\n\nOften the FBO will contain artefacts from the memory that the graphics card has just allocated for it, so it's good to clear it before starting to draw it:\n\n~~~~{.cpp}\n    fbo.begin();\n\tofClear(255,255,255, 0);\n    fbo.end();\n~~~~\n\nWhen you call begin() you're telling the framebuffer to store the rendered results of any drawing calls (or shaders for that matter) in the FBO:\n\n~~~~{.cpp}\nfloat alpha = ofMap(ofGetMouseX(), 0, ofGetWidth(), 0, 255);\nfbo.begin();\n\tofSetColor(255,255,255, alpha);\n\tofDrawRectangle(0,0,400,400);\nfbo.end();\n~~~~\n\nWhen it's time to draw your FBO, you can simply call draw:\n\n~~~~{.cpp}\nvoid ofApp::draw()\n{\n\tfbo.draw(0,0);\n}\n~~~~\n\nIf you want to pass the FBO to say, an ofShader, you do:\n\n~~~~{.cpp}\nshader.setUniformTexture(\"fboTexture\", fbo.getTextureReference(0), 0);\n~~~~\n\nYou can also use the ofFbo::Settings object to create a more customized FBO that allows you to set the internal format of the depth and stencil textures, create multiple textures to render to, and use different texture targets, among other things.\n\nofFbo can be a little confusing because it wraps two related, but distinct things in OpenGL: Textures and RenderBuffers. The difference conceptually isn't huge, but it's important if you're looking to understand deeply what's going on inside the ofFbo. RenderBuffers are good for rendering to, not drawing, whereas Textures are ok for both but slightly slower. More info on both [here](http://www.opengl.org/wiki/Renderbuffer_Objects) and [here](http://www.opengl.org/wiki/Framebuffer_Object)\n\n\n\n\n\n##Methods\n\n\n\n###void activateAllDrawBuffers()\n\n<!--\n_syntax: activateAllDrawBuffers()_\n_name: activateAllDrawBuffers_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0071_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis method allows you to render the results of a shading pass to all the textures inside the FBO. It's  handy if you have many textures inside your FBO, for instance, a normals texture, a colored depth texture, a color texture, and you want to have a shader render to all of them at once. It calls glDrawBuffers() internally, which you can learn more about [here](https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawBuffers.xhtml).\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void allocate(settings)\n\n<!--\n_syntax: allocate(settings)_\n_name: allocate_\n_returns: void_\n_returns_description: _\n_parameters: ofFboSettings settings_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nYou can also allocate the ofFbo using a Settings object\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void allocate(width, height, internalformat, numSamples = 0)\n\n<!--\n_syntax: allocate(width, height, internalformat, numSamples = 0)_\n_name: allocate_\n_returns: void_\n_returns_description: _\n_parameters: int width, int height, int internalformat, int numSamples=0_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nBefore you use the fbo you need to allocate it. This sets the width, height, and GL type of the fbo (i.e. whether it has alpha data or not) and the number of samples for MSAA. MSAA is sort of a big topic.\nMSAA is what you typically have in hardware on a modern graphics card. The graphics card renders to a surface that is larger than the final image, but in shading each \"cluster\" of samples (that will end up in a single pixel on the final screen) the pixel shader is run only once. We save a ton of fill rate, but we still burn memory bandwidth.\nThis technique does not anti-alias any effects coming out of the shader, because the shader runs at 1x, so alpha cutouts are jagged. This is the most common way to run a forward-rendering game. MSAA does not work for a deferred renderer because lighting decisions are made after the MSAA is \"resolved\" (down-sized) to its final image size.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void attachTexture(&texture, internalFormat, attachmentPoint)\n\n<!--\n_syntax: attachTexture(&texture, internalFormat, attachmentPoint)_\n_name: attachTexture_\n_returns: void_\n_returns_description: _\n_parameters: ofTexture &texture, GLenum internalFormat, GLenum attachmentPoint_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void begin(mode)\n\n<!--\n_syntax: begin(mode)_\n_name: begin_\n_returns: void_\n_returns_description: _\n_parameters: ofFboMode mode_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nSets up the framebuffer and binds it for rendering.\n\nThe mode parameter indicates which defaults are set when binding\nthe fbo.\n\nThe default OF_FBOMODE_PERSPECTIVE | OF_FBOMODE_MATRIXFLIP\nwill set the screen perspective to the OF default for the fbo size, the\ncorrect viewport to cover the full fbo and will flip the orientation\nmatrix in y so when drawing the fbo later or accesing it from a shader\nit's correctly oriented\n\nPassing OF_FBOMODE_PERSPECTIVE will only set perspective and viewport\n\nPassing OF_FBOMODE_MATRIXFLIP won't set the perspective but will flip\nthe matrix.\n\nPassing OF_FBOMODE_NODEFAULTS won't change anything and just bind the fbo\nand set it as current rendering surface in OF\n\n\n**Warning**:  This is a convenience method, and is considered unsafe\n          in multi-window and/or multi-renderer scenarios.\n          If you use more than one renderer, use each renderer's\n          explicit void ofBaseGLRenderer::begin(const ofFbo & fbo, ofFboMode mode)\n          method instead.\n\n**See also**:       void ofBaseGLRenderer::begin(const ofFbo & fbo, ofFboMode mode)\n\n\n\n\n\n_description: _\n\nAny drawing that you do after begin() is drawn into the fbo rather than the screen. This is how you draw things into your ofFbo instance.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void bind()\n\n<!--\n_syntax: bind()_\n_name: bind_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n   Bind OpenGL GL_FRAMEBUFFER target to this ofFbo\n\n**Warning**:  If you use this method, you need to manually keep track of the\n          currently bound framebuffer, if you ever want to restore state.\n          * use ofBaseGLRenderer::getCurrentFramebuffer() to query the current\n          framebuffer binding state within the renderer.\n          * Better, use the renderer's explicit method:\n          ofBaseGLRenderer::bind(const ofFbo & fbo) to bind the fbo, to allow\n          the renderer to keep track of any bound fbos.\n\n**See also**:       unbind()\n\n**See also**:       virtual void ofBaseGLRenderer::bind(const ofFbo & fbo)\n\n\n\n\n\n_description: _\n\nThis function is internally called by ofFbo::begin() after setting up the\nviewport to draw things into your ofFbo instance.\n\nTo map the fbo to ofRectangle, ofMesh, or other vertex based drawing, call\n\n```cpp\nfbo.getTextureReference().bind();\nmesh.draw();\nfbo.getTextureReference().unbind();\n```\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool checkGLSupport()\n\n<!--\n_syntax: checkGLSupport()_\n_name: checkGLSupport_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: True_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis allows you quickly check whether your graphics card supports FBO objects.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool checkStatus()\n\n<!--\n_syntax: checkStatus()_\n_name: checkStatus_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis checks the status of your FBO object.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void clear()\n\n<!--\n_syntax: clear()_\n_name: clear_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void clearColorBuffer(&color)\n\n<!--\n_syntax: clearColorBuffer(&color)_\n_name: clearColorBuffer_\n_returns: void_\n_returns_description: _\n_parameters: const ofFloatColor &color_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nglClearBufferfv(GL_COLOR, 0...)\n\n@see: https://www.opengl.org/wiki/GLAPI/glClearBuffer\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void clearColorBuffer(buffer_idx, &color)\n\n<!--\n_syntax: clearColorBuffer(buffer_idx, &color)_\n_name: clearColorBuffer_\n_returns: void_\n_returns_description: _\n_parameters: size_t buffer_idx, const ofFloatColor &color_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nglClearBufferfv(GL_COLOR, buffer_idx...)\n\n@see: https://www.opengl.org/wiki/GLAPI/glClearBuffer\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void clearDepthBuffer(value)\n\n<!--\n_syntax: clearDepthBuffer(value)_\n_name: clearDepthBuffer_\n_returns: void_\n_returns_description: _\n_parameters: float value_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nglClearBufferfv(GL_DEPTH...)\n\n@see: https://www.opengl.org/wiki/GLAPI/glClearBuffer\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void clearDepthStencilBuffer(depth, stencil)\n\n<!--\n_syntax: clearDepthStencilBuffer(depth, stencil)_\n_name: clearDepthStencilBuffer_\n_returns: void_\n_returns_description: _\n_parameters: float depth, int stencil_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nglClearBufferfi(GL_DEPTH_STENCIL...)\n\n@see: https://www.opengl.org/wiki/GLAPI/glClearBuffer\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void clearStencilBuffer(value)\n\n<!--\n_syntax: clearStencilBuffer(value)_\n_name: clearStencilBuffer_\n_returns: void_\n_returns_description: _\n_parameters: int value_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nglClearBufferiv(GL_STENCIL...)\n\n@see: https://www.opengl.org/wiki/GLAPI/glClearBuffer\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void copyTo(&buffer)\n\n<!--\n_syntax: copyTo(&buffer)_\n_name: copyTo_\n_returns: void_\n_returns_description: _\n_parameters: ofBufferObject &buffer_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCopy the fbo to an ofBufferObject.\n\n**Parameters:**\n\nbuffer the target buffer to copy to.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void createAndAttachDepthStencilTexture(target, internalformat, attachment)\n\n<!--\n_syntax: createAndAttachDepthStencilTexture(target, internalformat, attachment)_\n_name: createAndAttachDepthStencilTexture_\n_returns: void_\n_returns_description: _\n_parameters: GLenum target, GLint internalformat, GLenum attachment_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nFBOs usually have two textures that are created inside of them: a color texture to hold all of the colors of objects that are rendered and a depth texture that represents all the depth values of objects that are rendered. While there are more esoteric reasons for generating a depth texture, a common one is that depth textures can be used in a vertex or fragment shader to figure out how far away from the camera (and possibly by extension a light) something is.\n\nThese are created with the default ofFbo::Settings, which means that unless you don't want one, you have a depth buffer to play with that you can access with:\n\n~~~~{.cpp}\nfbo.getDepthTexture();\n~~~~\n\nThe attachment point is the index of the texture that you're going to be referring to within the FBO. By default this should just be GL_DEPTH_STENCIL but if you know what you're doing and don't want a stencil buffer you can use GL_DEPTH_ATTACHMENT or vice versa, GL_STENCIL_ATTACHMENT.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void createAndAttachDepthStencilTexture(target, internalformat, attachment, transferFormat, transferType)\n\n<!--\n_syntax: createAndAttachDepthStencilTexture(target, internalformat, attachment, transferFormat, transferType)_\n_name: createAndAttachDepthStencilTexture_\n_returns: void_\n_returns_description: _\n_parameters: GLenum target, GLint internalformat, GLenum attachment, GLenum transferFormat, GLenum transferType_\n_access: public_\n_version_started: 0071_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nFBOs usually have two textures that are created inside of them: a color texture to hold all of the colors of objects that are rendered and a depth texture that represents all the depth values of objects that are rendered. While there are more esoteric reasons for generating a depth texture, a common one is that depth textures can be used in a vertex or fragment shader to figure out how far away from the camera (and possibly by extension a light) something is.\n\nThese are created with the default ofFbo::Settings, which means that unless you don't want one, you have a depth buffer to play with that you can access with:\n\n~~~~{.cpp}\nfbo.getDepthTexture();\n~~~~\n\nThe attachment point is the index of the texture that you're going to be referring to within the FBO. By default this should just be GL_DEPTH_STENCIL but if you know what you're doing and don't want a stencil buffer you can use GL_DEPTH_ATTACHMENT or vice versa, GL_STENCIL_ATTACHMENT.\n\nThe extra parameters on this method allow you to set the type of depth buffer that you want to create, which is handy if you need particular fidelity for depth, for instance, GL_DEPTH32.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###GLuint createAndAttachRenderbuffer(internalFormat, attachmentPoint)\n\n<!--\n_syntax: createAndAttachRenderbuffer(internalFormat, attachmentPoint)_\n_name: createAndAttachRenderbuffer_\n_returns: GLuint_\n_returns_description: _\n_parameters: GLenum internalFormat, GLenum attachmentPoint_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis creates a texture of the specified format and attaches it to the FBO at the index specified. Most of this can be handled for you by using the ofFbo::Settings object. RenderBuffers are slightly different than textures, more info can be found on the [OpenGL Wiki](http://www.opengl.org/wiki/Renderbuffer_Objects).\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void createAndAttachTexture(internalFormat, attachmentPoint)\n\n<!--\n_syntax: createAndAttachTexture(internalFormat, attachmentPoint)_\n_name: createAndAttachTexture_\n_returns: void_\n_returns_description: _\n_parameters: GLenum internalFormat, GLenum attachmentPoint_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis creates a texture of the specified format and attaches it to the FBO at the index specified. Most of this can be handled for you by using the ofFbo::Settings object.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void draw(x, y)\n\n<!--\n_syntax: draw(x, y)_\n_name: draw_\n_returns: void_\n_returns_description: _\n_parameters: float x, float y_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis allows you draw everything that's in your fbo to the screen using its default height and width at the x, y indicated.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void draw(x, y, width, height)\n\n<!--\n_syntax: draw(x, y, width, height)_\n_name: draw_\n_returns: void_\n_returns_description: _\n_parameters: float x, float y, float width, float height_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis allows you draw everything that's in your fbo to the screen using any height and width. Any stretching is up to you to handle appropriately.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void end()\n\n<!--\n_syntax: end()_\n_name: end_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n   Ends the current framebuffer render context.\n\n**See also**:       void begin(bool setupScreen=true) const;\n\n\n\n\n\n_description: _\n\nAny drawing that you do after end() is drawn to the screen rather than into the fbo buffer. This is how you stop drawing things into your ofFbo instance.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void flagDirty()\n\n<!--\n_syntax: flagDirty()_\n_name: flagDirty_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###int getDefaultTextureIndex()\n\n<!--\n_syntax: getDefaultTextureIndex()_\n_name: getDefaultTextureIndex_\n_returns: int_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nIf you've set the default texture reference, you can get access to it here.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###GLuint getDepthBuffer()\n\n<!--\n_syntax: getDepthBuffer()_\n_name: getDepthBuffer_\n_returns: GLuint_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis gives you the OpenGL id of the depth RenderBuffer that the fbo contains. The depthBuffer will only be created if you pass a Setting object with depthStencilAsTexture = false.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###ofTexture & getDepthTexture()\n\n<!--\n_syntax: getDepthTexture()_\n_name: getDepthTexture_\n_returns: ofTexture &_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0071_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis gives you the OpenGL id of the depth Texture that the fbo contains. The depthBuffer will be created by default or if you pass a Setting object with depthStencilAsTexture = true.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###const ofTexture & getDepthTexture()\n\n<!--\n_syntax: getDepthTexture()_\n_name: getDepthTexture_\n_returns: const ofTexture &_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float getHeight()\n\n<!--\n_syntax: getHeight()_\n_name: getHeight_\n_returns: float_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis returns the height of the fbo. This is just like height of a texture: it sets how many pixels wide the allocated memory on the graphics card is.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###GLuint getId()\n\n<!--\n_syntax: getId()_\n_name: getId_\n_returns: GLuint_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nreturns id of the underlying GL object for advanced actions\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###GLuint getIdDrawBuffer()\n\n<!--\n_syntax: getIdDrawBuffer()_\n_name: getIdDrawBuffer_\n_returns: GLuint_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nreturns id of Fbo for texture attachments\nwhich is different when the fbo is using MSAA\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###int getNumTextures()\n\n<!--\n_syntax: getNumTextures()_\n_name: getNumTextures_\n_returns: int_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis returns the number of textures that the fbo contains.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###GLuint getStencilBuffer()\n\n<!--\n_syntax: getStencilBuffer()_\n_name: getStencilBuffer_\n_returns: GLuint_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis gives you the OpenGL id of the stencil RenderBuffer that the fbo contains. The depthBuffer will only be created if you pass a Setting object with depthStencilAsTexture = false and settings.useStencil = true.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###ofTexture & getTexture()\n\n<!--\n_syntax: getTexture()_\n_name: getTexture_\n_returns: ofTexture &_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###const ofTexture & getTexture()\n\n<!--\n_syntax: getTexture()_\n_name: getTexture_\n_returns: const ofTexture &_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###ofTexture & getTexture(attachmentPoint)\n\n<!--\n_syntax: getTexture(attachmentPoint)_\n_name: getTexture_\n_returns: ofTexture &_\n_returns_description: _\n_parameters: int attachmentPoint_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###const ofTexture & getTexture(attachmentPoint)\n\n<!--\n_syntax: getTexture(attachmentPoint)_\n_name: getTexture_\n_returns: const ofTexture &_\n_returns_description: _\n_parameters: int attachmentPoint_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float getWidth()\n\n<!--\n_syntax: getWidth()_\n_name: getWidth_\n_returns: float_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis returns the width of the fbo that was set when it was allocated. This is just like width of a texture: it sets how many pixels wide the allocated memory on the graphics card is.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool isAllocated()\n\n<!--\n_syntax: isAllocated()_\n_name: isAllocated_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0071_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nReturns whether your FBO is allocated or not.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool isUsingTexture()\n\n<!--\n_syntax: isUsingTexture()_\n_name: isUsingTexture_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###int maxColorAttachments()\n\n<!--\n_syntax: maxColorAttachments()_\n_name: maxColorAttachments_\n_returns: int_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: True_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis returns the max number of simultaneous max color attachments, i.e. textures that will just be used for color information.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###int maxDrawBuffers()\n\n<!--\n_syntax: maxDrawBuffers()_\n_name: maxDrawBuffers_\n_returns: int_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: True_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis returns the max number of simultaneous draw buffers that your graphics card supports, i.e. color buffers that can be drawn to simultaneously. This is usually 4 at present.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###int maxSamples()\n\n<!--\n_syntax: maxSamples()_\n_name: maxSamples_\n_returns: int_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: True_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis is the maximum number of MSAA samples that your graphic card supports.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n### ofFbo(&&mom)\n\n<!--\n_syntax: ofFbo(&&mom)_\n_name: ofFbo_\n_returns: _\n_returns_description: _\n_parameters: ofFbo &&mom_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n### ofFbo(&mom)\n\n<!--\n_syntax: ofFbo(&mom)_\n_name: ofFbo_\n_returns: _\n_returns_description: _\n_parameters: const ofFbo &mom_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nCopies all data from the mom fbo\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n### ofFbo()\n\n<!--\n_syntax: ofFbo()_\n_name: ofFbo_\n_returns: _\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis is the default constructor for the ofFbo.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###ofFbo & operator=(&&fbo)\n\n<!--\n_syntax: operator=(&&fbo)_\n_name: operator=_\n_returns: ofFbo &_\n_returns_description: _\n_parameters: ofFbo &&fbo_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###ofFbo & operator=(&fbo)\n\n<!--\n_syntax: operator=(&fbo)_\n_name: operator=_\n_returns: ofFbo &_\n_returns_description: _\n_parameters: const ofFbo &fbo_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis overloaded operator allows you to set one fbo from another using the = operator. Very convenient.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void readToPixels(&pixels, attachmentPoint = 0)\n\n<!--\n_syntax: readToPixels(&pixels, attachmentPoint = 0)_\n_name: readToPixels_\n_returns: void_\n_returns_description: _\n_parameters: ofPixels &pixels, int attachmentPoint=0_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis allows you to get the pixels from an ofFbo and store it in an ofPixels instance. The attachmentPoint parameter allows you indicate which of the textures attached to the fbo you want to grab.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void readToPixels(&pixels, attachmentPoint = 0)\n\n<!--\n_syntax: readToPixels(&pixels, attachmentPoint = 0)_\n_name: readToPixels_\n_returns: void_\n_returns_description: _\n_parameters: ofShortPixels &pixels, int attachmentPoint=0_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis allows you to get the pixels from an ofFbo and store it in an ofShortPixels instance. The attachmentPoint parameter allows you indicate which of the textures attached to the fbo you want to grab. The ofShortPixels instance is useful when you want your image at short ints, or non-floating point values.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void readToPixels(&pixels, attachmentPoint = 0)\n\n<!--\n_syntax: readToPixels(&pixels, attachmentPoint = 0)_\n_name: readToPixels_\n_returns: void_\n_returns_description: _\n_parameters: ofFloatPixels &pixels, int attachmentPoint=0_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis allows you to get the pixels from an ofFbo and store it in an ofFloatPixels instance. The attachmentPoint parameter allows you indicate which of the textures attached to the fbo you want to grab. The ofShortPixels instance is useful when you want your image as floating point values.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void reloadFbo()\n\n<!--\n_syntax: reloadFbo()_\n_name: reloadFbo_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: private_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void resetAnchor()\n\n<!--\n_syntax: resetAnchor()_\n_name: resetAnchor_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis allows you reset the anchor position.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setActiveDrawBuffer(i)\n\n<!--\n_syntax: setActiveDrawBuffer(i)_\n_name: setActiveDrawBuffer_\n_returns: void_\n_returns_description: _\n_parameters: int i_\n_access: public_\n_version_started: 0071_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis sets which texture within your FBO is going contain the results of any drawing method or shading pass, particularly useful if you have multiple color textures, for instance, a normals texture and a color value texture. Doing multiple rendering passes on different objects is called [Deferred Shading](http://en.wikipedia.org/wiki/Deferred_shading) and is a tricky but powerful technique.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setActiveDrawBuffers(&i)\n\n<!--\n_syntax: setActiveDrawBuffers(&i)_\n_name: setActiveDrawBuffers_\n_returns: void_\n_returns_description: _\n_parameters: const vector< int > &i_\n_access: public_\n_version_started: 0071_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis sets which texture within your FBO is going contain the results of any drawing method or shading pass, particularly useful if you have multiple color textures, for instance, a normals texture and a color value texture. Doing multiple rendering passes on different objects is called [Deferred Shading](http://en.wikipedia.org/wiki/Deferred_shading) and is a tricky but powerful technique.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setAnchorPercent(xPct, yPct)\n\n<!--\n_syntax: setAnchorPercent(xPct, yPct)_\n_name: setAnchorPercent_\n_returns: void_\n_returns_description: _\n_parameters: float xPct, float yPct_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nYou can set the anchor position that the texture will be drawn at. This means that passing 0.5, 0.5 will draw the ofFbo center at the point you pass in to the draw() method.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setAnchorPoint(x, y)\n\n<!--\n_syntax: setAnchorPoint(x, y)_\n_name: setAnchorPoint_\n_returns: void_\n_returns_description: _\n_parameters: float x, float y_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis allows you set the anchor position of the texture in the fbo when you draw it.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setDefaultTextureIndex(defaultTexture)\n\n<!--\n_syntax: setDefaultTextureIndex(defaultTexture)_\n_name: setDefaultTextureIndex_\n_returns: void_\n_returns_description: _\n_parameters: int defaultTexture_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis allows you set the default texture that your fbo will use. If you're using multiple textures, this will return the one that should be draw to, scaled, and positioned.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setUseTexture(bool)\n\n<!--\n_syntax: setUseTexture(bool)_\n_name: setUseTexture_\n_returns: void_\n_returns_description: _\n_parameters: bool _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis method does nothing.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void unbind()\n\n<!--\n_syntax: unbind()_\n_name: unbind_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n   Unbinds OpenGL framebuffer target and restores the OpenGL framebuffer\n          render target to whatever this ofFbo stores in previousFramebufferBinding.\n\n**See also**:       bind()\n\n**See also**:       void setPreviousFramebufferBinding(const GLuint& previousFramebufferBinding_) const\n\n\n\n\n\n_description: _\n\nAfter you bind the fbo and draw with it, call fbo to stop the fbo from being attached to vertices that are created.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void updateTexture(attachmentPoint)\n\n<!--\n_syntax: updateTexture(attachmentPoint)_\n_name: updateTexture_\n_returns: void_\n_returns_description: _\n_parameters: int attachmentPoint_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n   Explicityl resolve MSAA render buffers into textures\n\\note     if using MSAA, we will have rendered into a colorbuffer, not directly\n          into the texture call this to blit from the colorbuffer into the texture\n          so we can use the results for rendering, or input to a shader etc.\n\\note     This will get called implicitly upon getTexture();\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n### ~ofFbo()\n\n<!--\n_syntax: ~ofFbo()_\n_name: ~ofFbo_\n_returns: _\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n##Variables\n\n\n\n###int _maxColorAttachments\n\n<!--\n_name: _maxColorAttachments_\n_type: int_\n_access: private_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###int _maxDrawBuffers\n\n<!--\n_name: _maxDrawBuffers_\n_type: int_\n_access: private_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###int _maxSamples\n\n<!--\n_name: _maxSamples_\n_type: int_\n_access: private_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###vector< GLenum > activeDrawBuffers\n\n<!--\n_name: activeDrawBuffers_\n_type: vector< GLenum >_\n_access: private_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: False_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n< table of currently active color draw buffers, allocate() defaults it to size(textures), with GL_COLOR_ATTACHMENT0..n as members, in order of allocation\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool bIsAllocated\n\n<!--\n_name: bIsAllocated_\n_type: bool_\n_access: private_\n_version_started: 0071_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###vector< GLuint > colorBuffers\n\n<!--\n_name: colorBuffers_\n_type: vector< GLuint >_\n_access: private_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###int defaultTextureIndex\n\n<!--\n_name: defaultTextureIndex_\n_type: int_\n_access: private_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###GLuint depthBuffer\n\n<!--\n_name: depthBuffer_\n_type: GLuint_\n_access: private_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###ofTexture depthBufferTex\n\n<!--\n_name: depthBufferTex_\n_type: ofTexture_\n_access: private_\n_version_started: 0071_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool dirty\n\n<!--\n_name: dirty_\n_type: bool_\n_access: private_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n Flags used internally to keep track of MSAA renderbuffers / textures\n\\note   The dirty flags are only used when dealing if the framebuffer has MSAA\n        enabled attachments, i.e. numSamples is > 0 and extra Textures have\n        been bound so that the multisampled renderbuffers can be resolved to\n        textures.\n        The flags are read whenever an attached texture is accessed. If the texture\n        is dirty, i.e. it has not yet been resolved from its associated renderbuffer\n        the texture will be resolved through blitting the renderbuffer into it.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###GLuint fbo\n\n<!--\n_name: fbo_\n_type: GLuint_\n_access: private_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###GLuint fboTextures\n\n<!--\n_name: fboTextures_\n_type: GLuint_\n_access: private_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###Settings settings\n\n<!--\n_name: settings_\n_type: Settings_\n_access: private_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###GLuint stencilBuffer\n\n<!--\n_name: stencilBuffer_\n_type: GLuint_\n_access: private_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###ofTexture textures\n\n<!--\n_name: textures_\n_type: ofTexture_\n_access: private_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n","type":"page","static":true}}],"fetch":[]}