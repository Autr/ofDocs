{"data":[{"page":{"entry":{"name":"ofEventUtils (functions)","filename":"ofEventUtils_functions.markdown","absolute":"/Users/Gilbert/Code/openFrameworks/ofSite/documentation/events/ofEventUtils_functions.markdown","path":"/documentation/events/ofEventUtils_functions","route":"/documentation/events/ofEventUtils_functions.markdown","dir":"../ofSite/documentation/events","ext":"markdown","type":"page","id":2184,"parent":2172,"breadcrumbs":[2172,1968],"siblings":[],"translations":{}},"description":{},"methods":[null,{"syntax":"ofAddListener(&event, *, listenerFunction, prio)","name":"ofAddListener","returns":"void","returns_description":null,"parameters":"EventType <span class=\"token operator\">&amp;</span>event<span class=\"token punctuation\">,</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">,</span> ArgumentsType <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span> listenerFunction<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> prio","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"","counter":7},{"syntax":"ofAddListener(&event, *, listenerFunction, prio)","name":"ofAddListener","returns":"void","returns_description":null,"parameters":"EventType <span class=\"token operator\">&amp;</span>event<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">,</span> ArgumentsType <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span> listenerFunction<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> prio","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"ofAddListener(&event, *listener, *, listenerMethod, prio)","name":"ofAddListener","returns":"void","returns_description":null,"parameters":"EventType <span class=\"token operator\">&amp;</span>event<span class=\"token punctuation\">,</span> ListenerClass <span class=\"token operator\">*</span>listener<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> <span class=\"token punctuation\">(</span>ListenerClass<span class=\"token operator\">::</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">,</span> ArgumentsType <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span> listenerMethod<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> prio","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Allows you to add a listener method to an event, use it whenever you want a class to be notified about an event.</p>\n<p>This is a templated function so the types of the parameters are not predefined types but can be any type as long as the method is one of the listener class' and it has a particular signature.</p>\n<p>The signature of the listener method depends on the event type. Every event is defined as:</p>\n<pre><code class=\"language-{.cpp}\">ofEvent<span class=\"token operator\">&lt;</span>type</code></pre>\n"},{"syntax":"ofAddListener(&event, *listener, *, listenerMethod, prio)","name":"ofAddListener","returns":"void","returns_description":null,"parameters":"EventType <span class=\"token operator\">&amp;</span>event<span class=\"token punctuation\">,</span> ListenerClass <span class=\"token operator\">*</span>listener<span class=\"token punctuation\">,</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">(</span>ListenerClass<span class=\"token operator\">::</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">,</span> ArgumentsType <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span> listenerMethod<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> prio","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>register any method of any class to an event.</p>\n<p>the method must provide one of the following\nsignatures:\nvoid method(ArgumentsType &amp; args)\nvoid method(const void * sender, ArgumentsType &amp;args)\nie:\nofAddListener(addon.newIntEvent, this, &amp;Class::method)</p>\n","desc":"<p>Allows you to add a listener method to an event, use it whenever you want a class to be notified about an event.</p>\n<p>This is a templated function so the types of the parameters are not predefined types but can be any type as long as the method is one of the listener class' and it has a particular signature.</p>\n<p>The signature of the listener method depends on the event type. Every event is defined as:</p>\n<pre><code class=\"language-{.cpp}\">ofEvent<span class=\"token operator\">&lt;</span>type</code></pre>\n"},{"short":"","desc":"<p>Allows you to add a listener method to an event, use it whenever you want a class to be notified about an event.</p>\n<p>This is a templated function so the types of the parameters are not predefined types but can be any type as long as the method is one of the listener class' and it has a particular signature.</p>\n<p>The signature of the listener method depends on the event type. Every event is defined as:</p>\n<pre><code class=\"language-{.cpp}\">ofEvent<span class=\"token operator\">&lt;</span>type</code></pre>\n"},{"short":"","desc":"<p>Allows you to add a listener method to an event, use it whenever you want a class to be notified about an event.</p>\n<p>This is a templated function so the types of the parameters are not predefined types but can be any type as long as the method is one of the listener class' and it has a particular signature.</p>\n<p>The signature of the listener method depends on the event type. Every event is defined as:</p>\n<pre><code class=\"language-{.cpp}\">ofEvent<span class=\"token operator\">&lt;</span>type</code></pre>\n"},{"syntax":"ofAddListener(&event, *listener, listenerMethod, prio)","name":"ofAddListener","returns":"void","returns_description":null,"parameters":"EventType <span class=\"token operator\">&amp;</span>event<span class=\"token punctuation\">,</span> ListenerClass <span class=\"token operator\">*</span>listener<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> <span class=\"token punctuation\">(</span>ListenerClass<span class=\"token operator\">::</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>ArgumentsType <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span> listenerMethod<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> prio","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Allows you to add a listener method to an event, use it whenever you want a class to be notified about an event.</p>\n<p>This is a templated function so the types of the parameters are not predefined types but can be any type as long as the method is one of the listener class' and it has a particular signature.</p>\n<p>The signature of the listener method depends on the event type. Every event is defined as:</p>\n<pre><code class=\"language-{.cpp}\">ofEvent<span class=\"token operator\">&lt;</span>type</code></pre>\n"},{"short":"","desc":"<p>Allows you to add a listener method to an event, use it whenever you want a class to be notified about an event.</p>\n<p>This is a templated function so the types of the parameters are not predefined types but can be any type as long as the method is one of the listener class' and it has a particular signature.</p>\n<p>The signature of the listener method depends on the event type. Every event is defined as:</p>\n<pre><code class=\"language-{.cpp}\">ofEvent<span class=\"token operator\">&lt;</span>type</code></pre>\n"},{"short":"","desc":"<p>Allows you to add a listener method to an event, use it whenever you want a class to be notified about an event.</p>\n<p>This is a templated function so the types of the parameters are not predefined types but can be any type as long as the method is one of the listener class' and it has a particular signature.</p>\n<p>The signature of the listener method depends on the event type. Every event is defined as:</p>\n<pre><code class=\"language-{.cpp}\">ofEvent<span class=\"token operator\">&lt;</span>type</code></pre>\n"},{"syntax":"ofAddListener(&event, *listener, listenerMethod, prio)","name":"ofAddListener","returns":"void","returns_description":null,"parameters":"EventType <span class=\"token operator\">&amp;</span>event<span class=\"token punctuation\">,</span> ListenerClass <span class=\"token operator\">*</span>listener<span class=\"token punctuation\">,</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">(</span>ListenerClass<span class=\"token operator\">::</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>ArgumentsType <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span> listenerMethod<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> prio","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Allows you to add a listener method to an event, use it whenever you want a class to be notified about an event.</p>\n<p>This is a templated function so the types of the parameters are not predefined types but can be any type as long as the method is one of the listener class' and it has a particular signature.</p>\n<p>The signature of the listener method depends on the event type. Every event is defined as:</p>\n<pre><code class=\"language-{.cpp}\">ofEvent<span class=\"token operator\">&lt;</span>type</code></pre>\n"},{"syntax":"ofAddListener(&event, listenerFunction, prio)","name":"ofAddListener","returns":"void","returns_description":null,"parameters":"EventType <span class=\"token operator\">&amp;</span>event<span class=\"token punctuation\">,</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>ArgumentsType <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span> listenerFunction<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> prio","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"short":"","desc":""},{"short":"","desc":""},{"syntax":"ofAddListener(&event, listenerFunction, prio)","name":"ofAddListener","returns":"void","returns_description":null,"parameters":"EventType <span class=\"token operator\">&amp;</span>event<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>ArgumentsType <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span> listenerFunction<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> prio","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"short":"","desc":""},{"short":"","desc":""},{"short":"","desc":"<p>Notifies an event, what makes all it's registered method listeners to be called with the same argument.</p>\n<p>This is a templated function so the type of the parameters is not predefined and can be anything as long as the listener methods use the same type for the parameter.</p>\n<p>The arguments are passed to the listeners by reference so they can modify them.</p>\n<p>The listener methods are called in the same order they were registered using ofAddListener.</p>\n<p>For instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:</p>\n<pre><code class=\"language-{.cpp}\">\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">SimpleEventNotifier</span> <span class=\"token punctuation\">{</span>\n\tofEvent<span class=\"token operator\">&lt;</span><span class=\"token keyword\">float</span></code></pre>\n"},{"syntax":"ofNotifyEvent(&event, &args)","name":"ofNotifyEvent","returns":"bool","returns_description":null,"parameters":"EventType <span class=\"token operator\">&amp;</span>event<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> ArgumentsType <span class=\"token operator\">&amp;</span>args","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Notifies an event, what makes all it's registered method listeners to be called with the same argument.</p>\n<p>This is a templated function so the type of the parameters is not predefined and can be anything as long as the listener methods use the same type for the parameter.</p>\n<p>The arguments are passed to the listeners by reference so they can modify them.</p>\n<p>The listener methods are called in the same order they were registered using ofAddListener.</p>\n<p>With this version the listeners also receive a pointer to the notifying class in case the listener method specifies that parameter.</p>\n<p>For instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:</p>\n<pre><code class=\"language-{.cpp}\">\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">SimpleEventNotifier</span> <span class=\"token punctuation\">{</span>\n\tofEvent<span class=\"token operator\">&lt;</span><span class=\"token keyword\">float</span></code></pre>\n","counter":3},{"syntax":"ofNotifyEvent(&event, &args)","name":"ofNotifyEvent","returns":"bool","returns_description":null,"parameters":"EventType <span class=\"token operator\">&amp;</span>event<span class=\"token punctuation\">,</span> ArgumentsType <span class=\"token operator\">&amp;</span>args","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Notifies an event, what makes all it's registered method listeners to be called with the same argument.</p>\n<p>This is a templated function so the type of the parameters is not predefined and can be anything as long as the listener methods use the same type for the parameter.</p>\n<p>The arguments are passed to the listeners by reference so they can modify them.</p>\n<p>The listener methods are called in the same order they were registered using ofAddListener.</p>\n<p>With this version the listeners also receive a pointer to the notifying class in case the listener method specifies that parameter.</p>\n<p>For instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:</p>\n<pre><code class=\"language-{.cpp}\">\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">SimpleEventNotifier</span> <span class=\"token punctuation\">{</span>\n\tofEvent<span class=\"token operator\">&lt;</span><span class=\"token keyword\">float</span></code></pre>\n"},{"syntax":"ofNotifyEvent(&event, &args, *sender)","name":"ofNotifyEvent","returns":"bool","returns_description":null,"parameters":"EventType <span class=\"token operator\">&amp;</span>event<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> ArgumentsType <span class=\"token operator\">&amp;</span>args<span class=\"token punctuation\">,</span> SenderType <span class=\"token operator\">*</span>sender","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Notifies an event, what makes all it's registered method listeners to be called with the same argument.</p>\n<p>This is a templated function so the type of the parameters is not predefined and can be anything as long as the listener methods use the same type for the parameter.</p>\n<p>The arguments are passed to the listeners by reference so they can modify them.</p>\n<p>The listener methods are called in the same order they were registered using ofAddListener.</p>\n<p>With this version the listeners also receive an event args object that can be used to send additional data to the listening class.</p>\n<p>For instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:</p>\n<pre><code class=\"language-{.cpp}\">\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">SimpleEventNotifier</span> <span class=\"token punctuation\">{</span>\n\tofEvent<span class=\"token operator\">&lt;</span><span class=\"token keyword\">float</span></code></pre>\n"},{"syntax":"ofNotifyEvent(&event, &args, *sender)","name":"ofNotifyEvent","returns":"bool","returns_description":null,"parameters":"EventType <span class=\"token operator\">&amp;</span>event<span class=\"token punctuation\">,</span> ArgumentsType <span class=\"token operator\">&amp;</span>args<span class=\"token punctuation\">,</span> SenderType <span class=\"token operator\">*</span>sender","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>notifies an event so all the registered listeners\nget called</p>\n<p>ie:\nofNotifyEvent(addon.newIntEvent, intArgument, this)</p>\n<p>or in case there's no sender:\nofNotifyEvent(addon.newIntEvent, intArgument)</p>\n<p>@returns: true in case any listener attended the event</p>\n","desc":"<p>Notifies an event, what makes all it's registered method listeners to be called with the same argument.</p>\n<p>This is a templated function so the type of the parameters is not predefined and can be anything as long as the listener methods use the same type for the parameter.</p>\n<p>The arguments are passed to the listeners by reference so they can modify them.</p>\n<p>The listener methods are called in the same order they were registered using ofAddListener.</p>\n<p>For instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:</p>\n<pre><code class=\"language-{.cpp}\">\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">SimpleEventNotifier</span> <span class=\"token punctuation\">{</span>\n\tofEvent notify<span class=\"token punctuation\">;</span>\t<span class=\"token comment\" spellcheck=\"true\">// will send an event with no data</span>\n\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">sendEvent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token function\">ofNotifyEvent</span><span class=\"token punctuation\">(</span>notify<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\t<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<p>We can listen for that in our ofApp:</p>\n<pre><code class=\"language-{.cpp}\">SimpleEventNotifier notifier<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">setup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">ofAddListener</span><span class=\"token punctuation\">(</span>notifier<span class=\"token punctuation\">.</span>notify<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>ofApp<span class=\"token operator\">::</span>haveBeenNotified<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">haveBeenNotified</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">ofLog</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" event at \"</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">ofGetElapsedTimef</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n"},{"short":"","desc":"<p>Notifies an event, what makes all it's registered method listeners to be called with the same argument.</p>\n<p>This is a templated function so the type of the parameters is not predefined and can be anything as long as the listener methods use the same type for the parameter.</p>\n<p>The arguments are passed to the listeners by reference so they can modify them.</p>\n<p>The listener methods are called in the same order they were registered using ofAddListener.</p>\n<p>With this version the listeners also receive a pointer to the notifying class in case the listener method specifies that parameter.</p>\n<p>For instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:</p>\n<pre><code class=\"language-{.cpp}\">\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">SimpleEventNotifier</span> <span class=\"token punctuation\">{</span>\n\tofEvent<span class=\"token operator\">&lt;</span><span class=\"token keyword\">float</span></code></pre>\n"},{"syntax":"ofRemoveListener(&event, *, listenerFunction, prio)","name":"ofRemoveListener","returns":"void","returns_description":null,"parameters":"EventType <span class=\"token operator\">&amp;</span>event<span class=\"token punctuation\">,</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">,</span> ArgumentsType <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span> listenerFunction<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> prio","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"","counter":7},{"syntax":"ofRemoveListener(&event, *, listenerFunction, prio)","name":"ofRemoveListener","returns":"void","returns_description":null,"parameters":"EventType <span class=\"token operator\">&amp;</span>event<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">,</span> ArgumentsType <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span> listenerFunction<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> prio","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"ofRemoveListener(&event, *listener, *, listenerMethod, prio)","name":"ofRemoveListener","returns":"void","returns_description":null,"parameters":"EventType <span class=\"token operator\">&amp;</span>event<span class=\"token punctuation\">,</span> ListenerClass <span class=\"token operator\">*</span>listener<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> <span class=\"token punctuation\">(</span>ListenerClass<span class=\"token operator\">::</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">,</span> ArgumentsType <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span> listenerMethod<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> prio","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Removes a listener method from an event. Use it whenever you want a class to stop being notified about an event after having registered it to the method with ofAddListener.</p>\n<p>Don't forget to call this before deleting any instance that is listening to an event, if not the event will try to notify a non existent instance and the application will crash.</p>\n<p>The syntax is just the same as that of ofAddListener.</p>\n"},{"syntax":"ofRemoveListener(&event, *listener, *, listenerMethod, prio)","name":"ofRemoveListener","returns":"void","returns_description":null,"parameters":"EventType <span class=\"token operator\">&amp;</span>event<span class=\"token punctuation\">,</span> ListenerClass <span class=\"token operator\">*</span>listener<span class=\"token punctuation\">,</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">(</span>ListenerClass<span class=\"token operator\">::</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">,</span> ArgumentsType <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span> listenerMethod<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> prio","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>unregister any method of any class to an event.</p>\n<p>the method must provide one the following\nsignatures:\nvoid method(ArgumentsType &amp; args)\nvoid method(const void * sender, ArgumentsType &amp;args)\nie:\nofAddListener(addon.newIntEvent, this, &amp;Class::method)</p>\n","desc":"<p>Removes a listener method from an event. Use it whenever you want a class to stop being notified about an event after having registered it to the method with ofAddListener.</p>\n<p>Don't forget to call this before deleting any instance that is listening to an event, if not the event will try to notify a non existent instance and the application will crash.</p>\n<p>The syntax is just the same as that of ofAddListener.</p>\n"},{"short":"","desc":"<p>Removes a listener method from an event. Use it whenever you want a class to stop being notified about an event after having registered it to the method with ofAddListener.</p>\n<p>Don't forget to call this before deleting any instance that is listening to an event, if not the event will try to notify a non existent instance and the application will crash.</p>\n<p>The syntax is just the same as that of ofAddListener.</p>\n"},{"short":"","desc":"<p>Removes a listener method from an event. Use it whenever you want a class to stop being notified about an event after having registered it to the method with ofAddListener.</p>\n<p>Don't forget to call this before deleting any instance that is listening to an event, if not the event will try to notify a non existent instance and the application will crash.</p>\n<p>The syntax is just the same as that of ofAddListener.</p>\n"},{"syntax":"ofRemoveListener(&event, *listener, listenerMethod, prio)","name":"ofRemoveListener","returns":"void","returns_description":null,"parameters":"EventType <span class=\"token operator\">&amp;</span>event<span class=\"token punctuation\">,</span> ListenerClass <span class=\"token operator\">*</span>listener<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> <span class=\"token punctuation\">(</span>ListenerClass<span class=\"token operator\">::</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>ArgumentsType <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span> listenerMethod<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> prio","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Removes a listener method from an event. Use it whenever you want a class to stop being notified about an event after having registered it to the method with ofAddListener.</p>\n<p>Don't forget to call this before deleting any instance that is listening to an event, if not the event will try to notify a non existent instance and the application will crash.</p>\n<p>The syntax is just the same as that of ofAddListener.</p>\n"},{"short":"","desc":"<p>Removes a listener method from an event. Use it whenever you want a class to stop being notified about an event after having registered it to the method with ofAddListener.</p>\n<p>Don't forget to call this before deleting any instance that is listening to an event, if not the event will try to notify a non existent instance and the application will crash.</p>\n<p>The syntax is just the same as that of ofAddListener.</p>\n"},{"short":"","desc":"<p>Removes a listener method from an event. Use it whenever you want a class to stop being notified about an event after having registered it to the method with ofAddListener.</p>\n<p>Don't forget to call this before deleting any instance that is listening to an event, if not the event will try to notify a non existent instance and the application will crash.</p>\n<p>The syntax is just the same as that of ofAddListener.</p>\n"},{"syntax":"ofRemoveListener(&event, *listener, listenerMethod, prio)","name":"ofRemoveListener","returns":"void","returns_description":null,"parameters":"EventType <span class=\"token operator\">&amp;</span>event<span class=\"token punctuation\">,</span> ListenerClass <span class=\"token operator\">*</span>listener<span class=\"token punctuation\">,</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">(</span>ListenerClass<span class=\"token operator\">::</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>ArgumentsType <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span> listenerMethod<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> prio","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Removes a listener method from an event. Use it whenever you want a class to stop being notified about an event after having registered it to the method with ofAddListener.</p>\n<p>Don't forget to call this before deleting any instance that is listening to an event, if not the event will try to notify a non existent instance and the application will crash.</p>\n<p>The syntax is just the same as that of ofAddListener.</p>\n"},{"syntax":"ofRemoveListener(&event, listenerFunction, prio)","name":"ofRemoveListener","returns":"void","returns_description":null,"parameters":"EventType <span class=\"token operator\">&amp;</span>event<span class=\"token punctuation\">,</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>ArgumentsType <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span> listenerFunction<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> prio","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"short":"","desc":""},{"short":"","desc":""},{"syntax":"ofRemoveListener(&event, listenerFunction, prio)","name":"ofRemoveListener","returns":"void","returns_description":null,"parameters":"EventType <span class=\"token operator\">&amp;</span>event<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>ArgumentsType <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span> listenerFunction<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> prio","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"short":"","desc":""},{"short":"","desc":""},{}],"document":"<p>#functions</p>\n<!--\n_visible: True_\n_advanced: False_\n-->\n<p>##Description</p>\n<!----------------------------------------------------------------------------->\n<p>###void ofAddListener(&amp;event, *, listenerFunction, prio)</p>\n<!--\n_syntax: ofAddListener(&event, *, listenerFunction, prio)_\n_name: ofAddListener_\n_returns: void_\n_returns_description: _\n_parameters: EventType &event, void (*)(const void *, ArgumentsType &) listenerFunction, int prio_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###void ofAddListener(&amp;event, *, listenerFunction, prio)</p>\n<!--\n_syntax: ofAddListener(&event, *, listenerFunction, prio)_\n_name: ofAddListener_\n_returns: void_\n_returns_description: _\n_parameters: EventType &event, bool (*)(const void *, ArgumentsType &) listenerFunction, int prio_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###void ofAddListener(&amp;event, *listener, *, listenerMethod, prio)</p>\n<!--\n_syntax: ofAddListener(&event, *listener, *, listenerMethod, prio)_\n_name: ofAddListener_\n_returns: void_\n_returns_description: _\n_parameters: EventType &event, ListenerClass *listener, bool (ListenerClass::*)(const void *, ArgumentsType &) listenerMethod, int prio_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Allows you to add a listener method to an event, use it whenever you want a class to be notified about an event.</p>\n<p>This is a templated function so the types of the parameters are not predefined types but can be any type as long as the method is one of the listener class' and it has a particular signature.</p>\n<p>The signature of the listener method depends on the event type. Every event is defined as:</p>\n<pre><code class=\"language-{.cpp}\">ofEvent<span class=\"token operator\">&lt;</span>type<span class=\"token operator\">></span> event<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>where type is the type of the parameter that is going to be passed when the event is notified. The listener method can have one of this two signatures:</p>\n<pre><code class=\"language-{.cpp}\"><span class=\"token keyword\">void</span> <span class=\"token function\">listenerMethod</span><span class=\"token punctuation\">(</span>type <span class=\"token operator\">&amp;</span> parameter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<pre><code class=\"language-{.cpp}\"><span class=\"token keyword\">void</span> <span class=\"token function\">listenerMethod</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span> sender<span class=\"token punctuation\">,</span> type parameter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>Where type must be the same as that of the event it listens to, and sender will be a pointer to the notifying class.</p>\n<p>For instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:</p>\n<pre><code class=\"language-{.cpp}\">\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">SimpleEventNotifier</span> <span class=\"token punctuation\">{</span>\n\tofEvent<span class=\"token operator\">&lt;</span><span class=\"token keyword\">float</span><span class=\"token operator\">></span> notify<span class=\"token punctuation\">;</span>\t<span class=\"token comment\" spellcheck=\"true\">// will send an event with a float</span>\n\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">sendEvent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token function\">ofNotifyEvent</span><span class=\"token punctuation\">(</span>notify<span class=\"token punctuation\">,</span> <span class=\"token function\">ofGetElapsedTimef</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\t<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<p>We can listen for that in our ofApp:</p>\n<pre><code class=\"language-{.cpp}\">SimpleEventNotifier notifier<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">setup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">ofAddListener</span><span class=\"token punctuation\">(</span>notifier<span class=\"token punctuation\">.</span>notify<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>ofApp<span class=\"token operator\">::</span>haveBeenNotified<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">haveBeenNotified</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span> <span class=\"token operator\">&amp;</span>f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">ofLog</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" event at \"</span> <span class=\"token operator\">&lt;&lt;</span> f <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p>The general pattern is:</p>\n<p>A notifying class that will notify defines an ofEvent.\nA listening class that will listen for that ofEvent calls ofAddListener() using the name of the event, the &quot;this&quot; keyword to refer to itself, and a pointer to the method that you want called when the event occurs\nThe notifying class calls ofNotifyEvent() when it's time to send the event.\nThe listening class has its notification method called with the parameters of the ofEvent passed to it.</p>\n<p>This version of the method allows you to use the prio to set whether the event should be called before the application events (mouse and key events, for example) with OF_EVENT_ORDER_BEFORE_APP or after with OF_EVENT_ORDER_AFTER_APP.</p>\n<!----------------------------------------------------------------------------->\n<p>###void ofAddListener(&amp;event, *listener, *, listenerMethod, prio)</p>\n<!--\n_syntax: ofAddListener(&event, *listener, *, listenerMethod, prio)_\n_name: ofAddListener_\n_returns: void_\n_returns_description: _\n_parameters: EventType &event, ListenerClass *listener, void (ListenerClass::*)(const void *, ArgumentsType &) listenerMethod, int prio_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>register any method of any class to an event.</p>\n<p>the method must provide one of the following\nsignatures:\nvoid method(ArgumentsType &amp; args)\nvoid method(const void * sender, ArgumentsType &amp;args)\nie:\nofAddListener(addon.newIntEvent, this, &amp;Class::method)</p>\n<p>_description: _</p>\n<p>Allows you to add a listener method to an event, use it whenever you want a class to be notified about an event.</p>\n<p>This is a templated function so the types of the parameters are not predefined types but can be any type as long as the method is one of the listener class' and it has a particular signature.</p>\n<p>The signature of the listener method depends on the event type. Every event is defined as:</p>\n<pre><code class=\"language-{.cpp}\">ofEvent<span class=\"token operator\">&lt;</span>type<span class=\"token operator\">></span> event<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>where type is the type of the parameter that is going to be passed when the event is notified. The listener method can have one of this two signatures:</p>\n<pre><code class=\"language-{.cpp}\"><span class=\"token keyword\">void</span> <span class=\"token function\">listenerMethod</span><span class=\"token punctuation\">(</span>type <span class=\"token operator\">&amp;</span> parameter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<pre><code class=\"language-{.cpp}\"><span class=\"token keyword\">void</span> <span class=\"token function\">listenerMethod</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span> sender<span class=\"token punctuation\">,</span> type parameter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>Where type must be the same as that of the event it listens to, and sender will be a pointer to the notifying class.</p>\n<p>For instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:</p>\n<pre><code class=\"language-{.cpp}\">\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">SimpleEventNotifier</span> <span class=\"token punctuation\">{</span>\n\tofEvent<span class=\"token operator\">&lt;</span><span class=\"token keyword\">float</span><span class=\"token operator\">></span> notify<span class=\"token punctuation\">;</span>\t<span class=\"token comment\" spellcheck=\"true\">// will send an event with a float</span>\n\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">sendEvent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token function\">ofNotifyEvent</span><span class=\"token punctuation\">(</span>notify<span class=\"token punctuation\">,</span> <span class=\"token function\">ofGetElapsedTimef</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\t<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<p>We can listen for that in our ofApp:</p>\n<pre><code class=\"language-{.cpp}\">SimpleEventNotifier notifier<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">setup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">ofAddListener</span><span class=\"token punctuation\">(</span>notifier<span class=\"token punctuation\">.</span>notify<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>ofApp<span class=\"token operator\">::</span>haveBeenNotified<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">haveBeenNotified</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span> <span class=\"token operator\">&amp;</span>f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">ofLog</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" event at \"</span> <span class=\"token operator\">&lt;&lt;</span> f <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p>The general pattern is:</p>\n<p>A notifying class that will notify defines an ofEvent.\nA listening class that will listen for that ofEvent calls ofAddListener() using the name of the event, the &quot;this&quot; keyword to refer to itself, and a pointer to the method that you want called when the event occurs\nThe notifying class calls ofNotifyEvent() when it's time to send the event.\nThe listening class has its notification method called with the parameters of the ofEvent passed to it.</p>\n<p>This version of the method allows you to use the prio to set whether the event should be called before the application events (mouse and key events, for example) with OF_EVENT_ORDER_BEFORE_APP or after with OF_EVENT_ORDER_AFTER_APP.</p>\n<!----------------------------------------------------------------------------->\n<p>###void ofAddListener(&amp;event, *listener, listenerMethod, prio)</p>\n<!--\n_syntax: ofAddListener(&event, *listener, listenerMethod, prio)_\n_name: ofAddListener_\n_returns: void_\n_returns_description: _\n_parameters: ofEvent< void > &event, ListenerClass *listener, bool (ListenerClass::*)() listenerMethod, int prio_\n_version_started: 0.06_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Allows you to add a listener method to an event, use it whenever you want a class to be notified about an event.</p>\n<p>This is a templated function so the types of the parameters are not predefined types but can be any type as long as the method is one of the listener class' and it has a particular signature.</p>\n<p>The signature of the listener method depends on the event type. Every event is defined as:</p>\n<pre><code class=\"language-{.cpp}\">ofEvent<span class=\"token operator\">&lt;</span>type<span class=\"token operator\">></span> event<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>where type is the type of the parameter that is going to be passed when the event is notified. The listener method can have one of this two signatures:</p>\n<pre><code class=\"language-{.cpp}\"><span class=\"token keyword\">void</span> <span class=\"token function\">listenerMethod</span><span class=\"token punctuation\">(</span>type <span class=\"token operator\">&amp;</span> parameter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<pre><code class=\"language-{.cpp}\"><span class=\"token keyword\">void</span> <span class=\"token function\">listenerMethod</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span> sender<span class=\"token punctuation\">,</span> type parameter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>Where type must be the same as that of the event it listens to, and sender will be a pointer to the notifying class.</p>\n<p>For instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:</p>\n<pre><code class=\"language-{.cpp}\">\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">SimpleEventNotifier</span> <span class=\"token punctuation\">{</span>\n\tofEvent<span class=\"token operator\">&lt;</span><span class=\"token keyword\">float</span><span class=\"token operator\">></span> notify<span class=\"token punctuation\">;</span>\t<span class=\"token comment\" spellcheck=\"true\">// will send an event with a float</span>\n\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">sendEvent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token function\">ofNotifyEvent</span><span class=\"token punctuation\">(</span>notify<span class=\"token punctuation\">,</span> <span class=\"token function\">ofGetElapsedTimef</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\t<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<p>We can listen for that in our ofApp:</p>\n<pre><code class=\"language-{.cpp}\">SimpleEventNotifier notifier<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">setup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">ofAddListener</span><span class=\"token punctuation\">(</span>notifier<span class=\"token punctuation\">.</span>notify<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>ofApp<span class=\"token operator\">::</span>haveBeenNotified<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">haveBeenNotified</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span> <span class=\"token operator\">&amp;</span>f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">ofLog</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" event at \"</span> <span class=\"token operator\">&lt;&lt;</span> f <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p>The general pattern is:</p>\n<p>A notifying class that will notify defines an ofEvent.\nA listening class that will listen for that ofEvent calls ofAddListener() using the name of the event, the &quot;this&quot; keyword to refer to itself, and a pointer to the method that you want called when the event occurs\nThe notifying class calls ofNotifyEvent() when it's time to send the event.\nThe listening class has its notification method called with the parameters of the ofEvent passed to it.</p>\n<!----------------------------------------------------------------------------->\n<p>###void ofAddListener(&amp;event, *listener, listenerMethod, prio)</p>\n<!--\n_syntax: ofAddListener(&event, *listener, listenerMethod, prio)_\n_name: ofAddListener_\n_returns: void_\n_returns_description: _\n_parameters: ofEvent< void > &event, ListenerClass *listener, bool (ListenerClass::*)(const void *) listenerMethod, int prio_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Allows you to add a listener method to an event, use it whenever you want a class to be notified about an event.</p>\n<p>This is a templated function so the types of the parameters are not predefined types but can be any type as long as the method is one of the listener class' and it has a particular signature.</p>\n<p>The signature of the listener method depends on the event type. Every event is defined as:</p>\n<pre><code class=\"language-{.cpp}\">ofEvent<span class=\"token operator\">&lt;</span>type<span class=\"token operator\">></span> event<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>where type is the type of the parameter that is going to be passed when the event is notified. The listener method can have one of this two signatures:</p>\n<pre><code class=\"language-{.cpp}\"><span class=\"token keyword\">void</span> <span class=\"token function\">listenerMethod</span><span class=\"token punctuation\">(</span>type <span class=\"token operator\">&amp;</span> parameter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<pre><code class=\"language-{.cpp}\"><span class=\"token keyword\">void</span> <span class=\"token function\">listenerMethod</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span> sender<span class=\"token punctuation\">,</span> type parameter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>Where type must be the same as that of the event it listens to, and sender will be a pointer to the notifying class.</p>\n<p>For instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:</p>\n<pre><code class=\"language-{.cpp}\">\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">SimpleEventNotifier</span> <span class=\"token punctuation\">{</span>\n\tofEvent<span class=\"token operator\">&lt;</span><span class=\"token keyword\">float</span><span class=\"token operator\">></span> notify<span class=\"token punctuation\">;</span>\t<span class=\"token comment\" spellcheck=\"true\">// will send an event with a float</span>\n\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">sendEvent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token function\">ofNotifyEvent</span><span class=\"token punctuation\">(</span>notify<span class=\"token punctuation\">,</span> <span class=\"token function\">ofGetElapsedTimef</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\t<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<p>We can listen for that in our ofApp:</p>\n<pre><code class=\"language-{.cpp}\">SimpleEventNotifier notifier<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">setup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">ofAddListener</span><span class=\"token punctuation\">(</span>notifier<span class=\"token punctuation\">.</span>notify<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>ofApp<span class=\"token operator\">::</span>haveBeenNotified<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">haveBeenNotified</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span> <span class=\"token operator\">&amp;</span>f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">ofLog</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" event at \"</span> <span class=\"token operator\">&lt;&lt;</span> f <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p>The general pattern is:</p>\n<p>A notifying class that will notify defines an ofEvent.\nA listening class that will listen for that ofEvent calls ofAddListener() using the name of the event, the &quot;this&quot; keyword to refer to itself, and a pointer to the method that you want called when the event occurs\nThe notifying class calls ofNotifyEvent() when it's time to send the event.\nThe listening class has its notification method called with the parameters of the ofEvent passed to it.</p>\n<p>Note that the event is a reference, which means it needs to a member of your class that will not go away in the lifetime of the object.</p>\n<p>This version of the method allows you to use the prio to set whether the event should be called before the application events (mouse and key events, for example) with OF_EVENT_ORDER_BEFORE_APP or after with OF_EVENT_ORDER_AFTER_APP.</p>\n<!----------------------------------------------------------------------------->\n<p>###void ofAddListener(&amp;event, *listener, listenerMethod, prio)</p>\n<!--\n_syntax: ofAddListener(&event, *listener, listenerMethod, prio)_\n_name: ofAddListener_\n_returns: void_\n_returns_description: _\n_parameters: EventType &event, ListenerClass *listener, bool (ListenerClass::*)(ArgumentsType &) listenerMethod, int prio_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Allows you to add a listener method to an event, use it whenever you want a class to be notified about an event.</p>\n<p>This is a templated function so the types of the parameters are not predefined types but can be any type as long as the method is one of the listener class' and it has a particular signature.</p>\n<p>The signature of the listener method depends on the event type. Every event is defined as:</p>\n<pre><code class=\"language-{.cpp}\">ofEvent<span class=\"token operator\">&lt;</span>type<span class=\"token operator\">></span> event<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>where type is the type of the parameter that is going to be passed when the event is notified. The listener method can have one of this two signatures:</p>\n<pre><code class=\"language-{.cpp}\"><span class=\"token keyword\">void</span> <span class=\"token function\">listenerMethod</span><span class=\"token punctuation\">(</span>type <span class=\"token operator\">&amp;</span> parameter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<pre><code class=\"language-{.cpp}\"><span class=\"token keyword\">void</span> <span class=\"token function\">listenerMethod</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span> sender<span class=\"token punctuation\">,</span> type parameter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>Where type must be the same as that of the event it listens to, and sender will be a pointer to the notifying class.</p>\n<p>For instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:</p>\n<pre><code class=\"language-{.cpp}\">\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">SimpleEventNotifier</span> <span class=\"token punctuation\">{</span>\n\tofEvent<span class=\"token operator\">&lt;</span><span class=\"token keyword\">float</span><span class=\"token operator\">></span> notify<span class=\"token punctuation\">;</span>\t<span class=\"token comment\" spellcheck=\"true\">// will send an event with a float</span>\n\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">sendEvent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token function\">ofNotifyEvent</span><span class=\"token punctuation\">(</span>notify<span class=\"token punctuation\">,</span> <span class=\"token function\">ofGetElapsedTimef</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\t<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<p>We can listen for that in our ofApp:</p>\n<pre><code class=\"language-{.cpp}\">SimpleEventNotifier notifier<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">setup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">ofAddListener</span><span class=\"token punctuation\">(</span>notifier<span class=\"token punctuation\">.</span>notify<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>ofApp<span class=\"token operator\">::</span>haveBeenNotified<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">haveBeenNotified</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span> <span class=\"token operator\">&amp;</span>f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">ofLog</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" event at \"</span> <span class=\"token operator\">&lt;&lt;</span> f <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p>The general pattern is:</p>\n<p>A notifying class that will notify defines an ofEvent.\nA listening class that will listen for that ofEvent calls ofAddListener() using the name of the event, the &quot;this&quot; keyword to refer to itself, and a pointer to the method that you want called when the event occurs\nThe notifying class calls ofNotifyEvent() when it's time to send the event.\nThe listening class has its notification method called with the parameters of the ofEvent passed to it.</p>\n<p>This version of the method allows you to use the prio to set whether the event should be called before the application events (mouse and key events, for example) with OF_EVENT_ORDER_BEFORE_APP or after with OF_EVENT_ORDER_AFTER_APP.</p>\n<!----------------------------------------------------------------------------->\n<p>###void ofAddListener(&amp;event, *listener, listenerMethod, prio)</p>\n<!--\n_syntax: ofAddListener(&event, *listener, listenerMethod, prio)_\n_name: ofAddListener_\n_returns: void_\n_returns_description: _\n_parameters: ofEvent< void > &event, ListenerClass *listener, void (ListenerClass::*)() listenerMethod, int prio_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Allows you to add a listener method to an event, use it whenever you want a class to be notified about an event.</p>\n<p>This is a templated function so the types of the parameters are not predefined types but can be any type as long as the method is one of the listener class' and it has a particular signature.</p>\n<p>The signature of the listener method depends on the event type. Every event is defined as:</p>\n<pre><code class=\"language-{.cpp}\">ofEvent<span class=\"token operator\">&lt;</span>type<span class=\"token operator\">></span> event<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>where type is the type of the parameter that is going to be passed when the event is notified. The listener method can have one of this two signatures:</p>\n<pre><code class=\"language-{.cpp}\"><span class=\"token keyword\">void</span> <span class=\"token function\">listenerMethod</span><span class=\"token punctuation\">(</span>type <span class=\"token operator\">&amp;</span> parameter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<pre><code class=\"language-{.cpp}\"><span class=\"token keyword\">void</span> <span class=\"token function\">listenerMethod</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span> sender<span class=\"token punctuation\">,</span> type parameter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>Where type must be the same as that of the event it listens to, and sender will be a pointer to the notifying class.</p>\n<p>For instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:</p>\n<pre><code class=\"language-{.cpp}\">\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">SimpleEventNotifier</span> <span class=\"token punctuation\">{</span>\n\tofEvent<span class=\"token operator\">&lt;</span><span class=\"token keyword\">float</span><span class=\"token operator\">></span> notify<span class=\"token punctuation\">;</span>\t<span class=\"token comment\" spellcheck=\"true\">// will send an event with a float</span>\n\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">sendEvent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token function\">ofNotifyEvent</span><span class=\"token punctuation\">(</span>notify<span class=\"token punctuation\">,</span> <span class=\"token function\">ofGetElapsedTimef</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\t<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<p>We can listen for that in our ofApp:</p>\n<pre><code class=\"language-{.cpp}\">SimpleEventNotifier notifier<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">setup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">ofAddListener</span><span class=\"token punctuation\">(</span>notifier<span class=\"token punctuation\">.</span>notify<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>ofApp<span class=\"token operator\">::</span>haveBeenNotified<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">haveBeenNotified</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span> <span class=\"token operator\">&amp;</span>f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">ofLog</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" event at \"</span> <span class=\"token operator\">&lt;&lt;</span> f <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p>The general pattern is:</p>\n<p>A notifying class that will notify defines an ofEvent.\nA listening class that will listen for that ofEvent calls ofAddListener() using the name of the event, the &quot;this&quot; keyword to refer to itself, and a pointer to the method that you want called when the event occurs\nThe notifying class calls ofNotifyEvent() when it's time to send the event.\nThe listening class has its notification method called with the parameters of the ofEvent passed to it.</p>\n<p>This version of the method allows you to use the prio to set whether the event should be called before the application events (mouse and key events, for example) with OF_EVENT_ORDER_BEFORE_APP or after with OF_EVENT_ORDER_AFTER_APP.</p>\n<!----------------------------------------------------------------------------->\n<p>###void ofAddListener(&amp;event, *listener, listenerMethod, prio)</p>\n<!--\n_syntax: ofAddListener(&event, *listener, listenerMethod, prio)_\n_name: ofAddListener_\n_returns: void_\n_returns_description: _\n_parameters: ofEvent< void > &event, ListenerClass *listener, void (ListenerClass::*)(const void *) listenerMethod, int prio_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Allows you to add a listener method to an event, use it whenever you want a class to be notified about an event.</p>\n<p>This is a templated function so the types of the parameters are not predefined types but can be any type as long as the method is one of the listener class' and it has a particular signature.</p>\n<p>The signature of the listener method depends on the event type. Every event is defined as:</p>\n<pre><code class=\"language-{.cpp}\">ofEvent<span class=\"token operator\">&lt;</span>type<span class=\"token operator\">></span> event<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>where type is the type of the parameter that is going to be passed when the event is notified. The listener method can have one of this two signatures:</p>\n<pre><code class=\"language-{.cpp}\"><span class=\"token keyword\">void</span> <span class=\"token function\">listenerMethod</span><span class=\"token punctuation\">(</span>type <span class=\"token operator\">&amp;</span> parameter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<pre><code class=\"language-{.cpp}\"><span class=\"token keyword\">void</span> <span class=\"token function\">listenerMethod</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span> sender<span class=\"token punctuation\">,</span> type parameter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>Where type must be the same as that of the event it listens to, and sender will be a pointer to the notifying class.</p>\n<p>For instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:</p>\n<pre><code class=\"language-{.cpp}\">\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">SimpleEventNotifier</span> <span class=\"token punctuation\">{</span>\n\tofEvent<span class=\"token operator\">&lt;</span><span class=\"token keyword\">float</span><span class=\"token operator\">></span> notify<span class=\"token punctuation\">;</span>\t<span class=\"token comment\" spellcheck=\"true\">// will send an event with a float</span>\n\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">sendEvent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token function\">ofNotifyEvent</span><span class=\"token punctuation\">(</span>notify<span class=\"token punctuation\">,</span> <span class=\"token function\">ofGetElapsedTimef</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\t<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<p>We can listen for that in our ofApp:</p>\n<pre><code class=\"language-{.cpp}\">SimpleEventNotifier notifier<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">setup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">ofAddListener</span><span class=\"token punctuation\">(</span>notifier<span class=\"token punctuation\">.</span>notify<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>ofApp<span class=\"token operator\">::</span>haveBeenNotified<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">haveBeenNotified</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span> <span class=\"token operator\">&amp;</span>f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">ofLog</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" event at \"</span> <span class=\"token operator\">&lt;&lt;</span> f <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p>The general pattern is:</p>\n<p>A notifying class that will notify defines an ofEvent.\nA listening class that will listen for that ofEvent calls ofAddListener() using the name of the event, the &quot;this&quot; keyword to refer to itself, and a pointer to the method that you want called when the event occurs\nThe notifying class calls ofNotifyEvent() when it's time to send the event.\nThe listening class has its notification method called with the parameters of the ofEvent passed to it.</p>\n<p>This version of the method allows you to use the prio to set whether the event should be called before the application events (mouse and key events, for example) with OF_EVENT_ORDER_BEFORE_APP or after with OF_EVENT_ORDER_AFTER_APP.</p>\n<!----------------------------------------------------------------------------->\n<p>###void ofAddListener(&amp;event, *listener, listenerMethod, prio)</p>\n<!--\n_syntax: ofAddListener(&event, *listener, listenerMethod, prio)_\n_name: ofAddListener_\n_returns: void_\n_returns_description: _\n_parameters: EventType &event, ListenerClass *listener, void (ListenerClass::*)(ArgumentsType &) listenerMethod, int prio_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Allows you to add a listener method to an event, use it whenever you want a class to be notified about an event.</p>\n<p>This is a templated function so the types of the parameters are not predefined types but can be any type as long as the method is one of the listener class' and it has a particular signature.</p>\n<p>The signature of the listener method depends on the event type. Every event is defined as:</p>\n<pre><code class=\"language-{.cpp}\">ofEvent<span class=\"token operator\">&lt;</span>type<span class=\"token operator\">></span> event<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>where type is the type of the parameter that is going to be passed when the event is notified. The listener method can have one of this two signatures:</p>\n<pre><code class=\"language-{.cpp}\"><span class=\"token keyword\">void</span> <span class=\"token function\">listenerMethod</span><span class=\"token punctuation\">(</span>type <span class=\"token operator\">&amp;</span> parameter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<pre><code class=\"language-{.cpp}\"><span class=\"token keyword\">void</span> <span class=\"token function\">listenerMethod</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span> sender<span class=\"token punctuation\">,</span> type parameter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>Where type must be the same as that of the event it listens to, and sender will be a pointer to the notifying class.</p>\n<p>For instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:</p>\n<pre><code class=\"language-{.cpp}\">\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">SimpleEventNotifier</span> <span class=\"token punctuation\">{</span>\n\tofEvent<span class=\"token operator\">&lt;</span><span class=\"token keyword\">float</span><span class=\"token operator\">></span> notify<span class=\"token punctuation\">;</span>\t<span class=\"token comment\" spellcheck=\"true\">// will send an event with a float</span>\n\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">sendEvent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token function\">ofNotifyEvent</span><span class=\"token punctuation\">(</span>notify<span class=\"token punctuation\">,</span> <span class=\"token function\">ofGetElapsedTimef</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\t<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<p>We can listen for that in our ofApp:</p>\n<pre><code class=\"language-{.cpp}\">SimpleEventNotifier notifier<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">setup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">ofAddListener</span><span class=\"token punctuation\">(</span>notifier<span class=\"token punctuation\">.</span>notify<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>ofApp<span class=\"token operator\">::</span>haveBeenNotified<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">haveBeenNotified</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span> <span class=\"token operator\">&amp;</span>f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">ofLog</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" event at \"</span> <span class=\"token operator\">&lt;&lt;</span> f <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p>The general pattern is:</p>\n<p>A notifying class that will notify defines an ofEvent.\nA listening class that will listen for that ofEvent calls ofAddListener() using the name of the event, the &quot;this&quot; keyword to refer to itself, and a pointer to the method that you want called when the event occurs\nThe notifying class calls ofNotifyEvent() when it's time to send the event.\nThe listening class has its notification method called with the parameters of the ofEvent passed to it.</p>\n<p>This version of the method allows you to use the prio to set whether the event should be called before the application events (mouse and key events, for example) with OF_EVENT_ORDER_BEFORE_APP or after with OF_EVENT_ORDER_AFTER_APP.</p>\n<!----------------------------------------------------------------------------->\n<p>###void ofAddListener(&amp;event, listenerFunction, prio)</p>\n<!--\n_syntax: ofAddListener(&event, listenerFunction, prio)_\n_name: ofAddListener_\n_returns: void_\n_returns_description: _\n_parameters: EventType &event, void (*)(ArgumentsType &) listenerFunction, int prio_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###void ofAddListener(&amp;event, listenerFunction, prio)</p>\n<!--\n_syntax: ofAddListener(&event, listenerFunction, prio)_\n_name: ofAddListener_\n_returns: void_\n_returns_description: _\n_parameters: ofEvent< void > &event, void (*)(const void *) listenerFunction, int prio_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###void ofAddListener(&amp;event, listenerFunction, prio)</p>\n<!--\n_syntax: ofAddListener(&event, listenerFunction, prio)_\n_name: ofAddListener_\n_returns: void_\n_returns_description: _\n_parameters: ofEvent< void > &event, void (*)() listenerFunction, int prio_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###void ofAddListener(&amp;event, listenerFunction, prio)</p>\n<!--\n_syntax: ofAddListener(&event, listenerFunction, prio)_\n_name: ofAddListener_\n_returns: void_\n_returns_description: _\n_parameters: EventType &event, bool (*)(ArgumentsType &) listenerFunction, int prio_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###void ofAddListener(&amp;event, listenerFunction, prio)</p>\n<!--\n_syntax: ofAddListener(&event, listenerFunction, prio)_\n_name: ofAddListener_\n_returns: void_\n_returns_description: _\n_parameters: ofEvent< void > &event, bool (*)(const void *) listenerFunction, int prio_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###void ofAddListener(&amp;event, listenerFunction, prio)</p>\n<!--\n_syntax: ofAddListener(&event, listenerFunction, prio)_\n_name: ofAddListener_\n_returns: void_\n_returns_description: _\n_parameters: ofEvent< void > &event, bool (*)() listenerFunction, int prio_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###bool ofNotifyEvent(&amp;event)</p>\n<!--\n_syntax: ofNotifyEvent(&event)_\n_name: ofNotifyEvent_\n_returns: bool_\n_returns_description: _\n_parameters: ofEvent< void > &event_\n_version_started: 0.06_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Notifies an event, what makes all it's registered method listeners to be called with the same argument.</p>\n<p>This is a templated function so the type of the parameters is not predefined and can be anything as long as the listener methods use the same type for the parameter.</p>\n<p>The arguments are passed to the listeners by reference so they can modify them.</p>\n<p>The listener methods are called in the same order they were registered using ofAddListener.</p>\n<p>For instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:</p>\n<pre><code class=\"language-{.cpp}\">\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">SimpleEventNotifier</span> <span class=\"token punctuation\">{</span>\n\tofEvent<span class=\"token operator\">&lt;</span><span class=\"token keyword\">float</span><span class=\"token operator\">></span> notify<span class=\"token punctuation\">;</span>\t<span class=\"token comment\" spellcheck=\"true\">// will send an event with a float</span>\n\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">sendEvent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token function\">ofNotifyEvent</span><span class=\"token punctuation\">(</span>notify<span class=\"token punctuation\">,</span> <span class=\"token function\">ofGetElapsedTimef</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\t<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<p>We can listen for that in our ofApp:</p>\n<pre><code class=\"language-{.cpp}\">SimpleEventNotifier notifier<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">setup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">ofAddListener</span><span class=\"token punctuation\">(</span>notifier<span class=\"token punctuation\">.</span>notify<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>ofApp<span class=\"token operator\">::</span>haveBeenNotified<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">haveBeenNotified</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span> <span class=\"token operator\">&amp;</span>f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">ofLog</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" event at \"</span> <span class=\"token operator\">&lt;&lt;</span> f <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<!----------------------------------------------------------------------------->\n<p>###bool ofNotifyEvent(&amp;event, &amp;args)</p>\n<!--\n_syntax: ofNotifyEvent(&event, &args)_\n_name: ofNotifyEvent_\n_returns: bool_\n_returns_description: _\n_parameters: EventType &event, const ArgumentsType &args_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Notifies an event, what makes all it's registered method listeners to be called with the same argument.</p>\n<p>This is a templated function so the type of the parameters is not predefined and can be anything as long as the listener methods use the same type for the parameter.</p>\n<p>The arguments are passed to the listeners by reference so they can modify them.</p>\n<p>The listener methods are called in the same order they were registered using ofAddListener.</p>\n<p>With this version the listeners also receive a pointer to the notifying class in case the listener method specifies that parameter.</p>\n<p>For instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:</p>\n<pre><code class=\"language-{.cpp}\">\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">SimpleEventNotifier</span> <span class=\"token punctuation\">{</span>\n\tofEvent<span class=\"token operator\">&lt;</span><span class=\"token keyword\">float</span><span class=\"token operator\">></span> notify<span class=\"token punctuation\">;</span>\t<span class=\"token comment\" spellcheck=\"true\">// will send an event with a float</span>\n\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">sendEvent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token function\">ofNotifyEvent</span><span class=\"token punctuation\">(</span>notify<span class=\"token punctuation\">,</span> <span class=\"token function\">ofGetElapsedTimef</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\t<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<p>We can listen for that in our ofApp:</p>\n<pre><code class=\"language-{.cpp}\">SimpleEventNotifier notifier<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">setup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">ofAddListener</span><span class=\"token punctuation\">(</span>notifier<span class=\"token punctuation\">.</span>notify<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>ofApp<span class=\"token operator\">::</span>haveBeenNotified<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">haveBeenNotified</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span> <span class=\"token operator\">&amp;</span>f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">ofLog</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" event at \"</span> <span class=\"token operator\">&lt;&lt;</span> f <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<!----------------------------------------------------------------------------->\n<p>###bool ofNotifyEvent(&amp;event, &amp;args)</p>\n<!--\n_syntax: ofNotifyEvent(&event, &args)_\n_name: ofNotifyEvent_\n_returns: bool_\n_returns_description: _\n_parameters: EventType &event, ArgumentsType &args_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Notifies an event, what makes all it's registered method listeners to be called with the same argument.</p>\n<p>This is a templated function so the type of the parameters is not predefined and can be anything as long as the listener methods use the same type for the parameter.</p>\n<p>The arguments are passed to the listeners by reference so they can modify them.</p>\n<p>The listener methods are called in the same order they were registered using ofAddListener.</p>\n<p>With this version the listeners also receive a pointer to the notifying class in case the listener method specifies that parameter.</p>\n<p>For instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:</p>\n<pre><code class=\"language-{.cpp}\">\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">SimpleEventNotifier</span> <span class=\"token punctuation\">{</span>\n\tofEvent<span class=\"token operator\">&lt;</span><span class=\"token keyword\">float</span><span class=\"token operator\">></span> notify<span class=\"token punctuation\">;</span>\t<span class=\"token comment\" spellcheck=\"true\">// will send an event with a float</span>\n\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">sendEvent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token function\">ofNotifyEvent</span><span class=\"token punctuation\">(</span>notify<span class=\"token punctuation\">,</span> <span class=\"token function\">ofGetElapsedTimef</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\t<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<p>We can listen for that in our ofApp:</p>\n<pre><code class=\"language-{.cpp}\">SimpleEventNotifier notifier<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">setup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">ofAddListener</span><span class=\"token punctuation\">(</span>notifier<span class=\"token punctuation\">.</span>notify<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>ofApp<span class=\"token operator\">::</span>haveBeenNotified<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">haveBeenNotified</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span> <span class=\"token operator\">&amp;</span>f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">ofLog</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" event at \"</span> <span class=\"token operator\">&lt;&lt;</span> f <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<!----------------------------------------------------------------------------->\n<p>###bool ofNotifyEvent(&amp;event, &amp;args, *sender)</p>\n<!--\n_syntax: ofNotifyEvent(&event, &args, *sender)_\n_name: ofNotifyEvent_\n_returns: bool_\n_returns_description: _\n_parameters: EventType &event, const ArgumentsType &args, SenderType *sender_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Notifies an event, what makes all it's registered method listeners to be called with the same argument.</p>\n<p>This is a templated function so the type of the parameters is not predefined and can be anything as long as the listener methods use the same type for the parameter.</p>\n<p>The arguments are passed to the listeners by reference so they can modify them.</p>\n<p>The listener methods are called in the same order they were registered using ofAddListener.</p>\n<p>With this version the listeners also receive an event args object that can be used to send additional data to the listening class.</p>\n<p>For instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:</p>\n<pre><code class=\"language-{.cpp}\">\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">SimpleEventNotifier</span> <span class=\"token punctuation\">{</span>\n\tofEvent<span class=\"token operator\">&lt;</span><span class=\"token keyword\">float</span><span class=\"token operator\">></span> notify<span class=\"token punctuation\">;</span>\t<span class=\"token comment\" spellcheck=\"true\">// will send an event with a float</span>\n\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">sendEvent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token function\">ofNotifyEvent</span><span class=\"token punctuation\">(</span>notify<span class=\"token punctuation\">,</span> <span class=\"token function\">ofGetElapsedTimef</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\t<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<p>We can listen for that in our ofApp:</p>\n<pre><code class=\"language-{.cpp}\">SimpleEventNotifier notifier<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">setup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">ofAddListener</span><span class=\"token punctuation\">(</span>notifier<span class=\"token punctuation\">.</span>notify<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>ofApp<span class=\"token operator\">::</span>haveBeenNotified<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">haveBeenNotified</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span> <span class=\"token operator\">&amp;</span>f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">ofLog</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" event at \"</span> <span class=\"token operator\">&lt;&lt;</span> f <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<!----------------------------------------------------------------------------->\n<p>###bool ofNotifyEvent(&amp;event, &amp;args, *sender)</p>\n<!--\n_syntax: ofNotifyEvent(&event, &args, *sender)_\n_name: ofNotifyEvent_\n_returns: bool_\n_returns_description: _\n_parameters: EventType &event, ArgumentsType &args, SenderType *sender_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>notifies an event so all the registered listeners\nget called</p>\n<p>ie:\nofNotifyEvent(addon.newIntEvent, intArgument, this)</p>\n<p>or in case there's no sender:\nofNotifyEvent(addon.newIntEvent, intArgument)</p>\n<p>@returns: true in case any listener attended the event</p>\n<p>_description: _</p>\n<p>Notifies an event, what makes all it's registered method listeners to be called with the same argument.</p>\n<p>This is a templated function so the type of the parameters is not predefined and can be anything as long as the listener methods use the same type for the parameter.</p>\n<p>The arguments are passed to the listeners by reference so they can modify them.</p>\n<p>The listener methods are called in the same order they were registered using ofAddListener.</p>\n<p>For instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:</p>\n<pre><code class=\"language-{.cpp}\">\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">SimpleEventNotifier</span> <span class=\"token punctuation\">{</span>\n\tofEvent notify<span class=\"token punctuation\">;</span>\t<span class=\"token comment\" spellcheck=\"true\">// will send an event with no data</span>\n\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">sendEvent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token function\">ofNotifyEvent</span><span class=\"token punctuation\">(</span>notify<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\t<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<p>We can listen for that in our ofApp:</p>\n<pre><code class=\"language-{.cpp}\">SimpleEventNotifier notifier<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">setup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">ofAddListener</span><span class=\"token punctuation\">(</span>notifier<span class=\"token punctuation\">.</span>notify<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>ofApp<span class=\"token operator\">::</span>haveBeenNotified<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">haveBeenNotified</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">ofLog</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" event at \"</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">ofGetElapsedTimef</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<!----------------------------------------------------------------------------->\n<p>###bool ofNotifyEvent(&amp;event, *sender)</p>\n<!--\n_syntax: ofNotifyEvent(&event, *sender)_\n_name: ofNotifyEvent_\n_returns: bool_\n_returns_description: _\n_parameters: ofEvent< void > &event, SenderType *sender_\n_version_started: 0.06_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Notifies an event, what makes all it's registered method listeners to be called with the same argument.</p>\n<p>This is a templated function so the type of the parameters is not predefined and can be anything as long as the listener methods use the same type for the parameter.</p>\n<p>The arguments are passed to the listeners by reference so they can modify them.</p>\n<p>The listener methods are called in the same order they were registered using ofAddListener.</p>\n<p>With this version the listeners also receive a pointer to the notifying class in case the listener method specifies that parameter.</p>\n<p>For instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:</p>\n<pre><code class=\"language-{.cpp}\">\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">SimpleEventNotifier</span> <span class=\"token punctuation\">{</span>\n\tofEvent<span class=\"token operator\">&lt;</span><span class=\"token keyword\">float</span><span class=\"token operator\">></span> notify<span class=\"token punctuation\">;</span>\t<span class=\"token comment\" spellcheck=\"true\">// will send an event with a float</span>\n\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">sendEvent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token function\">ofNotifyEvent</span><span class=\"token punctuation\">(</span>notify<span class=\"token punctuation\">,</span> <span class=\"token function\">ofGetElapsedTimef</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\t<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<p>We can listen for that in our ofApp:</p>\n<pre><code class=\"language-{.cpp}\">SimpleEventNotifier notifier<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">setup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">ofAddListener</span><span class=\"token punctuation\">(</span>notifier<span class=\"token punctuation\">.</span>notify<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>ofApp<span class=\"token operator\">::</span>haveBeenNotified<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">haveBeenNotified</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span> <span class=\"token operator\">&amp;</span>f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">ofLog</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" event at \"</span> <span class=\"token operator\">&lt;&lt;</span> f <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<!----------------------------------------------------------------------------->\n<p>###void ofRemoveListener(&amp;event, *, listenerFunction, prio)</p>\n<!--\n_syntax: ofRemoveListener(&event, *, listenerFunction, prio)_\n_name: ofRemoveListener_\n_returns: void_\n_returns_description: _\n_parameters: EventType &event, void (*)(const void *, ArgumentsType &) listenerFunction, int prio_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###void ofRemoveListener(&amp;event, *, listenerFunction, prio)</p>\n<!--\n_syntax: ofRemoveListener(&event, *, listenerFunction, prio)_\n_name: ofRemoveListener_\n_returns: void_\n_returns_description: _\n_parameters: EventType &event, bool (*)(const void *, ArgumentsType &) listenerFunction, int prio_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###void ofRemoveListener(&amp;event, *listener, *, listenerMethod, prio)</p>\n<!--\n_syntax: ofRemoveListener(&event, *listener, *, listenerMethod, prio)_\n_name: ofRemoveListener_\n_returns: void_\n_returns_description: _\n_parameters: EventType &event, ListenerClass *listener, bool (ListenerClass::*)(const void *, ArgumentsType &) listenerMethod, int prio_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Removes a listener method from an event. Use it whenever you want a class to stop being notified about an event after having registered it to the method with ofAddListener.</p>\n<p>Don't forget to call this before deleting any instance that is listening to an event, if not the event will try to notify a non existent instance and the application will crash.</p>\n<p>The syntax is just the same as that of ofAddListener.</p>\n<!----------------------------------------------------------------------------->\n<p>###void ofRemoveListener(&amp;event, *listener, *, listenerMethod, prio)</p>\n<!--\n_syntax: ofRemoveListener(&event, *listener, *, listenerMethod, prio)_\n_name: ofRemoveListener_\n_returns: void_\n_returns_description: _\n_parameters: EventType &event, ListenerClass *listener, void (ListenerClass::*)(const void *, ArgumentsType &) listenerMethod, int prio_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>unregister any method of any class to an event.</p>\n<p>the method must provide one the following\nsignatures:\nvoid method(ArgumentsType &amp; args)\nvoid method(const void * sender, ArgumentsType &amp;args)\nie:\nofAddListener(addon.newIntEvent, this, &amp;Class::method)</p>\n<p>_description: _</p>\n<p>Removes a listener method from an event. Use it whenever you want a class to stop being notified about an event after having registered it to the method with ofAddListener.</p>\n<p>Don't forget to call this before deleting any instance that is listening to an event, if not the event will try to notify a non existent instance and the application will crash.</p>\n<p>The syntax is just the same as that of ofAddListener.</p>\n<!----------------------------------------------------------------------------->\n<p>###void ofRemoveListener(&amp;event, *listener, listenerMethod, prio)</p>\n<!--\n_syntax: ofRemoveListener(&event, *listener, listenerMethod, prio)_\n_name: ofRemoveListener_\n_returns: void_\n_returns_description: _\n_parameters: ofEvent< void > &event, ListenerClass *listener, bool (ListenerClass::*)() listenerMethod, int prio_\n_version_started: 0.06_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Removes a listener method from an event. Use it whenever you want a class to stop being notified about an event after having registered it to the method with ofAddListener.</p>\n<p>Don't forget to call this before deleting any instance that is listening to an event, if not the event will try to notify a non existent instance and the application will crash.</p>\n<p>The syntax is just the same as that of ofAddListener.</p>\n<!----------------------------------------------------------------------------->\n<p>###void ofRemoveListener(&amp;event, *listener, listenerMethod, prio)</p>\n<!--\n_syntax: ofRemoveListener(&event, *listener, listenerMethod, prio)_\n_name: ofRemoveListener_\n_returns: void_\n_returns_description: _\n_parameters: ofEvent< void > &event, ListenerClass *listener, bool (ListenerClass::*)(const void *) listenerMethod, int prio_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Removes a listener method from an event. Use it whenever you want a class to stop being notified about an event after having registered it to the method with ofAddListener.</p>\n<p>Don't forget to call this before deleting any instance that is listening to an event, if not the event will try to notify a non existent instance and the application will crash.</p>\n<p>The syntax is just the same as that of ofAddListener.</p>\n<!----------------------------------------------------------------------------->\n<p>###void ofRemoveListener(&amp;event, *listener, listenerMethod, prio)</p>\n<!--\n_syntax: ofRemoveListener(&event, *listener, listenerMethod, prio)_\n_name: ofRemoveListener_\n_returns: void_\n_returns_description: _\n_parameters: EventType &event, ListenerClass *listener, bool (ListenerClass::*)(ArgumentsType &) listenerMethod, int prio_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Removes a listener method from an event. Use it whenever you want a class to stop being notified about an event after having registered it to the method with ofAddListener.</p>\n<p>Don't forget to call this before deleting any instance that is listening to an event, if not the event will try to notify a non existent instance and the application will crash.</p>\n<p>The syntax is just the same as that of ofAddListener.</p>\n<!----------------------------------------------------------------------------->\n<p>###void ofRemoveListener(&amp;event, *listener, listenerMethod, prio)</p>\n<!--\n_syntax: ofRemoveListener(&event, *listener, listenerMethod, prio)_\n_name: ofRemoveListener_\n_returns: void_\n_returns_description: _\n_parameters: ofEvent< void > &event, ListenerClass *listener, void (ListenerClass::*)() listenerMethod, int prio_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Removes a listener method from an event. Use it whenever you want a class to stop being notified about an event after having registered it to the method with ofAddListener.</p>\n<p>Don't forget to call this before deleting any instance that is listening to an event, if not the event will try to notify a non existent instance and the application will crash.</p>\n<p>The syntax is just the same as that of ofAddListener.</p>\n<!----------------------------------------------------------------------------->\n<p>###void ofRemoveListener(&amp;event, *listener, listenerMethod, prio)</p>\n<!--\n_syntax: ofRemoveListener(&event, *listener, listenerMethod, prio)_\n_name: ofRemoveListener_\n_returns: void_\n_returns_description: _\n_parameters: ofEvent< void > &event, ListenerClass *listener, void (ListenerClass::*)(const void *) listenerMethod, int prio_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Removes a listener method from an event. Use it whenever you want a class to stop being notified about an event after having registered it to the method with ofAddListener.</p>\n<p>Don't forget to call this before deleting any instance that is listening to an event, if not the event will try to notify a non existent instance and the application will crash.</p>\n<p>The syntax is just the same as that of ofAddListener.</p>\n<!----------------------------------------------------------------------------->\n<p>###void ofRemoveListener(&amp;event, *listener, listenerMethod, prio)</p>\n<!--\n_syntax: ofRemoveListener(&event, *listener, listenerMethod, prio)_\n_name: ofRemoveListener_\n_returns: void_\n_returns_description: _\n_parameters: EventType &event, ListenerClass *listener, void (ListenerClass::*)(ArgumentsType &) listenerMethod, int prio_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Removes a listener method from an event. Use it whenever you want a class to stop being notified about an event after having registered it to the method with ofAddListener.</p>\n<p>Don't forget to call this before deleting any instance that is listening to an event, if not the event will try to notify a non existent instance and the application will crash.</p>\n<p>The syntax is just the same as that of ofAddListener.</p>\n<!----------------------------------------------------------------------------->\n<p>###void ofRemoveListener(&amp;event, listenerFunction, prio)</p>\n<!--\n_syntax: ofRemoveListener(&event, listenerFunction, prio)_\n_name: ofRemoveListener_\n_returns: void_\n_returns_description: _\n_parameters: EventType &event, void (*)(ArgumentsType &) listenerFunction, int prio_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###void ofRemoveListener(&amp;event, listenerFunction, prio)</p>\n<!--\n_syntax: ofRemoveListener(&event, listenerFunction, prio)_\n_name: ofRemoveListener_\n_returns: void_\n_returns_description: _\n_parameters: ofEvent< void > &event, void (*)(const void *) listenerFunction, int prio_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###void ofRemoveListener(&amp;event, listenerFunction, prio)</p>\n<!--\n_syntax: ofRemoveListener(&event, listenerFunction, prio)_\n_name: ofRemoveListener_\n_returns: void_\n_returns_description: _\n_parameters: ofEvent< void > &event, void (*)() listenerFunction, int prio_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###void ofRemoveListener(&amp;event, listenerFunction, prio)</p>\n<!--\n_syntax: ofRemoveListener(&event, listenerFunction, prio)_\n_name: ofRemoveListener_\n_returns: void_\n_returns_description: _\n_parameters: EventType &event, bool (*)(ArgumentsType &) listenerFunction, int prio_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###void ofRemoveListener(&amp;event, listenerFunction, prio)</p>\n<!--\n_syntax: ofRemoveListener(&event, listenerFunction, prio)_\n_name: ofRemoveListener_\n_returns: void_\n_returns_description: _\n_parameters: ofEvent< void > &event, bool (*)(const void *) listenerFunction, int prio_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###void ofRemoveListener(&amp;event, listenerFunction, prio)</p>\n<!--\n_syntax: ofRemoveListener(&event, listenerFunction, prio)_\n_name: ofRemoveListener_\n_returns: void_\n_returns_description: _\n_parameters: ofEvent< void > &event, bool (*)() listenerFunction, int prio_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n","raw":"#functions\n\n\n<!--\n_visible: True_\n_advanced: False_\n-->\n\n##Description\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void ofAddListener(&event, *, listenerFunction, prio)\n\n<!--\n_syntax: ofAddListener(&event, *, listenerFunction, prio)_\n_name: ofAddListener_\n_returns: void_\n_returns_description: _\n_parameters: EventType &event, void (*)(const void *, ArgumentsType &) listenerFunction, int prio_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void ofAddListener(&event, *, listenerFunction, prio)\n\n<!--\n_syntax: ofAddListener(&event, *, listenerFunction, prio)_\n_name: ofAddListener_\n_returns: void_\n_returns_description: _\n_parameters: EventType &event, bool (*)(const void *, ArgumentsType &) listenerFunction, int prio_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void ofAddListener(&event, *listener, *, listenerMethod, prio)\n\n<!--\n_syntax: ofAddListener(&event, *listener, *, listenerMethod, prio)_\n_name: ofAddListener_\n_returns: void_\n_returns_description: _\n_parameters: EventType &event, ListenerClass *listener, bool (ListenerClass::*)(const void *, ArgumentsType &) listenerMethod, int prio_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nAllows you to add a listener method to an event, use it whenever you want a class to be notified about an event.\n\nThis is a templated function so the types of the parameters are not predefined types but can be any type as long as the method is one of the listener class' and it has a particular signature.\n\nThe signature of the listener method depends on the event type. Every event is defined as:\n\n~~~~{.cpp}\nofEvent<type> event;\n~~~~\n\nwhere type is the type of the parameter that is going to be passed when the event is notified. The listener method can have one of this two signatures:\n\n~~~~{.cpp}\nvoid listenerMethod(type & parameter);\n~~~~\n\n~~~~{.cpp}\nvoid listenerMethod(const void * sender, type parameter);\n~~~~\n\nWhere type must be the same as that of the event it listens to, and sender will be a pointer to the notifying class.\n\nFor instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:\n\n~~~~{.cpp}\n\nclass SimpleEventNotifier {\n\tofEvent<float> notify;\t// will send an event with a float\n\n\tvoid sendEvent() {\n\t\tofNotifyEvent(notify, ofGetElapsedTimef(), this); \n\t}\n\n};\n\n~~~~\n\nWe can listen for that in our ofApp:\n\n~~~~{.cpp}\nSimpleEventNotifier notifier;\nvoid ofApp::setup() {\n\tofAddListener(notifier.notify, this, &ofApp::haveBeenNotified);\n}\n\nvoid ofApp::haveBeenNotified(float &f){\n    ofLog() << \" event at \" << f << endl;\n}\n\n~~~~\n\nThe general pattern is:\n\nA notifying class that will notify defines an ofEvent.\nA listening class that will listen for that ofEvent calls ofAddListener() using the name of the event, the \"this\" keyword to refer to itself, and a pointer to the method that you want called when the event occurs\nThe notifying class calls ofNotifyEvent() when it's time to send the event.\nThe listening class has its notification method called with the parameters of the ofEvent passed to it.\n\nThis version of the method allows you to use the prio to set whether the event should be called before the application events (mouse and key events, for example) with OF_EVENT_ORDER_BEFORE_APP or after with OF_EVENT_ORDER_AFTER_APP.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void ofAddListener(&event, *listener, *, listenerMethod, prio)\n\n<!--\n_syntax: ofAddListener(&event, *listener, *, listenerMethod, prio)_\n_name: ofAddListener_\n_returns: void_\n_returns_description: _\n_parameters: EventType &event, ListenerClass *listener, void (ListenerClass::*)(const void *, ArgumentsType &) listenerMethod, int prio_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nregister any method of any class to an event.\n\nthe method must provide one of the following\nsignatures:\n    void method(ArgumentsType & args)\n    void method(const void * sender, ArgumentsType &args)\nie:\n    ofAddListener(addon.newIntEvent, this, &Class::method)\n\n\n\n\n\n_description: _\n\nAllows you to add a listener method to an event, use it whenever you want a class to be notified about an event.\n\nThis is a templated function so the types of the parameters are not predefined types but can be any type as long as the method is one of the listener class' and it has a particular signature.\n\nThe signature of the listener method depends on the event type. Every event is defined as:\n\n~~~~{.cpp}\nofEvent<type> event;\n~~~~\n\nwhere type is the type of the parameter that is going to be passed when the event is notified. The listener method can have one of this two signatures:\n\n~~~~{.cpp}\nvoid listenerMethod(type & parameter);\n~~~~\n\n~~~~{.cpp}\nvoid listenerMethod(const void * sender, type parameter);\n~~~~\n\nWhere type must be the same as that of the event it listens to, and sender will be a pointer to the notifying class.\n\nFor instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:\n\n~~~~{.cpp}\n\nclass SimpleEventNotifier {\n\tofEvent<float> notify;\t// will send an event with a float\n\n\tvoid sendEvent() {\n\t\tofNotifyEvent(notify, ofGetElapsedTimef(), this); \n\t}\n\n};\n\n~~~~\n\nWe can listen for that in our ofApp:\n\n~~~~{.cpp}\nSimpleEventNotifier notifier;\nvoid ofApp::setup() {\n\tofAddListener(notifier.notify, this, &ofApp::haveBeenNotified);\n}\n\nvoid ofApp::haveBeenNotified(float &f){\n    ofLog() << \" event at \" << f << endl;\n}\n\n~~~~\n\nThe general pattern is:\n\nA notifying class that will notify defines an ofEvent.\nA listening class that will listen for that ofEvent calls ofAddListener() using the name of the event, the \"this\" keyword to refer to itself, and a pointer to the method that you want called when the event occurs\nThe notifying class calls ofNotifyEvent() when it's time to send the event.\nThe listening class has its notification method called with the parameters of the ofEvent passed to it.\n\nThis version of the method allows you to use the prio to set whether the event should be called before the application events (mouse and key events, for example) with OF_EVENT_ORDER_BEFORE_APP or after with OF_EVENT_ORDER_AFTER_APP.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void ofAddListener(&event, *listener, listenerMethod, prio)\n\n<!--\n_syntax: ofAddListener(&event, *listener, listenerMethod, prio)_\n_name: ofAddListener_\n_returns: void_\n_returns_description: _\n_parameters: ofEvent< void > &event, ListenerClass *listener, bool (ListenerClass::*)() listenerMethod, int prio_\n_version_started: 0.06_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nAllows you to add a listener method to an event, use it whenever you want a class to be notified about an event.\n\nThis is a templated function so the types of the parameters are not predefined types but can be any type as long as the method is one of the listener class' and it has a particular signature.\n\nThe signature of the listener method depends on the event type. Every event is defined as:\n\n~~~~{.cpp}\nofEvent<type> event;\n~~~~\n\nwhere type is the type of the parameter that is going to be passed when the event is notified. The listener method can have one of this two signatures:\n\n~~~~{.cpp}\nvoid listenerMethod(type & parameter);\n~~~~\n\n~~~~{.cpp}\nvoid listenerMethod(const void * sender, type parameter);\n~~~~\n\nWhere type must be the same as that of the event it listens to, and sender will be a pointer to the notifying class.\n\nFor instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:\n\n~~~~{.cpp}\n\nclass SimpleEventNotifier {\n\tofEvent<float> notify;\t// will send an event with a float\n\n\tvoid sendEvent() {\n\t\tofNotifyEvent(notify, ofGetElapsedTimef(), this); \n\t}\n\n};\n\n~~~~\n\nWe can listen for that in our ofApp:\n\n~~~~{.cpp}\nSimpleEventNotifier notifier;\nvoid ofApp::setup() {\n\tofAddListener(notifier.notify, this, &ofApp::haveBeenNotified);\n}\n\nvoid ofApp::haveBeenNotified(float &f){\n    ofLog() << \" event at \" << f << endl;\n}\n\n~~~~\n\nThe general pattern is:\n\nA notifying class that will notify defines an ofEvent.\nA listening class that will listen for that ofEvent calls ofAddListener() using the name of the event, the \"this\" keyword to refer to itself, and a pointer to the method that you want called when the event occurs\nThe notifying class calls ofNotifyEvent() when it's time to send the event.\nThe listening class has its notification method called with the parameters of the ofEvent passed to it.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void ofAddListener(&event, *listener, listenerMethod, prio)\n\n<!--\n_syntax: ofAddListener(&event, *listener, listenerMethod, prio)_\n_name: ofAddListener_\n_returns: void_\n_returns_description: _\n_parameters: ofEvent< void > &event, ListenerClass *listener, bool (ListenerClass::*)(const void *) listenerMethod, int prio_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nAllows you to add a listener method to an event, use it whenever you want a class to be notified about an event.\n\nThis is a templated function so the types of the parameters are not predefined types but can be any type as long as the method is one of the listener class' and it has a particular signature.\n\nThe signature of the listener method depends on the event type. Every event is defined as:\n\n~~~~{.cpp}\nofEvent<type> event;\n~~~~\n\nwhere type is the type of the parameter that is going to be passed when the event is notified. The listener method can have one of this two signatures:\n\n~~~~{.cpp}\nvoid listenerMethod(type & parameter);\n~~~~\n\n~~~~{.cpp}\nvoid listenerMethod(const void * sender, type parameter);\n~~~~\n\nWhere type must be the same as that of the event it listens to, and sender will be a pointer to the notifying class.\n\nFor instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:\n\n~~~~{.cpp}\n\nclass SimpleEventNotifier {\n\tofEvent<float> notify;\t// will send an event with a float\n\n\tvoid sendEvent() {\n\t\tofNotifyEvent(notify, ofGetElapsedTimef(), this); \n\t}\n\n};\n\n~~~~\n\nWe can listen for that in our ofApp:\n\n~~~~{.cpp}\nSimpleEventNotifier notifier;\nvoid ofApp::setup() {\n\tofAddListener(notifier.notify, this, &ofApp::haveBeenNotified);\n}\n\nvoid ofApp::haveBeenNotified(float &f){\n    ofLog() << \" event at \" << f << endl;\n}\n\n~~~~\n\nThe general pattern is:\n\nA notifying class that will notify defines an ofEvent.\nA listening class that will listen for that ofEvent calls ofAddListener() using the name of the event, the \"this\" keyword to refer to itself, and a pointer to the method that you want called when the event occurs\nThe notifying class calls ofNotifyEvent() when it's time to send the event.\nThe listening class has its notification method called with the parameters of the ofEvent passed to it.\n\nNote that the event is a reference, which means it needs to a member of your class that will not go away in the lifetime of the object.\n\nThis version of the method allows you to use the prio to set whether the event should be called before the application events (mouse and key events, for example) with OF_EVENT_ORDER_BEFORE_APP or after with OF_EVENT_ORDER_AFTER_APP.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void ofAddListener(&event, *listener, listenerMethod, prio)\n\n<!--\n_syntax: ofAddListener(&event, *listener, listenerMethod, prio)_\n_name: ofAddListener_\n_returns: void_\n_returns_description: _\n_parameters: EventType &event, ListenerClass *listener, bool (ListenerClass::*)(ArgumentsType &) listenerMethod, int prio_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nAllows you to add a listener method to an event, use it whenever you want a class to be notified about an event.\n\nThis is a templated function so the types of the parameters are not predefined types but can be any type as long as the method is one of the listener class' and it has a particular signature.\n\nThe signature of the listener method depends on the event type. Every event is defined as:\n\n~~~~{.cpp}\nofEvent<type> event;\n~~~~\n\nwhere type is the type of the parameter that is going to be passed when the event is notified. The listener method can have one of this two signatures:\n\n~~~~{.cpp}\nvoid listenerMethod(type & parameter);\n~~~~\n\n~~~~{.cpp}\nvoid listenerMethod(const void * sender, type parameter);\n~~~~\n\nWhere type must be the same as that of the event it listens to, and sender will be a pointer to the notifying class.\n\nFor instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:\n\n~~~~{.cpp}\n\nclass SimpleEventNotifier {\n\tofEvent<float> notify;\t// will send an event with a float\n\n\tvoid sendEvent() {\n\t\tofNotifyEvent(notify, ofGetElapsedTimef(), this); \n\t}\n\n};\n\n~~~~\n\nWe can listen for that in our ofApp:\n\n~~~~{.cpp}\nSimpleEventNotifier notifier;\nvoid ofApp::setup() {\n\tofAddListener(notifier.notify, this, &ofApp::haveBeenNotified);\n}\n\nvoid ofApp::haveBeenNotified(float &f){\n    ofLog() << \" event at \" << f << endl;\n}\n\n~~~~\n\nThe general pattern is:\n\nA notifying class that will notify defines an ofEvent.\nA listening class that will listen for that ofEvent calls ofAddListener() using the name of the event, the \"this\" keyword to refer to itself, and a pointer to the method that you want called when the event occurs\nThe notifying class calls ofNotifyEvent() when it's time to send the event.\nThe listening class has its notification method called with the parameters of the ofEvent passed to it.\n\nThis version of the method allows you to use the prio to set whether the event should be called before the application events (mouse and key events, for example) with OF_EVENT_ORDER_BEFORE_APP or after with OF_EVENT_ORDER_AFTER_APP.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void ofAddListener(&event, *listener, listenerMethod, prio)\n\n<!--\n_syntax: ofAddListener(&event, *listener, listenerMethod, prio)_\n_name: ofAddListener_\n_returns: void_\n_returns_description: _\n_parameters: ofEvent< void > &event, ListenerClass *listener, void (ListenerClass::*)() listenerMethod, int prio_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nAllows you to add a listener method to an event, use it whenever you want a class to be notified about an event.\n\nThis is a templated function so the types of the parameters are not predefined types but can be any type as long as the method is one of the listener class' and it has a particular signature.\n\nThe signature of the listener method depends on the event type. Every event is defined as:\n\n~~~~{.cpp}\nofEvent<type> event;\n~~~~\n\nwhere type is the type of the parameter that is going to be passed when the event is notified. The listener method can have one of this two signatures:\n\n~~~~{.cpp}\nvoid listenerMethod(type & parameter);\n~~~~\n\n~~~~{.cpp}\nvoid listenerMethod(const void * sender, type parameter);\n~~~~\n\nWhere type must be the same as that of the event it listens to, and sender will be a pointer to the notifying class.\n\nFor instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:\n\n~~~~{.cpp}\n\nclass SimpleEventNotifier {\n\tofEvent<float> notify;\t// will send an event with a float\n\n\tvoid sendEvent() {\n\t\tofNotifyEvent(notify, ofGetElapsedTimef(), this); \n\t}\n\n};\n\n~~~~\n\nWe can listen for that in our ofApp:\n\n~~~~{.cpp}\nSimpleEventNotifier notifier;\nvoid ofApp::setup() {\n\tofAddListener(notifier.notify, this, &ofApp::haveBeenNotified);\n}\n\nvoid ofApp::haveBeenNotified(float &f){\n    ofLog() << \" event at \" << f << endl;\n}\n\n~~~~\n\nThe general pattern is:\n\nA notifying class that will notify defines an ofEvent.\nA listening class that will listen for that ofEvent calls ofAddListener() using the name of the event, the \"this\" keyword to refer to itself, and a pointer to the method that you want called when the event occurs\nThe notifying class calls ofNotifyEvent() when it's time to send the event.\nThe listening class has its notification method called with the parameters of the ofEvent passed to it.\n\nThis version of the method allows you to use the prio to set whether the event should be called before the application events (mouse and key events, for example) with OF_EVENT_ORDER_BEFORE_APP or after with OF_EVENT_ORDER_AFTER_APP.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void ofAddListener(&event, *listener, listenerMethod, prio)\n\n<!--\n_syntax: ofAddListener(&event, *listener, listenerMethod, prio)_\n_name: ofAddListener_\n_returns: void_\n_returns_description: _\n_parameters: ofEvent< void > &event, ListenerClass *listener, void (ListenerClass::*)(const void *) listenerMethod, int prio_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nAllows you to add a listener method to an event, use it whenever you want a class to be notified about an event.\n\nThis is a templated function so the types of the parameters are not predefined types but can be any type as long as the method is one of the listener class' and it has a particular signature.\n\nThe signature of the listener method depends on the event type. Every event is defined as:\n\n~~~~{.cpp}\nofEvent<type> event;\n~~~~\n\nwhere type is the type of the parameter that is going to be passed when the event is notified. The listener method can have one of this two signatures:\n\n~~~~{.cpp}\nvoid listenerMethod(type & parameter);\n~~~~\n\n~~~~{.cpp}\nvoid listenerMethod(const void * sender, type parameter);\n~~~~\n\nWhere type must be the same as that of the event it listens to, and sender will be a pointer to the notifying class.\n\nFor instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:\n\n~~~~{.cpp}\n\nclass SimpleEventNotifier {\n\tofEvent<float> notify;\t// will send an event with a float\n\n\tvoid sendEvent() {\n\t\tofNotifyEvent(notify, ofGetElapsedTimef(), this); \n\t}\n\n};\n\n~~~~\n\nWe can listen for that in our ofApp:\n\n~~~~{.cpp}\nSimpleEventNotifier notifier;\nvoid ofApp::setup() {\n\tofAddListener(notifier.notify, this, &ofApp::haveBeenNotified);\n}\n\nvoid ofApp::haveBeenNotified(float &f){\n    ofLog() << \" event at \" << f << endl;\n}\n\n~~~~\n\nThe general pattern is:\n\nA notifying class that will notify defines an ofEvent.\nA listening class that will listen for that ofEvent calls ofAddListener() using the name of the event, the \"this\" keyword to refer to itself, and a pointer to the method that you want called when the event occurs\nThe notifying class calls ofNotifyEvent() when it's time to send the event.\nThe listening class has its notification method called with the parameters of the ofEvent passed to it.\n\nThis version of the method allows you to use the prio to set whether the event should be called before the application events (mouse and key events, for example) with OF_EVENT_ORDER_BEFORE_APP or after with OF_EVENT_ORDER_AFTER_APP.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void ofAddListener(&event, *listener, listenerMethod, prio)\n\n<!--\n_syntax: ofAddListener(&event, *listener, listenerMethod, prio)_\n_name: ofAddListener_\n_returns: void_\n_returns_description: _\n_parameters: EventType &event, ListenerClass *listener, void (ListenerClass::*)(ArgumentsType &) listenerMethod, int prio_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nAllows you to add a listener method to an event, use it whenever you want a class to be notified about an event.\n\nThis is a templated function so the types of the parameters are not predefined types but can be any type as long as the method is one of the listener class' and it has a particular signature.\n\nThe signature of the listener method depends on the event type. Every event is defined as:\n\n~~~~{.cpp}\nofEvent<type> event;\n~~~~\n\nwhere type is the type of the parameter that is going to be passed when the event is notified. The listener method can have one of this two signatures:\n\n~~~~{.cpp}\nvoid listenerMethod(type & parameter);\n~~~~\n\n~~~~{.cpp}\nvoid listenerMethod(const void * sender, type parameter);\n~~~~\n\nWhere type must be the same as that of the event it listens to, and sender will be a pointer to the notifying class.\n\nFor instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:\n\n~~~~{.cpp}\n\nclass SimpleEventNotifier {\n\tofEvent<float> notify;\t// will send an event with a float\n\n\tvoid sendEvent() {\n\t\tofNotifyEvent(notify, ofGetElapsedTimef(), this); \n\t}\n\n};\n\n~~~~\n\nWe can listen for that in our ofApp:\n\n~~~~{.cpp}\nSimpleEventNotifier notifier;\nvoid ofApp::setup() {\n\tofAddListener(notifier.notify, this, &ofApp::haveBeenNotified);\n}\n\nvoid ofApp::haveBeenNotified(float &f){\n    ofLog() << \" event at \" << f << endl;\n}\n\n~~~~\n\nThe general pattern is:\n\nA notifying class that will notify defines an ofEvent.\nA listening class that will listen for that ofEvent calls ofAddListener() using the name of the event, the \"this\" keyword to refer to itself, and a pointer to the method that you want called when the event occurs\nThe notifying class calls ofNotifyEvent() when it's time to send the event.\nThe listening class has its notification method called with the parameters of the ofEvent passed to it.\n\nThis version of the method allows you to use the prio to set whether the event should be called before the application events (mouse and key events, for example) with OF_EVENT_ORDER_BEFORE_APP or after with OF_EVENT_ORDER_AFTER_APP.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void ofAddListener(&event, listenerFunction, prio)\n\n<!--\n_syntax: ofAddListener(&event, listenerFunction, prio)_\n_name: ofAddListener_\n_returns: void_\n_returns_description: _\n_parameters: EventType &event, void (*)(ArgumentsType &) listenerFunction, int prio_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void ofAddListener(&event, listenerFunction, prio)\n\n<!--\n_syntax: ofAddListener(&event, listenerFunction, prio)_\n_name: ofAddListener_\n_returns: void_\n_returns_description: _\n_parameters: ofEvent< void > &event, void (*)(const void *) listenerFunction, int prio_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void ofAddListener(&event, listenerFunction, prio)\n\n<!--\n_syntax: ofAddListener(&event, listenerFunction, prio)_\n_name: ofAddListener_\n_returns: void_\n_returns_description: _\n_parameters: ofEvent< void > &event, void (*)() listenerFunction, int prio_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void ofAddListener(&event, listenerFunction, prio)\n\n<!--\n_syntax: ofAddListener(&event, listenerFunction, prio)_\n_name: ofAddListener_\n_returns: void_\n_returns_description: _\n_parameters: EventType &event, bool (*)(ArgumentsType &) listenerFunction, int prio_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void ofAddListener(&event, listenerFunction, prio)\n\n<!--\n_syntax: ofAddListener(&event, listenerFunction, prio)_\n_name: ofAddListener_\n_returns: void_\n_returns_description: _\n_parameters: ofEvent< void > &event, bool (*)(const void *) listenerFunction, int prio_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void ofAddListener(&event, listenerFunction, prio)\n\n<!--\n_syntax: ofAddListener(&event, listenerFunction, prio)_\n_name: ofAddListener_\n_returns: void_\n_returns_description: _\n_parameters: ofEvent< void > &event, bool (*)() listenerFunction, int prio_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool ofNotifyEvent(&event)\n\n<!--\n_syntax: ofNotifyEvent(&event)_\n_name: ofNotifyEvent_\n_returns: bool_\n_returns_description: _\n_parameters: ofEvent< void > &event_\n_version_started: 0.06_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nNotifies an event, what makes all it's registered method listeners to be called with the same argument.\n\nThis is a templated function so the type of the parameters is not predefined and can be anything as long as the listener methods use the same type for the parameter.\n\nThe arguments are passed to the listeners by reference so they can modify them. \n\nThe listener methods are called in the same order they were registered using ofAddListener.\n\nFor instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:\n\n~~~~{.cpp}\n\nclass SimpleEventNotifier {\n\tofEvent<float> notify;\t// will send an event with a float\n\n\tvoid sendEvent() {\n\t\tofNotifyEvent(notify, ofGetElapsedTimef(), this); \n\t}\n\n};\n\n~~~~\n\nWe can listen for that in our ofApp:\n\n~~~~{.cpp}\nSimpleEventNotifier notifier;\nvoid ofApp::setup() {\n\tofAddListener(notifier.notify, this, &ofApp::haveBeenNotified);\n}\n\nvoid ofApp::haveBeenNotified(float &f){\n    ofLog() << \" event at \" << f << endl;\n}\n\n~~~~\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool ofNotifyEvent(&event, &args)\n\n<!--\n_syntax: ofNotifyEvent(&event, &args)_\n_name: ofNotifyEvent_\n_returns: bool_\n_returns_description: _\n_parameters: EventType &event, const ArgumentsType &args_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nNotifies an event, what makes all it's registered method listeners to be called with the same argument.\n\nThis is a templated function so the type of the parameters is not predefined and can be anything as long as the listener methods use the same type for the parameter.\n\nThe arguments are passed to the listeners by reference so they can modify them.\n\nThe listener methods are called in the same order they were registered using ofAddListener.\n\nWith this version the listeners also receive a pointer to the notifying class in case the listener method specifies that parameter.\n\nFor instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:\n\n~~~~{.cpp}\n\nclass SimpleEventNotifier {\n\tofEvent<float> notify;\t// will send an event with a float\n\n\tvoid sendEvent() {\n\t\tofNotifyEvent(notify, ofGetElapsedTimef(), this); \n\t}\n\n};\n\n~~~~\n\nWe can listen for that in our ofApp:\n\n~~~~{.cpp}\nSimpleEventNotifier notifier;\nvoid ofApp::setup() {\n\tofAddListener(notifier.notify, this, &ofApp::haveBeenNotified);\n}\n\nvoid ofApp::haveBeenNotified(float &f){\n    ofLog() << \" event at \" << f << endl;\n}\n\n~~~~\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool ofNotifyEvent(&event, &args)\n\n<!--\n_syntax: ofNotifyEvent(&event, &args)_\n_name: ofNotifyEvent_\n_returns: bool_\n_returns_description: _\n_parameters: EventType &event, ArgumentsType &args_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nNotifies an event, what makes all it's registered method listeners to be called with the same argument.\n\nThis is a templated function so the type of the parameters is not predefined and can be anything as long as the listener methods use the same type for the parameter.\n\nThe arguments are passed to the listeners by reference so they can modify them.\n\nThe listener methods are called in the same order they were registered using ofAddListener.\n\nWith this version the listeners also receive a pointer to the notifying class in case the listener method specifies that parameter.\n\nFor instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:\n\n~~~~{.cpp}\n\nclass SimpleEventNotifier {\n\tofEvent<float> notify;\t// will send an event with a float\n\n\tvoid sendEvent() {\n\t\tofNotifyEvent(notify, ofGetElapsedTimef(), this); \n\t}\n\n};\n\n~~~~\n\nWe can listen for that in our ofApp:\n\n~~~~{.cpp}\nSimpleEventNotifier notifier;\nvoid ofApp::setup() {\n\tofAddListener(notifier.notify, this, &ofApp::haveBeenNotified);\n}\n\nvoid ofApp::haveBeenNotified(float &f){\n    ofLog() << \" event at \" << f << endl;\n}\n\n~~~~\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool ofNotifyEvent(&event, &args, *sender)\n\n<!--\n_syntax: ofNotifyEvent(&event, &args, *sender)_\n_name: ofNotifyEvent_\n_returns: bool_\n_returns_description: _\n_parameters: EventType &event, const ArgumentsType &args, SenderType *sender_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nNotifies an event, what makes all it's registered method listeners to be called with the same argument.\n\nThis is a templated function so the type of the parameters is not predefined and can be anything as long as the listener methods use the same type for the parameter.\n\nThe arguments are passed to the listeners by reference so they can modify them.\n\nThe listener methods are called in the same order they were registered using ofAddListener.\n\nWith this version the listeners also receive an event args object that can be used to send additional data to the listening class.\n\nFor instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:\n\n~~~~{.cpp}\n\nclass SimpleEventNotifier {\n\tofEvent<float> notify;\t// will send an event with a float\n\n\tvoid sendEvent() {\n\t\tofNotifyEvent(notify, ofGetElapsedTimef()); \n\t}\n\n};\n\n~~~~\n\nWe can listen for that in our ofApp:\n\n~~~~{.cpp}\nSimpleEventNotifier notifier;\nvoid ofApp::setup() {\n\tofAddListener(notifier.notify, this, &ofApp::haveBeenNotified);\n}\n\nvoid ofApp::haveBeenNotified(float &f){\n    ofLog() << \" event at \" << f << endl;\n}\n\n~~~~\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool ofNotifyEvent(&event, &args, *sender)\n\n<!--\n_syntax: ofNotifyEvent(&event, &args, *sender)_\n_name: ofNotifyEvent_\n_returns: bool_\n_returns_description: _\n_parameters: EventType &event, ArgumentsType &args, SenderType *sender_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nnotifies an event so all the registered listeners\nget called\n\nie:\n\tofNotifyEvent(addon.newIntEvent, intArgument, this)\n\nor in case there's no sender:\n\tofNotifyEvent(addon.newIntEvent, intArgument)\n\n@returns: true in case any listener attended the event\n\n\n\n\n\n_description: _\n\nNotifies an event, what makes all it's registered method listeners to be called with the same argument.\n\nThis is a templated function so the type of the parameters is not predefined and can be anything as long as the listener methods use the same type for the parameter.\n\nThe arguments are passed to the listeners by reference so they can modify them.\n\nThe listener methods are called in the same order they were registered using ofAddListener.\n\nFor instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:\n\n~~~~{.cpp}\n\nclass SimpleEventNotifier {\n\tofEvent notify;\t// will send an event with no data\n\n\tvoid sendEvent() {\n\t\tofNotifyEvent(notify); \n\t}\n\n};\n\n~~~~\n\nWe can listen for that in our ofApp:\n\n~~~~{.cpp}\nSimpleEventNotifier notifier;\nvoid ofApp::setup() {\n\tofAddListener(notifier.notify, this, &ofApp::haveBeenNotified);\n}\n\nvoid ofApp::haveBeenNotified(){\n    ofLog() << \" event at \" << ofGetElapsedTimef() << endl;\n}\n\n~~~~\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool ofNotifyEvent(&event, *sender)\n\n<!--\n_syntax: ofNotifyEvent(&event, *sender)_\n_name: ofNotifyEvent_\n_returns: bool_\n_returns_description: _\n_parameters: ofEvent< void > &event, SenderType *sender_\n_version_started: 0.06_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nNotifies an event, what makes all it's registered method listeners to be called with the same argument.\n\nThis is a templated function so the type of the parameters is not predefined and can be anything as long as the listener methods use the same type for the parameter.\n\nThe arguments are passed to the listeners by reference so they can modify them.\n\nThe listener methods are called in the same order they were registered using ofAddListener.\n\nWith this version the listeners also receive a pointer to the notifying class in case the listener method specifies that parameter.\n\nFor instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:\n\n~~~~{.cpp}\n\nclass SimpleEventNotifier {\n\tofEvent<float> notify;\t// will send an event with a float\n\n\tvoid sendEvent() {\n\t\tofNotifyEvent(notify, ofGetElapsedTimef(), this); \n\t}\n\n};\n\n~~~~\n\nWe can listen for that in our ofApp:\n\n~~~~{.cpp}\nSimpleEventNotifier notifier;\nvoid ofApp::setup() {\n\tofAddListener(notifier.notify, this, &ofApp::haveBeenNotified);\n}\n\nvoid ofApp::haveBeenNotified(float &f){\n    ofLog() << \" event at \" << f << endl;\n}\n\n~~~~\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void ofRemoveListener(&event, *, listenerFunction, prio)\n\n<!--\n_syntax: ofRemoveListener(&event, *, listenerFunction, prio)_\n_name: ofRemoveListener_\n_returns: void_\n_returns_description: _\n_parameters: EventType &event, void (*)(const void *, ArgumentsType &) listenerFunction, int prio_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void ofRemoveListener(&event, *, listenerFunction, prio)\n\n<!--\n_syntax: ofRemoveListener(&event, *, listenerFunction, prio)_\n_name: ofRemoveListener_\n_returns: void_\n_returns_description: _\n_parameters: EventType &event, bool (*)(const void *, ArgumentsType &) listenerFunction, int prio_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void ofRemoveListener(&event, *listener, *, listenerMethod, prio)\n\n<!--\n_syntax: ofRemoveListener(&event, *listener, *, listenerMethod, prio)_\n_name: ofRemoveListener_\n_returns: void_\n_returns_description: _\n_parameters: EventType &event, ListenerClass *listener, bool (ListenerClass::*)(const void *, ArgumentsType &) listenerMethod, int prio_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nRemoves a listener method from an event. Use it whenever you want a class to stop being notified about an event after having registered it to the method with ofAddListener.\n\nDon't forget to call this before deleting any instance that is listening to an event, if not the event will try to notify a non existent instance and the application will crash.\n\nThe syntax is just the same as that of ofAddListener.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void ofRemoveListener(&event, *listener, *, listenerMethod, prio)\n\n<!--\n_syntax: ofRemoveListener(&event, *listener, *, listenerMethod, prio)_\n_name: ofRemoveListener_\n_returns: void_\n_returns_description: _\n_parameters: EventType &event, ListenerClass *listener, void (ListenerClass::*)(const void *, ArgumentsType &) listenerMethod, int prio_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nunregister any method of any class to an event.\n\nthe method must provide one the following\nsignatures:\n    void method(ArgumentsType & args)\n    void method(const void * sender, ArgumentsType &args)\nie:\n    ofAddListener(addon.newIntEvent, this, &Class::method)\n\n\n\n\n\n_description: _\n\nRemoves a listener method from an event. Use it whenever you want a class to stop being notified about an event after having registered it to the method with ofAddListener.\n\nDon't forget to call this before deleting any instance that is listening to an event, if not the event will try to notify a non existent instance and the application will crash.\n\nThe syntax is just the same as that of ofAddListener.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void ofRemoveListener(&event, *listener, listenerMethod, prio)\n\n<!--\n_syntax: ofRemoveListener(&event, *listener, listenerMethod, prio)_\n_name: ofRemoveListener_\n_returns: void_\n_returns_description: _\n_parameters: ofEvent< void > &event, ListenerClass *listener, bool (ListenerClass::*)() listenerMethod, int prio_\n_version_started: 0.06_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nRemoves a listener method from an event. Use it whenever you want a class to stop being notified about an event after having registered it to the method with ofAddListener.\n\nDon't forget to call this before deleting any instance that is listening to an event, if not the event will try to notify a non existent instance and the application will crash.\n\nThe syntax is just the same as that of ofAddListener.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void ofRemoveListener(&event, *listener, listenerMethod, prio)\n\n<!--\n_syntax: ofRemoveListener(&event, *listener, listenerMethod, prio)_\n_name: ofRemoveListener_\n_returns: void_\n_returns_description: _\n_parameters: ofEvent< void > &event, ListenerClass *listener, bool (ListenerClass::*)(const void *) listenerMethod, int prio_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nRemoves a listener method from an event. Use it whenever you want a class to stop being notified about an event after having registered it to the method with ofAddListener.\n\nDon't forget to call this before deleting any instance that is listening to an event, if not the event will try to notify a non existent instance and the application will crash.\n\nThe syntax is just the same as that of ofAddListener.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void ofRemoveListener(&event, *listener, listenerMethod, prio)\n\n<!--\n_syntax: ofRemoveListener(&event, *listener, listenerMethod, prio)_\n_name: ofRemoveListener_\n_returns: void_\n_returns_description: _\n_parameters: EventType &event, ListenerClass *listener, bool (ListenerClass::*)(ArgumentsType &) listenerMethod, int prio_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nRemoves a listener method from an event. Use it whenever you want a class to stop being notified about an event after having registered it to the method with ofAddListener.\n\nDon't forget to call this before deleting any instance that is listening to an event, if not the event will try to notify a non existent instance and the application will crash.\n\nThe syntax is just the same as that of ofAddListener.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void ofRemoveListener(&event, *listener, listenerMethod, prio)\n\n<!--\n_syntax: ofRemoveListener(&event, *listener, listenerMethod, prio)_\n_name: ofRemoveListener_\n_returns: void_\n_returns_description: _\n_parameters: ofEvent< void > &event, ListenerClass *listener, void (ListenerClass::*)() listenerMethod, int prio_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nRemoves a listener method from an event. Use it whenever you want a class to stop being notified about an event after having registered it to the method with ofAddListener.\n\nDon't forget to call this before deleting any instance that is listening to an event, if not the event will try to notify a non existent instance and the application will crash.\n\nThe syntax is just the same as that of ofAddListener.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void ofRemoveListener(&event, *listener, listenerMethod, prio)\n\n<!--\n_syntax: ofRemoveListener(&event, *listener, listenerMethod, prio)_\n_name: ofRemoveListener_\n_returns: void_\n_returns_description: _\n_parameters: ofEvent< void > &event, ListenerClass *listener, void (ListenerClass::*)(const void *) listenerMethod, int prio_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nRemoves a listener method from an event. Use it whenever you want a class to stop being notified about an event after having registered it to the method with ofAddListener.\n\nDon't forget to call this before deleting any instance that is listening to an event, if not the event will try to notify a non existent instance and the application will crash.\n\nThe syntax is just the same as that of ofAddListener.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void ofRemoveListener(&event, *listener, listenerMethod, prio)\n\n<!--\n_syntax: ofRemoveListener(&event, *listener, listenerMethod, prio)_\n_name: ofRemoveListener_\n_returns: void_\n_returns_description: _\n_parameters: EventType &event, ListenerClass *listener, void (ListenerClass::*)(ArgumentsType &) listenerMethod, int prio_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nRemoves a listener method from an event. Use it whenever you want a class to stop being notified about an event after having registered it to the method with ofAddListener.\n\nDon't forget to call this before deleting any instance that is listening to an event, if not the event will try to notify a non existent instance and the application will crash.\n\nThe syntax is just the same as that of ofAddListener.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void ofRemoveListener(&event, listenerFunction, prio)\n\n<!--\n_syntax: ofRemoveListener(&event, listenerFunction, prio)_\n_name: ofRemoveListener_\n_returns: void_\n_returns_description: _\n_parameters: EventType &event, void (*)(ArgumentsType &) listenerFunction, int prio_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void ofRemoveListener(&event, listenerFunction, prio)\n\n<!--\n_syntax: ofRemoveListener(&event, listenerFunction, prio)_\n_name: ofRemoveListener_\n_returns: void_\n_returns_description: _\n_parameters: ofEvent< void > &event, void (*)(const void *) listenerFunction, int prio_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void ofRemoveListener(&event, listenerFunction, prio)\n\n<!--\n_syntax: ofRemoveListener(&event, listenerFunction, prio)_\n_name: ofRemoveListener_\n_returns: void_\n_returns_description: _\n_parameters: ofEvent< void > &event, void (*)() listenerFunction, int prio_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void ofRemoveListener(&event, listenerFunction, prio)\n\n<!--\n_syntax: ofRemoveListener(&event, listenerFunction, prio)_\n_name: ofRemoveListener_\n_returns: void_\n_returns_description: _\n_parameters: EventType &event, bool (*)(ArgumentsType &) listenerFunction, int prio_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void ofRemoveListener(&event, listenerFunction, prio)\n\n<!--\n_syntax: ofRemoveListener(&event, listenerFunction, prio)_\n_name: ofRemoveListener_\n_returns: void_\n_returns_description: _\n_parameters: ofEvent< void > &event, bool (*)(const void *) listenerFunction, int prio_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void ofRemoveListener(&event, listenerFunction, prio)\n\n<!--\n_syntax: ofRemoveListener(&event, listenerFunction, prio)_\n_name: ofRemoveListener_\n_returns: void_\n_returns_description: _\n_parameters: ofEvent< void > &event, bool (*)() listenerFunction, int prio_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n","type":"page","static":true}}],"fetch":[]}