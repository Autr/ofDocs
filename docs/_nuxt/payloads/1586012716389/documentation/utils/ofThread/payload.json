{"data":[{"page":{"entry":{"name":"ofThread","filename":"ofThread.markdown","absolute":"/Users/Gilbert/Code/openFrameworks/ofSite/documentation/utils/ofThread.markdown","path":"/documentation/utils/ofThread","route":"/documentation/utils/ofThread.markdown","dir":"../ofSite/documentation/utils","ext":"markdown","type":"page","id":2473,"parent":2446,"breadcrumbs":[2446,1968],"siblings":[],"translations":{}},"description":{"short":"<p>A threaded base class with a built in mutex for convenience.</p>\n<p>Users can extend this base class by public inheritance like this:</p>\n<pre><code>class MyThreadedClass: public ofThread\n{\n    public:\n    ...\n    void threadedFunction()\n    {\n        while(isThreadRunning())\n        {\n            Threaded function here.\n        }\n    }\n};\n</code></pre>\n<p>ofThread is a convenient wrapper for Poco::Thread, Poco::Runnable and\nPoco::Mutex.  It represents a simplified (sometimes overly simplified -\nor simplified in ways that might not make sense for your project)\npathway for quickly writing threaded classes.  Poco::Runnable represents\na class that can be &quot;run&quot; via its void run() method.  Poco::Thread is\nable to spawn a thread and &quot;run&quot; the contents of a class that extends\nthe Poco::Runnable interface (which ofThread does).  Poco::FastMutex,\n(aka ofMutex) is a &quot;mutual exclusion&quot; object that prevents two threads\nfrom accessing the same data at the same time.  It is important to know\nthat Poco::FastMutex (aka ofMutex) is not &quot;recursive&quot; while Poco::Mutex\nis. This means that if the same thread attempts to lock a thread while\nit ALREADY has a lock on the mutex, the program will lock up and go\nnowhere.  Thus, it is important that ofThread subclasses carefully\ntheir use of the mutex.  Currently ofThread does not lock its own mutex\nat any point (e.g. ofThread's internal variables are not thread safe).\nThis is a somewhat dangerous convenience that is (theoretically)\nsupposed to make it easier for subclasses to avoid the recursive mutex\n&quot;problem&quot;. The situation that arises from two threads simultanously\nreading or writing from the same shared data (shared data\noccupies the same physical location in memory) leads to something\ncalled a &quot;race condition&quot;, which can lead to deadlocks.\nA deadlock is as bad as it sounds.  It means your program\njust stops.  ofMutex prevents race conditions, deadlocks and crashes by\npermitting only one thread access to shared data at a time.  When using\nmutexes to protect data, the trick is to always be sure to unlock the\nmutex when finished.  This problem can often be avoided by using\nan Poco::FastMutex::ScopedLock (aka ofScopedLock).  See the\nthe documentation for more information.  Finally, there are many cases\nwhere it might make more sense to use Poco::Thread, Poco::Runnable and\nPoco::FastMutex directly rather than using ofThread.  Further, cross\nplatform thread management will be alleviated with the std::thread\nsupport library included with C++11.</p>\n<p>Uncaught Exceptions throw from within ofThread will cause the thread to stop\nand the Exception will be delivered to the default ofBaseThreadErrorHandler.\nThe ofBaseThreadErrorHandler will print the exception details, if available.\nThe ofBaseThreadErrorHandler offers no opportunity to take corrective action\nand only allows the user to receive more valuable debugging information\nabout the uncaught exception.  Users should design ofThread subclasses to\ncatch and respond to all anticipated exceptions.</p>\n","full":"<p>ofThread is a thread base class with a built in mutex. A <a href=\"http://en.wikipedia.org/wiki/Thread_(computing)\">thread</a> is essentially a mini processing object you can run in parallel to your main application loop and is useful for running time intensive operations without slowing down your app.</p>\n<p>####Implementing a Thread</p>\n<p>For instance, you have to grab from a camera and waiting for an image slows down your app. You can offload this wait to a thread which tells the main app when an image is ready. To do this, you create a class that inherits from the ofThread class and implement the threadedFunction() function.</p>\n<p>Declaration in a .h file:</p>\n<pre><code class=\"language-{.cpp}\">\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">MyThread</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">public</span> ofThread <span class=\"token punctuation\">{</span>\n\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\n\t<span class=\"token comment\" spellcheck=\"true\">// the thread function</span>\n\t<span class=\"token keyword\">void</span> MyThread<span class=\"token operator\">::</span><span class=\"token function\">threadedFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\n\t\t<span class=\"token comment\" spellcheck=\"true\">// start</span>\n\t\n\t\t<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token function\">isThreadRunning</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\n\t\t\tcam<span class=\"token punctuation\">.</span><span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>cam<span class=\"token punctuation\">.</span><span class=\"token function\">isFrameNew</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\n\t\t\t\t<span class=\"token comment\" spellcheck=\"true\">// load the image</span>\n\t\t\t\timage<span class=\"token punctuation\">.</span><span class=\"token function\">setFromPixels</span><span class=\"token punctuation\">(</span>cam<span class=\"token punctuation\">.</span><span class=\"token function\">getPixels</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token punctuation\">}</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\n\t\t<span class=\"token comment\" spellcheck=\"true\">// done</span>\n\t<span class=\"token punctuation\">}</span>\n\t\n\tofVideoGrabber cam<span class=\"token punctuation\">;</span>\t<span class=\"token comment\" spellcheck=\"true\">// the cam</span>\n\tofImage image<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<p>In the application .h inside the ofApp class declare an object of type MyThread like:</p>\n<pre><code class=\"language-{.cpp}\"><span class=\"token comment\" spellcheck=\"true\">// create object</span>\nMyThread thread<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>then in the .cpp file:</p>\n<pre><code class=\"language-{.cpp}\">\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">setup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n\t<span class=\"token comment\" spellcheck=\"true\">// start the thread</span>\n\tthread<span class=\"token punctuation\">.</span><span class=\"token function\">startThread</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\" spellcheck=\"true\">// blocking</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\n\t<span class=\"token comment\" spellcheck=\"true\">// do something with the thread is running</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n\t<span class=\"token comment\" spellcheck=\"true\">// stop the thread</span>\n\tthread<span class=\"token punctuation\">.</span><span class=\"token function\">stopThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p>####Shared Resources</p>\n<p>With this great power, however, comes great responsibility. If both the thread and your main app loop try to access the image at the same time, bad things happen inside your computer and the app will crash. The image is a considered a &quot;shared resource&quot; and you need to make sure to lock access to it so that only 1 thread can access it a time. You can do this using a <a href=\"http://en.wikipedia.org/wiki/Mutex\">&quot;mutal exclusion&quot; object</a> by called lock() when you want to access the resource, then unlock() when you are done.</p>\n<p>Declaration in a .h file:</p>\n<pre><code class=\"language-{.cpp}\">\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">MyThread</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">public</span> ofThread <span class=\"token punctuation\">{</span>\n\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\n\t<span class=\"token comment\" spellcheck=\"true\">// the thread function</span>\n\t<span class=\"token keyword\">void</span> MyThread<span class=\"token operator\">::</span><span class=\"token function\">threadedFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\n\t\t<span class=\"token comment\" spellcheck=\"true\">// start</span>\n\t\n\t\t<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token function\">isThreadRunning</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\n\t\t\tcam<span class=\"token punctuation\">.</span><span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>cam<span class=\"token punctuation\">.</span><span class=\"token function\">isFrameNew</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\n\t\t\t\t<span class=\"token comment\" spellcheck=\"true\">// lock access to the resource</span>\n\t\t\t\t<span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t\n\t\t\t\t<span class=\"token comment\" spellcheck=\"true\">// load the image</span>\n\t\t\t\timage<span class=\"token punctuation\">.</span><span class=\"token function\">setFromPixels</span><span class=\"token punctuation\">(</span>cam<span class=\"token punctuation\">.</span><span class=\"token function\">getPixels</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t\n\t\t\t\t<span class=\"token comment\" spellcheck=\"true\">// done with the resource</span>\n\t\t\t\t<span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token punctuation\">}</span>\t\n\t\t<span class=\"token punctuation\">}</span>\n\t\n\t\t<span class=\"token comment\" spellcheck=\"true\">// done</span>\n\t<span class=\"token punctuation\">}</span>\n\n\tofVideoGrabber cam<span class=\"token punctuation\">;</span>\t<span class=\"token comment\" spellcheck=\"true\">// the cam</span>\n\tofImage image<span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\" spellcheck=\"true\">// the shared resource</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<p>In the .cpp file:</p>\n<pre><code class=\"language-{.cpp}\">\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">setup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\n\t<span class=\"token comment\" spellcheck=\"true\">// start the thread</span>\n\tthread<span class=\"token punctuation\">.</span><span class=\"token function\">startThread</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\" spellcheck=\"true\">// blocking, non verbose</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\n\t<span class=\"token comment\" spellcheck=\"true\">// lock access to the resource</span>\n\tthread<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\n\t<span class=\"token comment\" spellcheck=\"true\">// copy image</span>\n\tmyImage <span class=\"token operator\">=</span> thread<span class=\"token punctuation\">.</span>image<span class=\"token punctuation\">;</span>\n\t\n\t<span class=\"token comment\" spellcheck=\"true\">// done with the resource</span>\n\tthread<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n\t<span class=\"token comment\" spellcheck=\"true\">// stop the thread</span>\n\tthread<span class=\"token punctuation\">.</span><span class=\"token function\">stopThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p>####Exiting Nicely</p>\n<p>As a thread is running in parallel with your application main loop, it's important to remember to tell it to stop before exiting the app. If you don't, you'll get weird errors or hangs because you aren't being nice to your threads. Depending on how you started your thread (blocking or non-blocking mode), you will either stop it for wait for it to finish. See the stopThread() &amp; waitForThread() functions.</p>\n<p>####Debugging</p>\n<p>Thread errors are <em>notoriously</em> difficult to debug sometimes. You will probably see a &quot;Bad Access&quot; runtime error or something similar if multiple threads are trying to access a shared resource simultaneously. Other times, nothing will happen as the thread may be stuck in an infinite loop and you can't stop it. Wee! We assume if you've read this far, you probably accept the difficulties in order to reap the thread speed rewards.</p>\n<p>A useful tool in debugging thread timing and access is the ofThread verbose mode which prints thread events such as starting, stopping, and mutex locking/unlocking. Simply set verbose=true when calling startThread(). Another trick is to use an ofSleepMillis() inside the thread to slow it down so you can see the timing better while debugging it.</p>\n<p>####HOO RAH</p>\n<p>Ok soldier, lock and load ... good luck!</p>\n<h1></h1>\n"},"config":{"visible":"True","advanced":"False","istemplated":"False","extends":null},"methods":[{"syntax":"getNativeThread()","name":"getNativeThread","returns":"thread &","returns_description":null,"parameters":null,"access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Get a reference to the underlying Poco thread.</p>\n<p>Poco::Thread provides a clean cross-platform wrapper for\nthreads.  On occasion, it may be useful to interact with the\nunderlying Poco::Thread directly.</p>\n<p><strong>Returns</strong>: A reference to the backing Poco thread.</p>\n","desc":"","counter":1},{"syntax":"getNativeThread()","name":"getNativeThread","returns":"const thread &","returns_description":null,"parameters":null,"access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Get a const reference to the underlying Poco thread.</p>\n<p>Poco::Thread provides a clean cross-platform wrapper for\nthreads.  On occasion, it may be useful to interact with the\nunderlying Poco::Thread directly.</p>\n<p><strong>Returns</strong>: A reference to the backing Poco thread.</p>\n","desc":""},{"syntax":"getThreadId()","name":"getThreadId","returns":"thread::id","returns_description":null,"parameters":null,"access":"public","version_started":"0071","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Get the unique thread id.\n\\note This is NOT the the same as the operating thread id!</p>\n","desc":"","counter":0},{"syntax":"getThreadName()","name":"getThreadName","returns":"string","returns_description":null,"parameters":null,"access":"public","version_started":"0.8.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Get the unique thread name, in the form of &quot;Thread id#&quot;</p>\n<p><strong>Returns</strong>: the Thread ID string.</p>\n","desc":"","counter":0},{"syntax":"isCurrentThread()","name":"isCurrentThread","returns":"bool","returns_description":null,"parameters":null,"access":"public","version_started":"0071","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Query whether the current thread is active.</p>\n<p>In multithreaded situations, it can be useful to know which\nthread is currently running some code in order to make sure\nonly certain threads can do certain things.  For example,\nOpenGL can only run in the main execution thread.  Thus,\nsituations where a thread is responsible for interacting\nwith graphics resources may need to prevent graphics updates\nunless the main thread is accessing or updating resources\nshared with this ofThread (or its subclass).</p>\n<pre><code>if(myThread.isCurrentThread())\n{\n    // do some myThread things,\n    // but keep your hands off my resources!\n}\nelse if(ofThread::isMainThread())\n{\n    // pheew! ok, update those graphics resources\n}\n</code></pre>\n<p>By way of another example, a subclass of ofThread may have\nan update() method that is called from ofBaseApp during the\nexecution of the main application thread.  In these cases,\nthe ofThread subclass might want to ask itself whether it\ncan, for instance, call update() on an ofImage, in order to\nsend copy some ofPixels to an ofTexture on the graphics\ncard.</p>\n<p><strong>Returns</strong>: True iff this ofThread the currently active thread.</p>\n","desc":"","counter":0},{"syntax":"isThreadRunning()","name":"isThreadRunning","returns":"bool","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Check the running status of the thread.</p>\n<p><strong>Returns</strong>: true iff the thread is currently running.</p>\n","desc":"<p>Returns true if the thread is currently running. This is especially useful inside the thread's threadedFunction() when you want it to loop continuously until it's told to exit:</p>\n<pre><code class=\"language-{.cpp}\">\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">MyThread</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">public</span> ofThread <span class=\"token punctuation\">{</span>\n\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\n\t<span class=\"token comment\" spellcheck=\"true\">// the thread function</span>\n\t<span class=\"token keyword\">void</span> MyThread<span class=\"token operator\">::</span><span class=\"token function\">threadedFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\n\t\t<span class=\"token comment\" spellcheck=\"true\">// start</span>\n\t\n\t\t<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token function\">isThreadRunning</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\n\t\t\t<span class=\"token comment\" spellcheck=\"true\">// do stuff</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\n\t\t<span class=\"token comment\" spellcheck=\"true\">// done</span>\n\t<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n","counter":0},{"syntax":"lock()","name":"lock","returns":"bool","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Lock the mutex.</p>\n<p>If the thread was started startThread(true), then this call will wait\nuntil the mutex is available and return true.  If the thread was started\nstartThread(false), this call will return true iff the mutex is\nwas successfully acquired.</p>\n<p><strong>Returns</strong>: true if the lock was successfully acquired.</p>\n","desc":"<p>Try to lock the mutex.</p>\n<p>If the thread was started in blocking mode in startThread(), any thread (including your app main loop) will wait until the mutex is unlocked.</p>\n<p>If the thread is non-blocking, this call will immediately return a true or false if the mutex is available. It is up to you to make sure the resource is not being used when accessing it. See the <a href=\"http://en.wikipedia.org/wiki/Non-blocking_algorithm\">Wikipedia article on Non-blocking</a> for reasons as to why using a non-blocking thread might be more advantageous.</p>\n","counter":0},{"syntax":"ofThread()","name":"ofThread","returns":null,"returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"False","advanced":"False","short":"<p>Create an ofThread.</p>\n","desc":"","counter":0},{"syntax":"run()","name":"run","returns":"void","returns_description":null,"parameters":null,"access":"private","version_started":"0071","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"","counter":0},{"syntax":"setThreadName(&name)","name":"setThreadName","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>name","access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"","counter":0},{"syntax":"sleep(milliseconds)","name":"sleep","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">long</span> milliseconds","access":"public","version_started":"0.8.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Tell the thread to sleep for a certain amount of milliseconds.</p>\n<p>This is useful inside the threadedFunction() when a thread is waiting\nfor input to process:</p>\n<pre><code>void MyThreadedClass::threadedFunction()\n{\n\t    // start\n\t    while(isThreadRunning())\n    {\n        // bReadyToProcess can be set from outside the threadedFuntion.\n        // perhaps by another thread that downloads data, or loads\n        // some media, etc.\n\n\t    \tif(bReadyToProcess == true)\n        {\n\t    \t\t// do some time intensive processing\n\t    \t\tbReadyToProcess = false;\n\t    \t}\n        else\n        {\n\t    \t\t// sleep the thread to give up some cpu\n\t    \t\tsleep(20);\n\t    \t}\n\t    }\n\t    // done\n}\n</code></pre>\n<p>If the user does not give the thread a chance to sleep, the\nthread may take 100% of the CPU core while it's looping as it\nwaits for something to do.  This may lead to poor application\nperformance.</p>\n<p><strong>Parameters:</strong></p>\n<p>milliseconds The number of milliseconds to sleep.</p>\n","desc":"","counter":0},{"syntax":"startThread()","name":"startThread","returns":"void","returns_description":null,"parameters":null,"access":"public","version_started":"0.8.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Start the thread.\n\\note Subclasses can directly access the mutex and employ thier\nown locking strategy.</p>\n","desc":"","counter":0},{"syntax":"stopThread()","name":"stopThread","returns":"void","returns_description":null,"parameters":null,"access":"public","version_started":"0072","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Stop the thread.</p>\n<p>This does immediately stop the thread from processing, but\nwill only set a flag that must be checked from within your\nthreadedFunction() by calling isThreadRunning().  If the user wants\nto both stop the thread AND wait for the thread to finish\nprocessing, the user should call waitForThread(true, ...).</p>\n","desc":"","counter":0},{"syntax":"threadedFunction()","name":"threadedFunction","returns":"void","returns_description":null,"parameters":null,"access":"protected","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>The thread's run function.</p>\n<p>Users must overide this in your their derived class\nand then implement their threaded activity inside the loop.\nIf the the users's threadedFunction does not have a loop,\nthe contents of the threadedFunction will be executed once\nand the thread will then exit.</p>\n<p>For tasks that must be repeated, the user can use a while\nloop that will run repeatedly until the thread's\nthreadRunning is set to false via the stopThread() method.</p>\n<pre><code>void MyThreadedClass::threadedFunction()\n{\n    // Start the loop and continue until\n    // isThreadRunning() returns false.\n    while(isThreadRunning())\n    {\n        // Do activity repeatedly here:\n\n        // int j = 1 + 1;\n\n        // This while loop will run as fast as it possibly\n        // can, consuming as much processor speed as it can.\n        // To help the processor stay cool, users are\n        // encouraged to let the while loop sleep via the\n        // sleep() method, or call the yield() method to let\n        // other threads have a turn.  See the sleep() and\n        // yield() methods for more information.\n\n        // sleep(100);\n    }\n}\n</code></pre>\n","desc":"<p>This is the thread run function, the heart of your thread.</p>\n<p>You need to override this in your derived class and implement your thread stuff inside. If you do not have a loop inside this function, it will run once then exit. If you want the thread to run until you signal it to stop, use a while loop inside that checks if the thread is should keep running.</p>\n<p>Declaration in a .h file:</p>\n<pre><code class=\"language-{.cpp}\">\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">MyThread</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">public</span> ofThread <span class=\"token punctuation\">{</span>\n\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\n\t<span class=\"token comment\" spellcheck=\"true\">// the thread function</span>\n\t<span class=\"token keyword\">void</span> MyThread<span class=\"token operator\">::</span><span class=\"token function\">threadedFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\n\t\t<span class=\"token comment\" spellcheck=\"true\">// start</span>\n\t\n\t\t<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token function\">isThreadRunning</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\n\t\t\t<span class=\"token comment\" spellcheck=\"true\">// do stuff</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\n\t\t<span class=\"token comment\" spellcheck=\"true\">// done</span>\n\t<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<p>In the .cpp file:</p>\n<pre><code class=\"language-{.cpp}\">\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">setup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n\t<span class=\"token comment\" spellcheck=\"true\">// create object</span>\n\tMyThread thread<span class=\"token punctuation\">;</span>\n\t\n\t<span class=\"token comment\" spellcheck=\"true\">// start the thread</span>\n\tthread<span class=\"token punctuation\">.</span><span class=\"token function\">startThread</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\" spellcheck=\"true\">// blocking, non verbose</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n\t<span class=\"token comment\" spellcheck=\"true\">// do something else while the thread is running</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\n\t<span class=\"token comment\" spellcheck=\"true\">// stop the thread</span>\n\tthread<span class=\"token punctuation\">.</span><span class=\"token function\">stopThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n","counter":0},{"syntax":"tryLock()","name":"tryLock","returns":"bool","returns_description":null,"parameters":null,"access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Tries to lock the mutex.</p>\n<p>If the thread was started startThread(true), then this call will wait\nuntil the mutex is available and return true.  If the thread was started\nstartThread(false), this call will return true iff the mutex is\nwas successfully acquired.</p>\n<p><strong>Returns</strong>: true if the lock was successfully acquired.</p>\n","desc":"","counter":0},{"syntax":"unlock()","name":"unlock","returns":"void","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Unlock the mutex.</p>\n<p>This will only unlocks the mutex if it was previously by the same\ncalling thread.</p>\n","desc":"<p>Unlock the mutex.</p>\n<p>This only unlocks the mutex if the calling thread had previously locked it, otherwise the functions does nothing and does not block.</p>\n","counter":0},{"syntax":"waitForThread(callStopThread = true, milliseconds)","name":"waitForThread","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">bool</span> callStopThread<span class=\"token operator\">=</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> milliseconds","access":"public","version_started":"0.8.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Wait for the thread to exit (aka &quot;joining&quot; the thread).</p>\n<p>This method waits for a thread will &quot;block&quot; and wait for the\nthread (aka &quot;join&quot; the thread) before it returns.  This allows the\nuser to be sure that the thread is properly cleaned up.  An example\nof when this might be particularly important is if the\nthreadedFunction() is opening a set of network sockets, or\ndownloading data from the web.  Destroying an ofThread subclass\nwithout releasing those sockets (or other resources), may result in\nsegmentation faults, error signals or other undefined behaviors.</p>\n<p><strong>Parameters:</strong></p>\n<p>callStopThread Set stop to true if you want to signal the thread\nto exit before waiting.  This is the equivalent to calling\nstopThread(). If you your threadedFunction uses a while-loop that\ndepends on isThreadRunning() and you do not call stopThread() or set\nstop == true, waitForThread will hang indefinitely.  Set stop ==\nfalse ONLY if you have already called stopThread() and you simply\nneed to be sure your thread has finished its tasks.</p>\n<p>milliseconds If millseconds is set to INFINITE_JOIN_TIMEOUT, the\nwaitForThread will wait indefinitely for the thread to complete.  If\nmilliseconds is set to a lower number (e.g. 10000 for 10 seconds),\nwaitForThread will wait for 10000 milliseconds and if the thread has\nnot yet stopped it will return and log an error message.  Users are\nencouraged to use the default INFINITE_JOIN_TIMEOUT.  If the user is\nunhappy with the amount of time it takes to join a thread, the user\nis encouraged to seek more expedient ways of signalling their desire\nfor a thread to complete via other signalling methods such as\nPoco::Event, Poco::Condition, or Poco::Semaphore.</p>\n<p><strong>See also</strong>: http://pocoproject.org/slides/090-NotificationsEvents.pdf</p>\n<p><strong>See also</strong>: http://pocoproject.org/docs/Poco.Condition.html</p>\n<p><strong>See also</strong>: http://pocoproject.org/docs/Poco.Event.html</p>\n<p><strong>See also</strong>: http://pocoproject.org/docs/Poco.Semaphore.html</p>\n","desc":"","counter":0},{"syntax":"yield()","name":"yield","returns":"void","returns_description":null,"parameters":null,"access":"public","version_started":"0071","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Tell the thread to give up its CPU time other threads.</p>\n<p>This method is similar to sleep() and can often be used in\nthe same way.  The main difference is that 1 millisecond\n(the minimum sleep time available with sleep()) is a very\nlong time on modern processors and yield() simply gives up\nprocessing time to the next thread, instead of waiting for\nnumber of milliseconds. In some cases, this behavior will\nbe preferred.</p>\n","desc":"","counter":0},{"name":"condition","type":"condition_variable","access":"private","version_started":"0.10.0","version_deprecated":null,"summary":null,"visible":"True","constant":"False","advanced":"False","short":"","desc":""},{"name":"mutex","type":"ofMutex","access":"protected","version_started":"007","version_deprecated":null,"summary":null,"visible":"True","constant":"True","advanced":"False","desc":"<p>This is the internal <a href=\"http://en.wikipedia.org/wiki/Mutex\">mutex</a> called through lock() &amp; unlock(). You can use it manually inside your derived class.</p>\n"},{"short":"","desc":""},{"name":"name","type":"string","access":"private","version_started":"0.10.0","version_deprecated":null,"summary":null,"visible":"True","constant":"False","advanced":"False","short":"","desc":""},{"name":"thread","type":"Poco","access":"private","version_started":"0071","version_deprecated":null,"summary":null,"visible":"True","constant":"True","advanced":"False","short":"<p>The Poco::Thread that runs the Poco::Runnable.</p>\n","desc":""},{"short":"","desc":""},{"short":"","desc":""},{}],"document":"<p>#class ofThread</p>\n<!--\n_visible: True_\n_advanced: False_\n_istemplated: False_\n_extends: _\n-->\n<p>##InlineDescription</p>\n<p>A threaded base class with a built in mutex for convenience.</p>\n<p>Users can extend this base class by public inheritance like this:</p>\n<pre><code>class MyThreadedClass: public ofThread\n{\n    public:\n    ...\n    void threadedFunction()\n    {\n        while(isThreadRunning())\n        {\n            Threaded function here.\n        }\n    }\n};\n</code></pre>\n<p>ofThread is a convenient wrapper for Poco::Thread, Poco::Runnable and\nPoco::Mutex.  It represents a simplified (sometimes overly simplified -\nor simplified in ways that might not make sense for your project)\npathway for quickly writing threaded classes.  Poco::Runnable represents\na class that can be &quot;run&quot; via its void run() method.  Poco::Thread is\nable to spawn a thread and &quot;run&quot; the contents of a class that extends\nthe Poco::Runnable interface (which ofThread does).  Poco::FastMutex,\n(aka ofMutex) is a &quot;mutual exclusion&quot; object that prevents two threads\nfrom accessing the same data at the same time.  It is important to know\nthat Poco::FastMutex (aka ofMutex) is not &quot;recursive&quot; while Poco::Mutex\nis. This means that if the same thread attempts to lock a thread while\nit ALREADY has a lock on the mutex, the program will lock up and go\nnowhere.  Thus, it is important that ofThread subclasses carefully\ntheir use of the mutex.  Currently ofThread does not lock its own mutex\nat any point (e.g. ofThread's internal variables are not thread safe).\nThis is a somewhat dangerous convenience that is (theoretically)\nsupposed to make it easier for subclasses to avoid the recursive mutex\n&quot;problem&quot;. The situation that arises from two threads simultanously\nreading or writing from the same shared data (shared data\noccupies the same physical location in memory) leads to something\ncalled a &quot;race condition&quot;, which can lead to deadlocks.\nA deadlock is as bad as it sounds.  It means your program\njust stops.  ofMutex prevents race conditions, deadlocks and crashes by\npermitting only one thread access to shared data at a time.  When using\nmutexes to protect data, the trick is to always be sure to unlock the\nmutex when finished.  This problem can often be avoided by using\nan Poco::FastMutex::ScopedLock (aka ofScopedLock).  See the\nthe documentation for more information.  Finally, there are many cases\nwhere it might make more sense to use Poco::Thread, Poco::Runnable and\nPoco::FastMutex directly rather than using ofThread.  Further, cross\nplatform thread management will be alleviated with the std::thread\nsupport library included with C++11.</p>\n<p>Uncaught Exceptions throw from within ofThread will cause the thread to stop\nand the Exception will be delivered to the default ofBaseThreadErrorHandler.\nThe ofBaseThreadErrorHandler will print the exception details, if available.\nThe ofBaseThreadErrorHandler offers no opportunity to take corrective action\nand only allows the user to receive more valuable debugging information\nabout the uncaught exception.  Users should design ofThread subclasses to\ncatch and respond to all anticipated exceptions.</p>\n<p>##Description</p>\n<p>ofThread is a thread base class with a built in mutex. A <a href=\"http://en.wikipedia.org/wiki/Thread_(computing)\">thread</a> is essentially a mini processing object you can run in parallel to your main application loop and is useful for running time intensive operations without slowing down your app.</p>\n<p>####Implementing a Thread</p>\n<p>For instance, you have to grab from a camera and waiting for an image slows down your app. You can offload this wait to a thread which tells the main app when an image is ready. To do this, you create a class that inherits from the ofThread class and implement the threadedFunction() function.</p>\n<p>Declaration in a .h file:</p>\n<pre><code class=\"language-{.cpp}\">\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">MyThread</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">public</span> ofThread <span class=\"token punctuation\">{</span>\n\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\n\t<span class=\"token comment\" spellcheck=\"true\">// the thread function</span>\n\t<span class=\"token keyword\">void</span> MyThread<span class=\"token operator\">::</span><span class=\"token function\">threadedFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\n\t\t<span class=\"token comment\" spellcheck=\"true\">// start</span>\n\t\n\t\t<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token function\">isThreadRunning</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\n\t\t\tcam<span class=\"token punctuation\">.</span><span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>cam<span class=\"token punctuation\">.</span><span class=\"token function\">isFrameNew</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\n\t\t\t\t<span class=\"token comment\" spellcheck=\"true\">// load the image</span>\n\t\t\t\timage<span class=\"token punctuation\">.</span><span class=\"token function\">setFromPixels</span><span class=\"token punctuation\">(</span>cam<span class=\"token punctuation\">.</span><span class=\"token function\">getPixels</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token punctuation\">}</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\n\t\t<span class=\"token comment\" spellcheck=\"true\">// done</span>\n\t<span class=\"token punctuation\">}</span>\n\t\n\tofVideoGrabber cam<span class=\"token punctuation\">;</span>\t<span class=\"token comment\" spellcheck=\"true\">// the cam</span>\n\tofImage image<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<p>In the application .h inside the ofApp class declare an object of type MyThread like:</p>\n<pre><code class=\"language-{.cpp}\"><span class=\"token comment\" spellcheck=\"true\">// create object</span>\nMyThread thread<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>then in the .cpp file:</p>\n<pre><code class=\"language-{.cpp}\">\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">setup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n\t<span class=\"token comment\" spellcheck=\"true\">// start the thread</span>\n\tthread<span class=\"token punctuation\">.</span><span class=\"token function\">startThread</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\" spellcheck=\"true\">// blocking</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\n\t<span class=\"token comment\" spellcheck=\"true\">// do something with the thread is running</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n\t<span class=\"token comment\" spellcheck=\"true\">// stop the thread</span>\n\tthread<span class=\"token punctuation\">.</span><span class=\"token function\">stopThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p>####Shared Resources</p>\n<p>With this great power, however, comes great responsibility. If both the thread and your main app loop try to access the image at the same time, bad things happen inside your computer and the app will crash. The image is a considered a &quot;shared resource&quot; and you need to make sure to lock access to it so that only 1 thread can access it a time. You can do this using a <a href=\"http://en.wikipedia.org/wiki/Mutex\">&quot;mutal exclusion&quot; object</a> by called lock() when you want to access the resource, then unlock() when you are done.</p>\n<p>Declaration in a .h file:</p>\n<pre><code class=\"language-{.cpp}\">\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">MyThread</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">public</span> ofThread <span class=\"token punctuation\">{</span>\n\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\n\t<span class=\"token comment\" spellcheck=\"true\">// the thread function</span>\n\t<span class=\"token keyword\">void</span> MyThread<span class=\"token operator\">::</span><span class=\"token function\">threadedFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\n\t\t<span class=\"token comment\" spellcheck=\"true\">// start</span>\n\t\n\t\t<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token function\">isThreadRunning</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\n\t\t\tcam<span class=\"token punctuation\">.</span><span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>cam<span class=\"token punctuation\">.</span><span class=\"token function\">isFrameNew</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\n\t\t\t\t<span class=\"token comment\" spellcheck=\"true\">// lock access to the resource</span>\n\t\t\t\t<span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t\n\t\t\t\t<span class=\"token comment\" spellcheck=\"true\">// load the image</span>\n\t\t\t\timage<span class=\"token punctuation\">.</span><span class=\"token function\">setFromPixels</span><span class=\"token punctuation\">(</span>cam<span class=\"token punctuation\">.</span><span class=\"token function\">getPixels</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t\n\t\t\t\t<span class=\"token comment\" spellcheck=\"true\">// done with the resource</span>\n\t\t\t\t<span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token punctuation\">}</span>\t\n\t\t<span class=\"token punctuation\">}</span>\n\t\n\t\t<span class=\"token comment\" spellcheck=\"true\">// done</span>\n\t<span class=\"token punctuation\">}</span>\n\n\tofVideoGrabber cam<span class=\"token punctuation\">;</span>\t<span class=\"token comment\" spellcheck=\"true\">// the cam</span>\n\tofImage image<span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\" spellcheck=\"true\">// the shared resource</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<p>In the .cpp file:</p>\n<pre><code class=\"language-{.cpp}\">\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">setup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\n\t<span class=\"token comment\" spellcheck=\"true\">// start the thread</span>\n\tthread<span class=\"token punctuation\">.</span><span class=\"token function\">startThread</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\" spellcheck=\"true\">// blocking, non verbose</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\n\t<span class=\"token comment\" spellcheck=\"true\">// lock access to the resource</span>\n\tthread<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\n\t<span class=\"token comment\" spellcheck=\"true\">// copy image</span>\n\tmyImage <span class=\"token operator\">=</span> thread<span class=\"token punctuation\">.</span>image<span class=\"token punctuation\">;</span>\n\t\n\t<span class=\"token comment\" spellcheck=\"true\">// done with the resource</span>\n\tthread<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n\t<span class=\"token comment\" spellcheck=\"true\">// stop the thread</span>\n\tthread<span class=\"token punctuation\">.</span><span class=\"token function\">stopThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p>####Exiting Nicely</p>\n<p>As a thread is running in parallel with your application main loop, it's important to remember to tell it to stop before exiting the app. If you don't, you'll get weird errors or hangs because you aren't being nice to your threads. Depending on how you started your thread (blocking or non-blocking mode), you will either stop it for wait for it to finish. See the stopThread() &amp; waitForThread() functions.</p>\n<p>####Debugging</p>\n<p>Thread errors are <em>notoriously</em> difficult to debug sometimes. You will probably see a &quot;Bad Access&quot; runtime error or something similar if multiple threads are trying to access a shared resource simultaneously. Other times, nothing will happen as the thread may be stuck in an infinite loop and you can't stop it. Wee! We assume if you've read this far, you probably accept the difficulties in order to reap the thread speed rewards.</p>\n<p>A useful tool in debugging thread timing and access is the ofThread verbose mode which prints thread events such as starting, stopping, and mutex locking/unlocking. Simply set verbose=true when calling startThread(). Another trick is to use an ofSleepMillis() inside the thread to slow it down so you can see the timing better while debugging it.</p>\n<p>####HOO RAH</p>\n<p>Ok soldier, lock and load ... good luck!</p>\n<p>##Methods</p>\n<p>###thread &amp; getNativeThread()</p>\n<!--\n_syntax: getNativeThread()_\n_name: getNativeThread_\n_returns: thread &_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>Get a reference to the underlying Poco thread.</p>\n<p>Poco::Thread provides a clean cross-platform wrapper for\nthreads.  On occasion, it may be useful to interact with the\nunderlying Poco::Thread directly.</p>\n<p><strong>Returns</strong>: A reference to the backing Poco thread.</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###const thread &amp; getNativeThread()</p>\n<!--\n_syntax: getNativeThread()_\n_name: getNativeThread_\n_returns: const thread &_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>Get a const reference to the underlying Poco thread.</p>\n<p>Poco::Thread provides a clean cross-platform wrapper for\nthreads.  On occasion, it may be useful to interact with the\nunderlying Poco::Thread directly.</p>\n<p><strong>Returns</strong>: A reference to the backing Poco thread.</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###thread::id getThreadId()</p>\n<!--\n_syntax: getThreadId()_\n_name: getThreadId_\n_returns: thread::id_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0071_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>Get the unique thread id.\n\\note This is NOT the the same as the operating thread id!</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###string getThreadName()</p>\n<!--\n_syntax: getThreadName()_\n_name: getThreadName_\n_returns: string_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.8.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>Get the unique thread name, in the form of &quot;Thread id#&quot;</p>\n<p><strong>Returns</strong>: the Thread ID string.</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###bool isCurrentThread()</p>\n<!--\n_syntax: isCurrentThread()_\n_name: isCurrentThread_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0071_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>Query whether the current thread is active.</p>\n<p>In multithreaded situations, it can be useful to know which\nthread is currently running some code in order to make sure\nonly certain threads can do certain things.  For example,\nOpenGL can only run in the main execution thread.  Thus,\nsituations where a thread is responsible for interacting\nwith graphics resources may need to prevent graphics updates\nunless the main thread is accessing or updating resources\nshared with this ofThread (or its subclass).</p>\n<pre><code>if(myThread.isCurrentThread())\n{\n    // do some myThread things,\n    // but keep your hands off my resources!\n}\nelse if(ofThread::isMainThread())\n{\n    // pheew! ok, update those graphics resources\n}\n</code></pre>\n<p>By way of another example, a subclass of ofThread may have\nan update() method that is called from ofBaseApp during the\nexecution of the main application thread.  In these cases,\nthe ofThread subclass might want to ask itself whether it\ncan, for instance, call update() on an ofImage, in order to\nsend copy some ofPixels to an ofTexture on the graphics\ncard.</p>\n<p><strong>Returns</strong>: True iff this ofThread the currently active thread.</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###bool isThreadRunning()</p>\n<!--\n_syntax: isThreadRunning()_\n_name: isThreadRunning_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>Check the running status of the thread.</p>\n<p><strong>Returns</strong>: true iff the thread is currently running.</p>\n<p>_description: _</p>\n<p>Returns true if the thread is currently running. This is especially useful inside the thread's threadedFunction() when you want it to loop continuously until it's told to exit:</p>\n<pre><code class=\"language-{.cpp}\">\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">MyThread</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">public</span> ofThread <span class=\"token punctuation\">{</span>\n\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\n\t<span class=\"token comment\" spellcheck=\"true\">// the thread function</span>\n\t<span class=\"token keyword\">void</span> MyThread<span class=\"token operator\">::</span><span class=\"token function\">threadedFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\n\t\t<span class=\"token comment\" spellcheck=\"true\">// start</span>\n\t\n\t\t<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token function\">isThreadRunning</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\n\t\t\t<span class=\"token comment\" spellcheck=\"true\">// do stuff</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\n\t\t<span class=\"token comment\" spellcheck=\"true\">// done</span>\n\t<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<!----------------------------------------------------------------------------->\n<p>###bool lock()</p>\n<!--\n_syntax: lock()_\n_name: lock_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>Lock the mutex.</p>\n<p>If the thread was started startThread(true), then this call will wait\nuntil the mutex is available and return true.  If the thread was started\nstartThread(false), this call will return true iff the mutex is\nwas successfully acquired.</p>\n<p><strong>Returns</strong>: true if the lock was successfully acquired.</p>\n<p>_description: _</p>\n<p>Try to lock the mutex.</p>\n<p>If the thread was started in blocking mode in startThread(), any thread (including your app main loop) will wait until the mutex is unlocked.</p>\n<p>If the thread is non-blocking, this call will immediately return a true or false if the mutex is available. It is up to you to make sure the resource is not being used when accessing it. See the <a href=\"http://en.wikipedia.org/wiki/Non-blocking_algorithm\">Wikipedia article on Non-blocking</a> for reasons as to why using a non-blocking thread might be more advantageous.</p>\n<!----------------------------------------------------------------------------->\n<h3>ofThread()</h3>\n<!--\n_syntax: ofThread()_\n_name: ofThread_\n_returns: _\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: False_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>Create an ofThread.</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###void run()</p>\n<!--\n_syntax: run()_\n_name: run_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: private_\n_version_started: 0071_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###void setThreadName(&amp;name)</p>\n<!--\n_syntax: setThreadName(&name)_\n_name: setThreadName_\n_returns: void_\n_returns_description: _\n_parameters: const string &name_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###void sleep(milliseconds)</p>\n<!--\n_syntax: sleep(milliseconds)_\n_name: sleep_\n_returns: void_\n_returns_description: _\n_parameters: long milliseconds_\n_access: public_\n_version_started: 0.8.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>Tell the thread to sleep for a certain amount of milliseconds.</p>\n<p>This is useful inside the threadedFunction() when a thread is waiting\nfor input to process:</p>\n<pre><code>void MyThreadedClass::threadedFunction()\n{\n\t    // start\n\t    while(isThreadRunning())\n    {\n        // bReadyToProcess can be set from outside the threadedFuntion.\n        // perhaps by another thread that downloads data, or loads\n        // some media, etc.\n\n\t    \tif(bReadyToProcess == true)\n        {\n\t    \t\t// do some time intensive processing\n\t    \t\tbReadyToProcess = false;\n\t    \t}\n        else\n        {\n\t    \t\t// sleep the thread to give up some cpu\n\t    \t\tsleep(20);\n\t    \t}\n\t    }\n\t    // done\n}\n</code></pre>\n<p>If the user does not give the thread a chance to sleep, the\nthread may take 100% of the CPU core while it's looping as it\nwaits for something to do.  This may lead to poor application\nperformance.</p>\n<p><strong>Parameters:</strong></p>\n<p>milliseconds The number of milliseconds to sleep.</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###void startThread()</p>\n<!--\n_syntax: startThread()_\n_name: startThread_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.8.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>Start the thread.\n\\note Subclasses can directly access the mutex and employ thier\nown locking strategy.</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###void stopThread()</p>\n<!--\n_syntax: stopThread()_\n_name: stopThread_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0072_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>Stop the thread.</p>\n<p>This does immediately stop the thread from processing, but\nwill only set a flag that must be checked from within your\nthreadedFunction() by calling isThreadRunning().  If the user wants\nto both stop the thread AND wait for the thread to finish\nprocessing, the user should call waitForThread(true, ...).</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###void threadedFunction()</p>\n<!--\n_syntax: threadedFunction()_\n_name: threadedFunction_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: protected_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>The thread's run function.</p>\n<p>Users must overide this in your their derived class\nand then implement their threaded activity inside the loop.\nIf the the users's threadedFunction does not have a loop,\nthe contents of the threadedFunction will be executed once\nand the thread will then exit.</p>\n<p>For tasks that must be repeated, the user can use a while\nloop that will run repeatedly until the thread's\nthreadRunning is set to false via the stopThread() method.</p>\n<pre><code>void MyThreadedClass::threadedFunction()\n{\n    // Start the loop and continue until\n    // isThreadRunning() returns false.\n    while(isThreadRunning())\n    {\n        // Do activity repeatedly here:\n\n        // int j = 1 + 1;\n\n        // This while loop will run as fast as it possibly\n        // can, consuming as much processor speed as it can.\n        // To help the processor stay cool, users are\n        // encouraged to let the while loop sleep via the\n        // sleep() method, or call the yield() method to let\n        // other threads have a turn.  See the sleep() and\n        // yield() methods for more information.\n\n        // sleep(100);\n    }\n}\n</code></pre>\n<p>_description: _</p>\n<p>This is the thread run function, the heart of your thread.</p>\n<p>You need to override this in your derived class and implement your thread stuff inside. If you do not have a loop inside this function, it will run once then exit. If you want the thread to run until you signal it to stop, use a while loop inside that checks if the thread is should keep running.</p>\n<p>Declaration in a .h file:</p>\n<pre><code class=\"language-{.cpp}\">\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">MyThread</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">public</span> ofThread <span class=\"token punctuation\">{</span>\n\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\n\t<span class=\"token comment\" spellcheck=\"true\">// the thread function</span>\n\t<span class=\"token keyword\">void</span> MyThread<span class=\"token operator\">::</span><span class=\"token function\">threadedFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\n\t\t<span class=\"token comment\" spellcheck=\"true\">// start</span>\n\t\n\t\t<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token function\">isThreadRunning</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\n\t\t\t<span class=\"token comment\" spellcheck=\"true\">// do stuff</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\n\t\t<span class=\"token comment\" spellcheck=\"true\">// done</span>\n\t<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<p>In the .cpp file:</p>\n<pre><code class=\"language-{.cpp}\">\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">setup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n\t<span class=\"token comment\" spellcheck=\"true\">// create object</span>\n\tMyThread thread<span class=\"token punctuation\">;</span>\n\t\n\t<span class=\"token comment\" spellcheck=\"true\">// start the thread</span>\n\tthread<span class=\"token punctuation\">.</span><span class=\"token function\">startThread</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\" spellcheck=\"true\">// blocking, non verbose</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n\t<span class=\"token comment\" spellcheck=\"true\">// do something else while the thread is running</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\n\t<span class=\"token comment\" spellcheck=\"true\">// stop the thread</span>\n\tthread<span class=\"token punctuation\">.</span><span class=\"token function\">stopThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<!----------------------------------------------------------------------------->\n<p>###bool tryLock()</p>\n<!--\n_syntax: tryLock()_\n_name: tryLock_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>Tries to lock the mutex.</p>\n<p>If the thread was started startThread(true), then this call will wait\nuntil the mutex is available and return true.  If the thread was started\nstartThread(false), this call will return true iff the mutex is\nwas successfully acquired.</p>\n<p><strong>Returns</strong>: true if the lock was successfully acquired.</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###void unlock()</p>\n<!--\n_syntax: unlock()_\n_name: unlock_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>Unlock the mutex.</p>\n<p>This will only unlocks the mutex if it was previously by the same\ncalling thread.</p>\n<p>_description: _</p>\n<p>Unlock the mutex.</p>\n<p>This only unlocks the mutex if the calling thread had previously locked it, otherwise the functions does nothing and does not block.</p>\n<!----------------------------------------------------------------------------->\n<p>###void waitForThread(callStopThread = true, milliseconds)</p>\n<!--\n_syntax: waitForThread(callStopThread = true, milliseconds)_\n_name: waitForThread_\n_returns: void_\n_returns_description: _\n_parameters: bool callStopThread=true, long milliseconds_\n_access: public_\n_version_started: 0.8.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>Wait for the thread to exit (aka &quot;joining&quot; the thread).</p>\n<p>This method waits for a thread will &quot;block&quot; and wait for the\nthread (aka &quot;join&quot; the thread) before it returns.  This allows the\nuser to be sure that the thread is properly cleaned up.  An example\nof when this might be particularly important is if the\nthreadedFunction() is opening a set of network sockets, or\ndownloading data from the web.  Destroying an ofThread subclass\nwithout releasing those sockets (or other resources), may result in\nsegmentation faults, error signals or other undefined behaviors.</p>\n<p><strong>Parameters:</strong></p>\n<p>callStopThread Set stop to true if you want to signal the thread\nto exit before waiting.  This is the equivalent to calling\nstopThread(). If you your threadedFunction uses a while-loop that\ndepends on isThreadRunning() and you do not call stopThread() or set\nstop == true, waitForThread will hang indefinitely.  Set stop ==\nfalse ONLY if you have already called stopThread() and you simply\nneed to be sure your thread has finished its tasks.</p>\n<p>milliseconds If millseconds is set to INFINITE_JOIN_TIMEOUT, the\nwaitForThread will wait indefinitely for the thread to complete.  If\nmilliseconds is set to a lower number (e.g. 10000 for 10 seconds),\nwaitForThread will wait for 10000 milliseconds and if the thread has\nnot yet stopped it will return and log an error message.  Users are\nencouraged to use the default INFINITE_JOIN_TIMEOUT.  If the user is\nunhappy with the amount of time it takes to join a thread, the user\nis encouraged to seek more expedient ways of signalling their desire\nfor a thread to complete via other signalling methods such as\nPoco::Event, Poco::Condition, or Poco::Semaphore.</p>\n<p><strong>See also</strong>: http://pocoproject.org/slides/090-NotificationsEvents.pdf</p>\n<p><strong>See also</strong>: http://pocoproject.org/docs/Poco.Condition.html</p>\n<p><strong>See also</strong>: http://pocoproject.org/docs/Poco.Event.html</p>\n<p><strong>See also</strong>: http://pocoproject.org/docs/Poco.Semaphore.html</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###void yield()</p>\n<!--\n_syntax: yield()_\n_name: yield_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0071_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>Tell the thread to give up its CPU time other threads.</p>\n<p>This method is similar to sleep() and can often be used in\nthe same way.  The main difference is that 1 millisecond\n(the minimum sleep time available with sleep()) is a very\nlong time on modern processors and yield() simply gives up\nprocessing time to the next thread, instead of waiting for\nnumber of milliseconds. In some cases, this behavior will\nbe preferred.</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>##Variables</p>\n<p>###condition_variable condition</p>\n<!--\n_name: condition_\n_type: condition_variable_\n_access: private_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: False_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###ofMutex mutex</p>\n<!--\n_name: mutex_\n_type: ofMutex_\n_access: protected_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>The internal mutex called through lock() &amp; unlock().</p>\n<p>This mutext can also be used with std::unique_lock or lock_guard\nwithin the threaded function by calling:</p>\n<pre><code>std::unique_lock&lt;std::mutex&gt; lock(mutex);\n</code></pre>\n<p>_description: _</p>\n<p>This is the internal <a href=\"http://en.wikipedia.org/wiki/Mutex\">mutex</a> called through lock() &amp; unlock(). You can use it manually inside your derived class.</p>\n<!----------------------------------------------------------------------------->\n<p>###atomic&lt; bool &gt; mutexBlocks</p>\n<!--\n_name: mutexBlocks_\n_type: atomic< bool >_\n_access: private_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: False_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###string name</p>\n<!--\n_name: name_\n_type: string_\n_access: private_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: False_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###Poco thread</p>\n<!--\n_name: thread_\n_type: Poco_\n_access: private_\n_version_started: 0071_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>The Poco::Thread that runs the Poco::Runnable.</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###atomic&lt; bool &gt; threadDone</p>\n<!--\n_name: threadDone_\n_type: atomic< bool >_\n_access: private_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: False_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n<p>###atomic&lt; bool &gt; threadRunning</p>\n<!--\n_name: threadRunning_\n_type: atomic< bool >_\n_access: private_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: False_\n_advanced: False_\n-->\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<!----------------------------------------------------------------------------->\n","raw":"#class ofThread\n\n\n<!--\n_visible: True_\n_advanced: False_\n_istemplated: False_\n_extends: _\n-->\n\n##InlineDescription\n\n\nA threaded base class with a built in mutex for convenience.\n\nUsers can extend this base class by public inheritance like this:\n\n    class MyThreadedClass: public ofThread\n    {\n        public:\n        ...\n        void threadedFunction()\n        {\n            while(isThreadRunning())\n            {\n                Threaded function here.\n            }\n        }\n    };\n\nofThread is a convenient wrapper for Poco::Thread, Poco::Runnable and\nPoco::Mutex.  It represents a simplified (sometimes overly simplified -\nor simplified in ways that might not make sense for your project)\npathway for quickly writing threaded classes.  Poco::Runnable represents\na class that can be \"run\" via its void run() method.  Poco::Thread is\nable to spawn a thread and \"run\" the contents of a class that extends\nthe Poco::Runnable interface (which ofThread does).  Poco::FastMutex,\n(aka ofMutex) is a \"mutual exclusion\" object that prevents two threads\nfrom accessing the same data at the same time.  It is important to know\nthat Poco::FastMutex (aka ofMutex) is not \"recursive\" while Poco::Mutex\nis. This means that if the same thread attempts to lock a thread while\nit ALREADY has a lock on the mutex, the program will lock up and go\nnowhere.  Thus, it is important that ofThread subclasses carefully\ntheir use of the mutex.  Currently ofThread does not lock its own mutex\nat any point (e.g. ofThread's internal variables are not thread safe).\nThis is a somewhat dangerous convenience that is (theoretically)\nsupposed to make it easier for subclasses to avoid the recursive mutex\n\"problem\". The situation that arises from two threads simultanously\nreading or writing from the same shared data (shared data\noccupies the same physical location in memory) leads to something\ncalled a \"race condition\", which can lead to deadlocks.\nA deadlock is as bad as it sounds.  It means your program\njust stops.  ofMutex prevents race conditions, deadlocks and crashes by\npermitting only one thread access to shared data at a time.  When using\nmutexes to protect data, the trick is to always be sure to unlock the\nmutex when finished.  This problem can often be avoided by using\nan Poco::FastMutex::ScopedLock (aka ofScopedLock).  See the\nthe documentation for more information.  Finally, there are many cases\nwhere it might make more sense to use Poco::Thread, Poco::Runnable and\nPoco::FastMutex directly rather than using ofThread.  Further, cross\nplatform thread management will be alleviated with the std::thread\nsupport library included with C++11.\n\nUncaught Exceptions throw from within ofThread will cause the thread to stop\nand the Exception will be delivered to the default ofBaseThreadErrorHandler.\nThe ofBaseThreadErrorHandler will print the exception details, if available.\nThe ofBaseThreadErrorHandler offers no opportunity to take corrective action\nand only allows the user to receive more valuable debugging information\nabout the uncaught exception.  Users should design ofThread subclasses to\ncatch and respond to all anticipated exceptions.\n\n\n\n\n\n##Description\n\nofThread is a thread base class with a built in mutex. A [thread](http://en.wikipedia.org/wiki/Thread_(computing)) is essentially a mini processing object you can run in parallel to your main application loop and is useful for running time intensive operations without slowing down your app.\n\n####Implementing a Thread\n\nFor instance, you have to grab from a camera and waiting for an image slows down your app. You can offload this wait to a thread which tells the main app when an image is ready. To do this, you create a class that inherits from the ofThread class and implement the threadedFunction() function.\n\nDeclaration in a .h file:\n\n~~~~{.cpp}\n\nclass MyThread : public ofThread {\n\n\t...\n\n\t// the thread function\n\tvoid MyThread::threadedFunction() {\n\t\n\t\t// start\n\t\n\t\twhile(isThreadRunning()) {\n\t\n\t\t\tcam.update();\n\t\t\tif(cam.isFrameNew()) {\n\t\t\n\t\t\t\t// load the image\n\t\t\t\timage.setFromPixels(cam.getPixels());\n\t\t\t}\n\t\t}\n\t\n\t\t// done\n\t}\n\t\n\tofVideoGrabber cam;\t// the cam\n\tofImage image;\n};\n\n~~~~\n\nIn the application .h inside the ofApp class declare an object of type MyThread like:\n\n~~~~{.cpp}\n// create object\nMyThread thread;\n~~~~\n\nthen in the .cpp file:\n\n~~~~{.cpp}\n\nvoid ofApp::setup() {\n\n\t// start the thread\n\tthread.startThread(true);\t// blocking\n}\n\nvoid ofApp::update() {\n\t\n\t// do something with the thread is running\n}\n\nvoid ofApp::exit() {\n\n\t// stop the thread\n\tthread.stopThread();\n}\n\n~~~~\n\n####Shared Resources\n\nWith this great power, however, comes great responsibility. If both the thread and your main app loop try to access the image at the same time, bad things happen inside your computer and the app will crash. The image is a considered a \"shared resource\" and you need to make sure to lock access to it so that only 1 thread can access it a time. You can do this using a [\"mutal exclusion\" object](http://en.wikipedia.org/wiki/Mutex) by called lock() when you want to access the resource, then unlock() when you are done.\n\nDeclaration in a .h file:\n\n~~~~{.cpp}\n\nclass MyThread : public ofThread {\n\n\t...\n\n\t// the thread function\n\tvoid MyThread::threadedFunction() {\n\t\n\t\t// start\n\t\n\t\twhile(isThreadRunning()) {\n\t\n\t\t\tcam.update();\n\t\t\tif(cam.isFrameNew()) {\n\t\n\t\t\t\t// lock access to the resource\n\t\t\t\tlock();\n\t\t\t\t\n\t\t\t\t// load the image\n\t\t\t\timage.setFromPixels(cam.getPixels());\t\n\t\t\t\t// done with the resource\n\t\t\t\tunlock();\n\t\t\t}\t\n\t\t}\n\t\n\t\t// done\n\t}\n\n\tofVideoGrabber cam;\t// the cam\n\tofImage image;\t\t// the shared resource\n};\n\n~~~~\n\nIn the .cpp file:\n\n~~~~{.cpp}\n\nvoid ofApp::setup() {\n\t\n\t// start the thread\n\tthread.startThread(true, false);\t// blocking, non verbose\n}\n\nvoid ofApp::update() {\n\t\n\t// lock access to the resource\n\tthread.lock();\n\t\n\t// copy image\n\tmyImage = thread.image;\n\t\n\t// done with the resource\n\tthread.unlock();\n}\n\nvoid ofApp::exit() {\n\n\t// stop the thread\n\tthread.stopThread();\n}\n\n~~~~\n\n####Exiting Nicely\n\nAs a thread is running in parallel with your application main loop, it's important to remember to tell it to stop before exiting the app. If you don't, you'll get weird errors or hangs because you aren't being nice to your threads. Depending on how you started your thread (blocking or non-blocking mode), you will either stop it for wait for it to finish. See the stopThread() & waitForThread() functions.\n\n####Debugging\n\nThread errors are *notoriously* difficult to debug sometimes. You will probably see a \"Bad Access\" runtime error or something similar if multiple threads are trying to access a shared resource simultaneously. Other times, nothing will happen as the thread may be stuck in an infinite loop and you can't stop it. Wee! We assume if you've read this far, you probably accept the difficulties in order to reap the thread speed rewards. \n\nA useful tool in debugging thread timing and access is the ofThread verbose mode which prints thread events such as starting, stopping, and mutex locking/unlocking. Simply set verbose=true when calling startThread(). Another trick is to use an ofSleepMillis() inside the thread to slow it down so you can see the timing better while debugging it.\n\n####HOO RAH\n\nOk soldier, lock and load ... good luck!\n\n\n\n\n\n##Methods\n\n\n\n###thread & getNativeThread()\n\n<!--\n_syntax: getNativeThread()_\n_name: getNativeThread_\n_returns: thread &_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nGet a reference to the underlying Poco thread.\n\nPoco::Thread provides a clean cross-platform wrapper for\nthreads.  On occasion, it may be useful to interact with the\nunderlying Poco::Thread directly.\n\n\n**Returns**: A reference to the backing Poco thread.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###const thread & getNativeThread()\n\n<!--\n_syntax: getNativeThread()_\n_name: getNativeThread_\n_returns: const thread &_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nGet a const reference to the underlying Poco thread.\n\nPoco::Thread provides a clean cross-platform wrapper for\nthreads.  On occasion, it may be useful to interact with the\nunderlying Poco::Thread directly.\n\n\n**Returns**: A reference to the backing Poco thread.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###thread::id getThreadId()\n\n<!--\n_syntax: getThreadId()_\n_name: getThreadId_\n_returns: thread::id_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0071_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nGet the unique thread id.\n\\note This is NOT the the same as the operating thread id!\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###string getThreadName()\n\n<!--\n_syntax: getThreadName()_\n_name: getThreadName_\n_returns: string_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.8.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nGet the unique thread name, in the form of \"Thread id#\"\n\n**Returns**: the Thread ID string.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool isCurrentThread()\n\n<!--\n_syntax: isCurrentThread()_\n_name: isCurrentThread_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0071_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nQuery whether the current thread is active.\n\nIn multithreaded situations, it can be useful to know which\nthread is currently running some code in order to make sure\nonly certain threads can do certain things.  For example,\nOpenGL can only run in the main execution thread.  Thus,\nsituations where a thread is responsible for interacting\nwith graphics resources may need to prevent graphics updates\nunless the main thread is accessing or updating resources\nshared with this ofThread (or its subclass).\n\n    if(myThread.isCurrentThread())\n    {\n        // do some myThread things,\n        // but keep your hands off my resources!\n    }\n    else if(ofThread::isMainThread())\n    {\n        // pheew! ok, update those graphics resources\n    }\n\nBy way of another example, a subclass of ofThread may have\nan update() method that is called from ofBaseApp during the\nexecution of the main application thread.  In these cases,\nthe ofThread subclass might want to ask itself whether it\ncan, for instance, call update() on an ofImage, in order to\nsend copy some ofPixels to an ofTexture on the graphics\ncard.\n\n\n**Returns**: True iff this ofThread the currently active thread.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool isThreadRunning()\n\n<!--\n_syntax: isThreadRunning()_\n_name: isThreadRunning_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCheck the running status of the thread.\n\n**Returns**: true iff the thread is currently running.\n\n\n\n\n\n_description: _\n\nReturns true if the thread is currently running. This is especially useful inside the thread's threadedFunction() when you want it to loop continuously until it's told to exit:\n\n~~~~{.cpp}\n\nclass MyThread : public ofThread {\n\n\t...\n\n\t// the thread function\n\tvoid MyThread::threadedFunction() {\n\t\n\t\t// start\n\t\n\t\twhile(isThreadRunning()) {\n\t\n\t\t\t// do stuff\n\t\t}\n\t\n\t\t// done\n\t}\n\n};\n\n~~~~\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool lock()\n\n<!--\n_syntax: lock()_\n_name: lock_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nLock the mutex.\n\nIf the thread was started startThread(true), then this call will wait\nuntil the mutex is available and return true.  If the thread was started\nstartThread(false), this call will return true iff the mutex is\nwas successfully acquired.\n\n\n**Returns**: true if the lock was successfully acquired.\n\n\n\n\n\n_description: _\n\nTry to lock the mutex.\n\nIf the thread was started in blocking mode in startThread(), any thread (including your app main loop) will wait until the mutex is unlocked.\n\nIf the thread is non-blocking, this call will immediately return a true or false if the mutex is available. It is up to you to make sure the resource is not being used when accessing it. See the [Wikipedia article on Non-blocking](http://en.wikipedia.org/wiki/Non-blocking_algorithm) for reasons as to why using a non-blocking thread might be more advantageous.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n### ofThread()\n\n<!--\n_syntax: ofThread()_\n_name: ofThread_\n_returns: _\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: False_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCreate an ofThread.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void run()\n\n<!--\n_syntax: run()_\n_name: run_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: private_\n_version_started: 0071_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setThreadName(&name)\n\n<!--\n_syntax: setThreadName(&name)_\n_name: setThreadName_\n_returns: void_\n_returns_description: _\n_parameters: const string &name_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void sleep(milliseconds)\n\n<!--\n_syntax: sleep(milliseconds)_\n_name: sleep_\n_returns: void_\n_returns_description: _\n_parameters: long milliseconds_\n_access: public_\n_version_started: 0.8.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nTell the thread to sleep for a certain amount of milliseconds.\n\nThis is useful inside the threadedFunction() when a thread is waiting\nfor input to process:\n\n    void MyThreadedClass::threadedFunction()\n    {\n\t\t    // start\n\t\t    while(isThreadRunning())\n        {\n            // bReadyToProcess can be set from outside the threadedFuntion.\n            // perhaps by another thread that downloads data, or loads\n            // some media, etc.\n\n\t\t    \tif(bReadyToProcess == true)\n            {\n\t\t    \t\t// do some time intensive processing\n\t\t    \t\tbReadyToProcess = false;\n\t\t    \t}\n            else\n            {\n\t\t    \t\t// sleep the thread to give up some cpu\n\t\t    \t\tsleep(20);\n\t\t    \t}\n\t\t    }\n\t\t    // done\n    }\n\nIf the user does not give the thread a chance to sleep, the\nthread may take 100% of the CPU core while it's looping as it\nwaits for something to do.  This may lead to poor application\nperformance.\n\n\n**Parameters:**\n\nmilliseconds The number of milliseconds to sleep.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void startThread()\n\n<!--\n_syntax: startThread()_\n_name: startThread_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.8.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nStart the thread.\n\\note Subclasses can directly access the mutex and employ thier\n      own locking strategy.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void stopThread()\n\n<!--\n_syntax: stopThread()_\n_name: stopThread_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0072_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nStop the thread.\n\nThis does immediately stop the thread from processing, but\nwill only set a flag that must be checked from within your\nthreadedFunction() by calling isThreadRunning().  If the user wants\nto both stop the thread AND wait for the thread to finish\nprocessing, the user should call waitForThread(true, ...).\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void threadedFunction()\n\n<!--\n_syntax: threadedFunction()_\n_name: threadedFunction_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: protected_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nThe thread's run function.\n\nUsers must overide this in your their derived class\nand then implement their threaded activity inside the loop.\nIf the the users's threadedFunction does not have a loop,\nthe contents of the threadedFunction will be executed once\nand the thread will then exit.\n\nFor tasks that must be repeated, the user can use a while\nloop that will run repeatedly until the thread's\nthreadRunning is set to false via the stopThread() method.\n\n    void MyThreadedClass::threadedFunction()\n    {\n        // Start the loop and continue until\n        // isThreadRunning() returns false.\n        while(isThreadRunning())\n        {\n            // Do activity repeatedly here:\n\n            // int j = 1 + 1;\n\n            // This while loop will run as fast as it possibly\n            // can, consuming as much processor speed as it can.\n            // To help the processor stay cool, users are\n            // encouraged to let the while loop sleep via the\n            // sleep() method, or call the yield() method to let\n            // other threads have a turn.  See the sleep() and\n            // yield() methods for more information.\n\n            // sleep(100);\n        }\n    }\n\n\n\n\n\n_description: _\n\nThis is the thread run function, the heart of your thread.\n\nYou need to override this in your derived class and implement your thread stuff inside. If you do not have a loop inside this function, it will run once then exit. If you want the thread to run until you signal it to stop, use a while loop inside that checks if the thread is should keep running.\n\nDeclaration in a .h file:\n\n~~~~{.cpp}\n\nclass MyThread : public ofThread {\n\n\t...\n\n\t// the thread function\n\tvoid MyThread::threadedFunction() {\n\t\n\t\t// start\n\t\n\t\twhile(isThreadRunning()) {\n\t\n\t\t\t// do stuff\n\t\t}\n\t\n\t\t// done\n\t}\n\n};\n\n~~~~\n\nIn the .cpp file:\n\n~~~~{.cpp}\n\nvoid ofApp::setup() {\n\n\t// create object\n\tMyThread thread;\n\t\n\t// start the thread\n\tthread.startThread(true, false);\t// blocking, non verbose\n}\n\nvoid ofApp::update() {\n\n\t// do something else while the thread is running\n}\n\nvoid ofApp::exit() {\n\t\n\t// stop the thread\n\tthread.stopThread();\n}\n\n~~~~\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool tryLock()\n\n<!--\n_syntax: tryLock()_\n_name: tryLock_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nTries to lock the mutex.\n\nIf the thread was started startThread(true), then this call will wait\nuntil the mutex is available and return true.  If the thread was started\nstartThread(false), this call will return true iff the mutex is\nwas successfully acquired.\n\n\n**Returns**: true if the lock was successfully acquired.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void unlock()\n\n<!--\n_syntax: unlock()_\n_name: unlock_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nUnlock the mutex.\n\nThis will only unlocks the mutex if it was previously by the same\ncalling thread.\n\n\n\n\n\n_description: _\n\nUnlock the mutex.\n\nThis only unlocks the mutex if the calling thread had previously locked it, otherwise the functions does nothing and does not block.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void waitForThread(callStopThread = true, milliseconds)\n\n<!--\n_syntax: waitForThread(callStopThread = true, milliseconds)_\n_name: waitForThread_\n_returns: void_\n_returns_description: _\n_parameters: bool callStopThread=true, long milliseconds_\n_access: public_\n_version_started: 0.8.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nWait for the thread to exit (aka \"joining\" the thread).\n\nThis method waits for a thread will \"block\" and wait for the\nthread (aka \"join\" the thread) before it returns.  This allows the\nuser to be sure that the thread is properly cleaned up.  An example\nof when this might be particularly important is if the\nthreadedFunction() is opening a set of network sockets, or\ndownloading data from the web.  Destroying an ofThread subclass\nwithout releasing those sockets (or other resources), may result in\nsegmentation faults, error signals or other undefined behaviors.\n\n\n**Parameters:**\n\ncallStopThread Set stop to true if you want to signal the thread\n    to exit before waiting.  This is the equivalent to calling\n    stopThread(). If you your threadedFunction uses a while-loop that\n    depends on isThreadRunning() and you do not call stopThread() or set\n    stop == true, waitForThread will hang indefinitely.  Set stop ==\n    false ONLY if you have already called stopThread() and you simply\n    need to be sure your thread has finished its tasks.\n\n\nmilliseconds If millseconds is set to INFINITE_JOIN_TIMEOUT, the\n    waitForThread will wait indefinitely for the thread to complete.  If\n    milliseconds is set to a lower number (e.g. 10000 for 10 seconds),\n    waitForThread will wait for 10000 milliseconds and if the thread has\n    not yet stopped it will return and log an error message.  Users are\n    encouraged to use the default INFINITE_JOIN_TIMEOUT.  If the user is\n    unhappy with the amount of time it takes to join a thread, the user\n    is encouraged to seek more expedient ways of signalling their desire\n    for a thread to complete via other signalling methods such as\n    Poco::Event, Poco::Condition, or Poco::Semaphore.\n\n**See also**: http://pocoproject.org/slides/090-NotificationsEvents.pdf\n\n**See also**: http://pocoproject.org/docs/Poco.Condition.html\n\n**See also**: http://pocoproject.org/docs/Poco.Event.html\n\n**See also**: http://pocoproject.org/docs/Poco.Semaphore.html\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void yield()\n\n<!--\n_syntax: yield()_\n_name: yield_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0071_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nTell the thread to give up its CPU time other threads.\n\nThis method is similar to sleep() and can often be used in\nthe same way.  The main difference is that 1 millisecond\n(the minimum sleep time available with sleep()) is a very\nlong time on modern processors and yield() simply gives up\nprocessing time to the next thread, instead of waiting for\nnumber of milliseconds. In some cases, this behavior will\nbe preferred.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n##Variables\n\n\n\n###condition_variable condition\n\n<!--\n_name: condition_\n_type: condition_variable_\n_access: private_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: False_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###ofMutex mutex\n\n<!--\n_name: mutex_\n_type: ofMutex_\n_access: protected_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nThe internal mutex called through lock() & unlock().\n\nThis mutext can also be used with std::unique_lock or lock_guard\nwithin the threaded function by calling:\n\n    std::unique_lock<std::mutex> lock(mutex);\n\n\n\n\n\n_description: _\n\nThis is the internal [mutex](http://en.wikipedia.org/wiki/Mutex) called through lock() & unlock(). You can use it manually inside your derived class.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###atomic< bool > mutexBlocks\n\n<!--\n_name: mutexBlocks_\n_type: atomic< bool >_\n_access: private_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: False_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###string name\n\n<!--\n_name: name_\n_type: string_\n_access: private_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: False_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###Poco thread\n\n<!--\n_name: thread_\n_type: Poco_\n_access: private_\n_version_started: 0071_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nThe Poco::Thread that runs the Poco::Runnable.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###atomic< bool > threadDone\n\n<!--\n_name: threadDone_\n_type: atomic< bool >_\n_access: private_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: False_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###atomic< bool > threadRunning\n\n<!--\n_name: threadRunning_\n_type: atomic< bool >_\n_access: private_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: False_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n","type":"page","static":true}}],"fetch":[]}