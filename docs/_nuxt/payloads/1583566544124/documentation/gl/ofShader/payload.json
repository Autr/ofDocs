{"data":[{"page":{"entry":{"name":"ofShader","filename":"ofShader.markdown","absolute":"/Users/gilbertsinnott/Code/openFrameworks/ofSite/documentation/gl/ofShader.markdown","path":"/documentation/gl/ofShader","route":"/documentation/gl/ofShader.markdown","dir":"../ofSite/documentation/gl","ext":"markdown","type":"page","id":1968,"parent":1942,"breadcrumbs":[1942,1718],"siblings":[],"translations":{}},"description":{"short":"","full":"<p>Graphics Language Shading Language (GLSL) can be used in oF by using the ofShader object. Shading happens in two distinct steps: the vertex shader creates values for each vertex in the model, and the fragment shader creates values for each pixel in the rendered object. To define a shader, create a .frag file for the fragment shader and a .vert file for the vertex shader.\nA vertex shader has attributes about a location in space or vertex, which means not only the actual coordinates of that location but also its color, how any textures should be mapped onto it, and how the vertices are modified in the operation. A vertex shader can change the positions of each vertex, the number of lighting computations per vertex, and the color that will be applied to each vertex.\nA geometry shader can generate new graphics primitives like points, lines, and triangles, from those primitives that were sent to the graphics card from the CPU. This means that you could get a point and turn it into a triangle or even a bunch of triangles, or get a line and turn it into a rectangle, or do real-time extrusion. They are very powerful and can be quite tricky to get right, but they're becoming more popular.\nThe fragment shader is somewhat misleadingly named because what it really allows you to do is to change values assigned to each pixel. The vertex shader operates on the vertices, and the fragment shader operates on the pixels. By the time the fragment shader gets information passed into it by the graphics card, the color of a particular pixel has already been computed and in the fragment shader can be combined with an element like a lighting effecting, a fog effect, or a blur among many other options. The usual end result of this stage per fragment is a color value and a depth for the fragment.</p>\n<h1></h1>\n"},"config":{"visible":"True","advanced":"False","istemplated":"False","extends":null},"methods":[{"syntax":"begin()","name":"begin","returns":"void","returns_description":null,"parameters":null,"access":"public","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>After you call begin() everything that you draw, vertexes and textures, in your of application have the effects of the shader applied to them.</p>\n"},{"syntax":"beginTransformFeedback(mode)","name":"beginTransformFeedback","returns":"void","returns_description":null,"parameters":"GLenum mode","access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"beginTransformFeedback(mode, &binding)","name":"beginTransformFeedback","returns":"void","returns_description":null,"parameters":"GLenum mode<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> ofShader<span class=\"token operator\">::</span>TransformFeedbackRangeBinding <span class=\"token operator\">&amp;</span>binding","access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"short":"","desc":""},{"syntax":"beginTransformFeedback(mode, &binding)","name":"beginTransformFeedback","returns":"void","returns_description":null,"parameters":"GLenum mode<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> ofShader<span class=\"token operator\">::</span>TransformFeedbackBaseBinding <span class=\"token operator\">&amp;</span>binding","access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"short":"","desc":""},{"syntax":"bindAttribute(location, &name)","name":"bindAttribute","returns":"void","returns_description":null,"parameters":"GLuint location<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>name","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p><code>bindAttribute</code> is used for faster access to attributes. The idea is to set attributes by location (an integer) instead of querying attribute locations multiple times by name. This method is used internally by OF in <code>ofShader<span class=\"token operator\">::</span><span class=\"token function\">bindDefaults</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code> to set the default locations of the <code>position</code>, <code>color</code>, <code>normal</code> and <code>texcoord</code> attributes.</p>\n"},{"syntax":"bindDefaults()","name":"bindDefaults","returns":"bool","returns_description":null,"parameters":null,"access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Binds default uniforms and attributes, only useful for fixed pipeline simulation under programmable renderer.\nHas to be called before linkProgram().</p>\n<p>See setupShaderFromSource() example.</p>\n"},{"syntax":"bindUniformBlock(bindind, &name)","name":"bindUniformBlock","returns":"void","returns_description":null,"parameters":"GLuint bindind<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>name","access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"checkAndCreateProgram()","name":"checkAndCreateProgram","returns":"void","returns_description":null,"parameters":null,"access":"private","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"checkProgramInfoLog()","name":"checkProgramInfoLog","returns":"void","returns_description":null,"parameters":null,"access":"private","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"checkProgramLinkStatus()","name":"checkProgramLinkStatus","returns":"bool","returns_description":null,"parameters":null,"access":"private","version_started":"0071","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"checkShaderInfoLog(shader, type, logLevel)","name":"checkShaderInfoLog","returns":"void","returns_description":null,"parameters":"GLuint shader<span class=\"token punctuation\">,</span> GLenum type<span class=\"token punctuation\">,</span> ofLogLevel logLevel","access":"private","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"dispatchCompute(x, y, z)","name":"dispatchCompute","returns":"void","returns_description":null,"parameters":"GLuint x<span class=\"token punctuation\">,</span> GLuint y<span class=\"token punctuation\">,</span> GLuint z","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"end()","name":"end","returns":"void","returns_description":null,"parameters":null,"access":"public","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>After you call end() any drawing, vertexes and textures, do not have the effect of the shader applied to them.</p>\n"},{"syntax":"endTransformFeedback(&binding)","name":"endTransformFeedback","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofShader<span class=\"token operator\">::</span>TransformFeedbackRangeBinding <span class=\"token operator\">&amp;</span>binding","access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"short":"","desc":""},{"syntax":"endTransformFeedback(&binding)","name":"endTransformFeedback","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofShader<span class=\"token operator\">::</span>TransformFeedbackBaseBinding <span class=\"token operator\">&amp;</span>binding","access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"short":"","desc":""},{"syntax":"endTransformFeedback()","name":"endTransformFeedback","returns":"void","returns_description":null,"parameters":null,"access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"getAttributeLocation(&name)","name":"getAttributeLocation","returns":"GLint","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>name","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"getGeometryMaxOutputCount()","name":"getGeometryMaxOutputCount","returns":"int","returns_description":null,"parameters":null,"access":"public","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>returns maximum number of supported vertices for your graphics card</p>\n"},{"syntax":"getProgram()","name":"getProgram","returns":"GLuint","returns_description":null,"parameters":null,"access":"public","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>This returns the GLuint for the actual shader object that is active on the graphics card. This is more of an advanced usage method, but can be helpful if you need to do something that the ofShader doesn't support currently. This is all the shaders: vertex, geom, and frag.</p>\n"},{"syntax":"getShader(type)","name":"getShader","returns":"GLuint","returns_description":null,"parameters":"GLenum type","access":"public","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>This returns the GLuint for the actual shader object that is active on the graphics card. This is more of an advanced usage method, but can be helpful if you need to do something that the ofShader doesn't support currently. This returns only one of the shaders. You can pass GL_VERTEX_SHADER, GL_GEOMETRY_SHADER_EXT, GL_FRAGMENT_SHADER</p>\n"},{"syntax":"getShaderSource(type)","name":"getShaderSource","returns":"string","returns_description":null,"parameters":"GLenum type","access":"public","version_started":"0.8.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>@brief returns the shader source as it was passed to the GLSL compiler</p>\n<p><strong>Parameters:</strong></p>\n<p>type (GL_VERTEX_SHADER | GL_FRAGMENT_SHADER | GL_GEOMETRY_SHADER_EXT) the shader source you'd like to inspect.</p>\n","desc":""},{"syntax":"getUniformBlockBinding(&name)","name":"getUniformBlockBinding","returns":"GLint","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>name","access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"getUniformBlockIndex(&name)","name":"getUniformBlockIndex","returns":"GLint","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>name","access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"getUniformLocation(&name)","name":"getUniformLocation","returns":"GLint","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>name","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"isLoaded()","name":"isLoaded","returns":"bool","returns_description":null,"parameters":null,"access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"linkProgram()","name":"linkProgram","returns":"bool","returns_description":null,"parameters":null,"access":"public","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Links program with all compiled shaders. This is more of an advanced use method, as this is done automatically for you.</p>\n"},{"syntax":"load(&shaderName)","name":"load","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> filesystem<span class=\"token operator\">::</span>path <span class=\"token operator\">&amp;</span>shaderName","access":"public","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>This assumes that your vertex and fragment shaders have the same name, i.e. &quot;dof.vert&quot; and &quot;dof.frag&quot; and loads them using just the name of the shader:</p>\n<pre><code>shader<span class=\"token punctuation\">.</span><span class=\"token function\">load</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>dof<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// assumes the shaders are in /data</span>\n</code></pre>\n"},{"syntax":"load(&vertName, &fragName, &geomName)","name":"load","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> filesystem<span class=\"token operator\">::</span>path <span class=\"token operator\">&amp;</span>vertName<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> filesystem<span class=\"token operator\">::</span>path <span class=\"token operator\">&amp;</span>fragName<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> filesystem<span class=\"token operator\">::</span>path <span class=\"token operator\">&amp;</span>geomName","access":"public","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Here you can load shaders with whatever names you choose. The geometry shader is optional, but the vertex and fragment shaders aren't.</p>\n<pre><code>shader<span class=\"token punctuation\">.</span><span class=\"token function\">load</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>dof<span class=\"token punctuation\">.</span>vert<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>dof<span class=\"token punctuation\">.</span>frag<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// assumes the shaders are in /data</span>\n</code></pre>\n"},{"syntax":"loadCompute(&shaderName)","name":"loadCompute","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> filesystem<span class=\"token operator\">::</span>path <span class=\"token operator\">&amp;</span>shaderName","access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"nameForType(type)","name":"nameForType","returns":"string","returns_description":null,"parameters":"GLenum type","access":"private","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"True","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"ofShader(&&shader)","name":"ofShader","returns":null,"returns_description":null,"parameters":"ofShader <span class=\"token operator\">&amp;&amp;</span>shader","access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"ofShader(&shader)","name":"ofShader","returns":null,"returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofShader <span class=\"token operator\">&amp;</span>shader","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"ofShader()","name":"ofShader","returns":null,"returns_description":null,"parameters":null,"access":"public","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"operator!=(&other)","name":"operator!=","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofShader <span class=\"token operator\">&amp;</span>other","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"operator=(&&shader)","name":"operator=","returns":"ofShader &","returns_description":null,"parameters":"ofShader <span class=\"token operator\">&amp;&amp;</span>shader","access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"operator=(&shader)","name":"operator=","returns":"ofShader &","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofShader <span class=\"token operator\">&amp;</span>shader","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"operator==(&other)","name":"operator==","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofShader <span class=\"token operator\">&amp;</span>other","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"short":"","desc":""},{"syntax":"parseForIncludes(&source, &sourceDirectoryPath)","name":"parseForIncludes","returns":"string","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>source<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> filesystem<span class=\"token operator\">::</span>path <span class=\"token operator\">&amp;</span>sourceDirectoryPath","access":"private","version_started":"0.8.0","version_deprecated":null,"summary":null,"constant":"False","static":"True","visible":"True","advanced":"False","desc":""},{"syntax":"printActiveAttributes()","name":"printActiveAttributes","returns":"void","returns_description":null,"parameters":null,"access":"public","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>This prints out all the active attributes to the console.</p>\n"},{"syntax":"printActiveUniformBlocks()","name":"printActiveUniformBlocks","returns":"void","returns_description":null,"parameters":null,"access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"printActiveUniforms()","name":"printActiveUniforms","returns":"void","returns_description":null,"parameters":null,"access":"public","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>This prints out all the active uniforms to the console.</p>\n"},{"syntax":"setAttribute1d(location, v1)","name":"setAttribute1d","returns":"void","returns_description":null,"parameters":"GLint location<span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> v1","access":"public","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Set one double attribute on the shader.\nAttributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.</p>\n"},{"syntax":"setAttribute1f(location, v1)","name":"setAttribute1f","returns":"void","returns_description":null,"parameters":"GLint location<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> v1","access":"public","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Set one float attributes on the shader.\nAttributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.</p>\n"},{"syntax":"setAttribute1fv(&name, *v, stride)","name":"setAttribute1fv","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">float</span> <span class=\"token operator\">*</span>v<span class=\"token punctuation\">,</span> GLsizei stride","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"setAttribute1s(location, v1)","name":"setAttribute1s","returns":"void","returns_description":null,"parameters":"GLint location<span class=\"token punctuation\">,</span> <span class=\"token keyword\">short</span> v1","access":"public","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Set a short attribute, a short int, on the shader.\nAttributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.</p>\n"},{"syntax":"setAttribute2d(location, v1, v2)","name":"setAttribute2d","returns":"void","returns_description":null,"parameters":"GLint location<span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> v1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> v2","access":"public","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Set two double attribute on the shader.\nAttributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.</p>\n"},{"syntax":"setAttribute2f(location, v1, v2)","name":"setAttribute2f","returns":"void","returns_description":null,"parameters":"GLint location<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> v1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> v2","access":"public","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Set two float attributes on the shader.\nAttributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.</p>\n"},{"syntax":"setAttribute2fv(&name, *v, stride)","name":"setAttribute2fv","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">float</span> <span class=\"token operator\">*</span>v<span class=\"token punctuation\">,</span> GLsizei stride","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"setAttribute2s(location, v1, v2)","name":"setAttribute2s","returns":"void","returns_description":null,"parameters":"GLint location<span class=\"token punctuation\">,</span> <span class=\"token keyword\">short</span> v1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">short</span> v2","access":"public","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Set two short attributes, a short int, on the shader.\nAttributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.</p>\n"},{"syntax":"setAttribute3d(location, v1, v2, v3)","name":"setAttribute3d","returns":"void","returns_description":null,"parameters":"GLint location<span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> v1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> v2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> v3","access":"public","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Set three double attribute on the shader.\nAttributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.</p>\n"},{"syntax":"setAttribute3f(location, v1, v2, v3)","name":"setAttribute3f","returns":"void","returns_description":null,"parameters":"GLint location<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> v1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> v2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> v3","access":"public","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Set three float attributes on the shader.\nAttributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.</p>\n"},{"syntax":"setAttribute3fv(&name, *v, stride)","name":"setAttribute3fv","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">float</span> <span class=\"token operator\">*</span>v<span class=\"token punctuation\">,</span> GLsizei stride","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"setAttribute3s(location, v1, v2, v3)","name":"setAttribute3s","returns":"void","returns_description":null,"parameters":"GLint location<span class=\"token punctuation\">,</span> <span class=\"token keyword\">short</span> v1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">short</span> v2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">short</span> v3","access":"public","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Set three short attributes, a short int, on the shader.\nAttributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.</p>\n"},{"syntax":"setAttribute4d(location, v1, v2, v3, v4)","name":"setAttribute4d","returns":"void","returns_description":null,"parameters":"GLint location<span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> v1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> v2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> v3<span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> v4","access":"public","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Set four double attribute on the shader.\nAttributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.</p>\n"},{"syntax":"setAttribute4f(location, v1, v2, v3, v4)","name":"setAttribute4f","returns":"void","returns_description":null,"parameters":"GLint location<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> v1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> v2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> v3<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> v4","access":"public","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Set four float attributes on the shader.\nAttributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.</p>\n"},{"syntax":"setAttribute4fv(&name, *v, stride)","name":"setAttribute4fv","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">float</span> <span class=\"token operator\">*</span>v<span class=\"token punctuation\">,</span> GLsizei stride","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"setAttribute4s(location, v1, v2, v3, v4)","name":"setAttribute4s","returns":"void","returns_description":null,"parameters":"GLint location<span class=\"token punctuation\">,</span> <span class=\"token keyword\">short</span> v1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">short</span> v2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">short</span> v3<span class=\"token punctuation\">,</span> <span class=\"token keyword\">short</span> v4","access":"public","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Set four short attributes, a short int, on the shader.\nAttributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.</p>\n"},{"syntax":"setConstantTemp(&name, &type, value)","name":"setConstantTemp","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>type<span class=\"token punctuation\">,</span> T value","access":"private","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"setDefineConstantTemp(&name, value)","name":"setDefineConstantTemp","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">,</span> T value","access":"private","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"setGeometryInputType(type)","name":"setGeometryInputType","returns":"void","returns_description":null,"parameters":"GLenum type","access":"public","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>You have to call this before linking the program with geometry shaders.\nPossible types are GL_POINTS, GL_LINES, GL_LINES_ADJACENCY_EXT, GL_TRIANGLES, GL_TRIANGLES_ADJACENCY_EXT</p>\n"},{"syntax":"setGeometryOutputCount(count)","name":"setGeometryOutputCount","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">int</span> count","access":"public","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>You have to call this before linking the program with geometry shaders to set the number of output vertices, For quads, this should be 4, for points 1. Triangle strips can use up to the maximum number. You can check the maximum number supported on your graphics cards with getGeometryMaxOutputCount()</p>\n"},{"syntax":"setGeometryOutputType(type)","name":"setGeometryOutputType","returns":"void","returns_description":null,"parameters":"GLenum type","access":"public","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>You have to call this before linking the program with geometry shaders.\ntype: GL_POINTS, GL_LINE_STRIP or GL_TRIANGLE_STRIP</p>\n"},{"syntax":"setUniform1f(&name, v1)","name":"setUniform1f","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> v1","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>set a float uniform on the shader</p>\n"},{"syntax":"setUniform1fv(&name, *v, count = 1)","name":"setUniform1fv","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">float</span> <span class=\"token operator\">*</span>v<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> count<span class=\"token operator\">=</span><span class=\"token number\">1</span>","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"setUniform1i(&name, v1)","name":"setUniform1i","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> v1","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"setUniform1iv(&name, *v, count = 1)","name":"setUniform1iv","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>v<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> count<span class=\"token operator\">=</span><span class=\"token number\">1</span>","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"setUniform2f(&name, &v)","name":"setUniform2f","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> glm<span class=\"token operator\">::</span>vec2 <span class=\"token operator\">&amp;</span>v","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"setUniform2f(&name, v1, v2)","name":"setUniform2f","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> v1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> v2","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"setUniform2fv(&name, *v, count = 1)","name":"setUniform2fv","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">float</span> <span class=\"token operator\">*</span>v<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> count<span class=\"token operator\">=</span><span class=\"token number\">1</span>","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>This allows you to set multiple vec2 uniforms.</p>\n<pre><code>vec2 v<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n"},{"syntax":"setUniform2i(&name, v1, v2)","name":"setUniform2i","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> v1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> v2","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"setUniform2iv(&name, *v, count = 1)","name":"setUniform2iv","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>v<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> count<span class=\"token operator\">=</span><span class=\"token number\">1</span>","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>set an array of uniform values on the shader using int[2] value. On the shader this looks like:</p>\n<pre><code>ivec2 iv<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n"},{"syntax":"setUniform3f(&name, &v)","name":"setUniform3f","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> glm<span class=\"token operator\">::</span>vec3 <span class=\"token operator\">&amp;</span>v","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"setUniform3f(&name, v1, v2, v3)","name":"setUniform3f","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> v1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> v2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> v3","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>set a vec3 uniform on the shader</p>\n"},{"syntax":"setUniform3fv(&name, *v, count = 1)","name":"setUniform3fv","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">float</span> <span class=\"token operator\">*</span>v<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> count<span class=\"token operator\">=</span><span class=\"token number\">1</span>","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>This allows you to set multiple vec3 uniforms.</p>\n<pre><code>vec3 v<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n"},{"syntax":"setUniform3i(&name, v1, v2, v3)","name":"setUniform3i","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> v1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> v2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> v3","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<pre><code>uniform ivec3 texture<span class=\"token punctuation\">;</span>\n</code></pre>\n"},{"syntax":"setUniform3iv(&name, *v, count = 1)","name":"setUniform3iv","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>v<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> count<span class=\"token operator\">=</span><span class=\"token number\">1</span>","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>set an array of uniform values on the shader using int[2] value. On the shader this looks like:</p>\n<pre><code>ivec3 iv<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n"},{"syntax":"setUniform4f(&name, &v)","name":"setUniform4f","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> glm<span class=\"token operator\">::</span>vec4 <span class=\"token operator\">&amp;</span>v","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"setUniform4f(&name, &v)","name":"setUniform4f","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> ofFloatColor <span class=\"token operator\">&amp;</span>v","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"setUniform4f(&name, v1, v2, v3, v4)","name":"setUniform4f","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> v1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> v2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> v3<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> v4","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>set a vec4 uniform on the shader</p>\n<pre><code>vec4 fv<span class=\"token punctuation\">;</span>\n</code></pre>\n"},{"syntax":"setUniform4fv(&name, *v, count = 1)","name":"setUniform4fv","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">float</span> <span class=\"token operator\">*</span>v<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> count<span class=\"token operator\">=</span><span class=\"token number\">1</span>","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>This allows you to set multiple vec4 uniforms.</p>\n<pre><code>vec4 v<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n"},{"syntax":"setUniform4i(&name, v1, v2, v3, v4)","name":"setUniform4i","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> v1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> v2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> v3<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> v4","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"setUniform4iv(&name, *v, count = 1)","name":"setUniform4iv","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>v<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> count<span class=\"token operator\">=</span><span class=\"token number\">1</span>","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>set an array of uniform values on the shader using int[2] value. On the shader this looks like:</p>\n<pre><code>ivec4 iv<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n"},{"syntax":"setUniformMatrix3f(&name, &m, count = 1)","name":"setUniformMatrix3f","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> glm<span class=\"token operator\">::</span>mat3 <span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> count<span class=\"token operator\">=</span><span class=\"token number\">1</span>","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"setUniformMatrix4f(&name, &m, count = 1)","name":"setUniformMatrix4f","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> glm<span class=\"token operator\">::</span>mat4 <span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> count<span class=\"token operator\">=</span><span class=\"token number\">1</span>","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"setUniformTexture(&name, &img, textureLocation)","name":"setUniformTexture","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> ofBaseHasTexture <span class=\"token operator\">&amp;</span>img<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> textureLocation","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>set a texture reference\nOn your shader it should look like this:</p>\n<pre><code>uniform sampler2DRect texture<span class=\"token punctuation\">;</span>\n</code></pre>\n"},{"syntax":"setUniformTexture(&name, &img, textureLocation)","name":"setUniformTexture","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> ofTexture <span class=\"token operator\">&amp;</span>img<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> textureLocation","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"setUniformTexture(&name, textureTarget, textureID, textureLocation)","name":"setUniformTexture","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> textureTarget<span class=\"token punctuation\">,</span> GLint textureID<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> textureLocation","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"setUniforms(&parameters)","name":"setUniforms","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofParameterGroup <span class=\"token operator\">&amp;</span>parameters","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"setup(&settings)","name":"setup","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofShaderSettings <span class=\"token operator\">&amp;</span>settings","access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"setup(&settings)","name":"setup","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofShader<span class=\"token operator\">::</span>TransformFeedbackSettings <span class=\"token operator\">&amp;</span>settings","access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"setupShaderFromFile(type, &filename)","name":"setupShaderFromFile","returns":"bool","returns_description":null,"parameters":"GLenum type<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> filesystem<span class=\"token operator\">::</span>path <span class=\"token operator\">&amp;</span>filename","access":"public","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>This are more of advanced use function and doesn't need.</p>\n"},{"syntax":"setupShaderFromSource(&&source)","name":"setupShaderFromSource","returns":"bool","returns_description":null,"parameters":"ofShader<span class=\"token operator\">::</span>Source <span class=\"token operator\">&amp;&amp;</span>source","access":"private","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"setupShaderFromSource(type, source, sourceDirectoryPath)","name":"setupShaderFromSource","returns":"bool","returns_description":null,"parameters":"GLenum type<span class=\"token punctuation\">,</span> string source<span class=\"token punctuation\">,</span> string sourceDirectoryPath","access":"public","version_started":"0.8.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>This method create and compile a shader from source.\nWorking with OpenGL 3 or OpenGL ES 2.0, remember to call bindDefaults() before linkProgram()</p>\n<p>Example of a simple shader to display a texture, using the ofGLProgrammableRenderer:</p>\n<pre><code>stringstream vertexSrc<span class=\"token punctuation\">;</span>\nvertexSrc <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>#version <span class=\"token number\">150</span>\\n<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\nvertexSrc <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>uniform mat4 modelViewProjectionMatrix<span class=\"token punctuation\">;</span>\\n<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\nvertexSrc  <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>in vec4 position<span class=\"token punctuation\">;</span>\\n<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\nvertexSrc  <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>in vec2 texcoord<span class=\"token punctuation\">;</span>\\n<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\nvertexSrc  <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>out vec2 texCoordVarying<span class=\"token punctuation\">;</span>\\n<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\nvertexSrc  <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\\n<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\nvertexSrc  <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>\\tgl_Position<span class=\"token operator\">=</span>modelViewProjectionMatrix<span class=\"token operator\">*</span>position<span class=\"token punctuation\">;</span>\\n<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\nvertexSrc  <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>\\ttexCoordVarying <span class=\"token operator\">=</span> texcoord<span class=\"token punctuation\">;</span>\\n<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\nvertexSrc  <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\\n<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n\nstringstream fragmentSrc<span class=\"token punctuation\">;</span>\nfragmentSrc <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>#version <span class=\"token number\">150</span>\\n<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\nfragmentSrc <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>uniform sampler2DRect tex0<span class=\"token punctuation\">;</span>\\n<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\nfragmentSrc <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>in vec2 texCoordVarying<span class=\"token punctuation\">;</span>\\n<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\nfragmentSrc <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>out vec4 outputColor<span class=\"token punctuation\">;</span>\\n<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\nfragmentSrc <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>uniform vec2 direction<span class=\"token punctuation\">;</span>\\n<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\nfragmentSrc <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\\n<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\nfragmentSrc <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>\\toutputColor <span class=\"token operator\">=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>tex0<span class=\"token punctuation\">,</span> texCoordVarying<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\\n<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\nfragmentSrc <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\\n<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n\nshader<span class=\"token punctuation\">.</span><span class=\"token function\">setupShaderFromSource</span><span class=\"token punctuation\">(</span> GL_VERTEX_SHADER<span class=\"token punctuation\">,</span> vertexSrc<span class=\"token punctuation\">.</span><span class=\"token function\">str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nshader<span class=\"token punctuation\">.</span><span class=\"token function\">setupShaderFromSource</span><span class=\"token punctuation\">(</span> GL_FRAGMENT_SHADER<span class=\"token punctuation\">,</span> fragmentSrc<span class=\"token punctuation\">.</span><span class=\"token function\">str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nshader<span class=\"token punctuation\">.</span><span class=\"token function\">bindDefaults</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nshader<span class=\"token punctuation\">.</span><span class=\"token function\">linkProgram</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n"},{"syntax":"sourceFromFile(type, &filename)","name":"sourceFromFile","returns":"ofShader::Source","returns_description":null,"parameters":"GLenum type<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> filesystem<span class=\"token operator\">::</span>path <span class=\"token operator\">&amp;</span>filename","access":"private","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"unload()","name":"unload","returns":"void","returns_description":null,"parameters":null,"access":"public","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>This unload the shader, which means that it will not be active on the graphics card any longer.</p>\n"},{"syntax":"~ofShader()","name":"~ofShader","returns":null,"returns_description":null,"parameters":null,"access":"public","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"short":"","desc":""},{"name":"bLoaded","type":"bool","access":"private","version_started":"007","version_deprecated":null,"summary":null,"visible":"True","constant":"True","advanced":"False","short":"","desc":""},{"name":"program","type":"GLuint","access":"private","version_started":"007","version_deprecated":null,"summary":null,"visible":"True","constant":"True","advanced":"False","short":"","desc":""},{"short":"","desc":""},{"name":"uniformBlocksCache","type":"int","access":"private","version_started":"0.10.0","version_deprecated":null,"summary":null,"visible":"True","constant":"False","advanced":"False","short":"","desc":""},{"short":"","desc":""},{}],"document":"<p>#class ofShader</p>\n<p>&lt;!--\n<em>visible: True</em>\n<em>advanced: False</em>\n<em>istemplated: False</em>\n_extends: _\n--&gt;</p>\n<p>##InlineDescription</p>\n<p>##Description</p>\n<p>Graphics Language Shading Language (GLSL) can be used in oF by using the ofShader object. Shading happens in two distinct steps: the vertex shader creates values for each vertex in the model, and the fragment shader creates values for each pixel in the rendered object. To define a shader, create a .frag file for the fragment shader and a .vert file for the vertex shader.\nA vertex shader has attributes about a location in space or vertex, which means not only the actual coordinates of that location but also its color, how any textures should be mapped onto it, and how the vertices are modified in the operation. A vertex shader can change the positions of each vertex, the number of lighting computations per vertex, and the color that will be applied to each vertex.\nA geometry shader can generate new graphics primitives like points, lines, and triangles, from those primitives that were sent to the graphics card from the CPU. This means that you could get a point and turn it into a triangle or even a bunch of triangles, or get a line and turn it into a rectangle, or do real-time extrusion. They are very powerful and can be quite tricky to get right, but they're becoming more popular.\nThe fragment shader is somewhat misleadingly named because what it really allows you to do is to change values assigned to each pixel. The vertex shader operates on the vertices, and the fragment shader operates on the pixels. By the time the fragment shader gets information passed into it by the graphics card, the color of a particular pixel has already been computed and in the fragment shader can be combined with an element like a lighting effecting, a fog effect, or a blur among many other options. The usual end result of this stage per fragment is a color value and a depth for the fragment.</p>\n<p>##Methods</p>\n<p>###void begin()</p>\n<p>&lt;!--\n<em>syntax: begin()</em>\n<em>name: begin</em>\n<em>returns: void</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>After you call begin() everything that you draw, vertexes and textures, in your of application have the effects of the shader applied to them.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void beginTransformFeedback(mode)</p>\n<p>&lt;!--\n<em>syntax: beginTransformFeedback(mode)</em>\n<em>name: beginTransformFeedback</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: GLenum mode</em>\n<em>access: public</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void beginTransformFeedback(mode, &amp;binding)</p>\n<p>&lt;!--\n<em>syntax: beginTransformFeedback(mode, &amp;binding)</em>\n<em>name: beginTransformFeedback</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: GLenum mode, const ofShader::TransformFeedbackRangeBinding &amp;binding</em>\n<em>access: public</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void beginTransformFeedback(mode, &amp;binding)</p>\n<p>&lt;!--\n<em>syntax: beginTransformFeedback(mode, &amp;binding)</em>\n<em>name: beginTransformFeedback</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: GLenum mode, const vector&lt; TransformFeedbackRangeBinding &gt; &amp;binding</em>\n<em>access: public</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void beginTransformFeedback(mode, &amp;binding)</p>\n<p>&lt;!--\n<em>syntax: beginTransformFeedback(mode, &amp;binding)</em>\n<em>name: beginTransformFeedback</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: GLenum mode, const ofShader::TransformFeedbackBaseBinding &amp;binding</em>\n<em>access: public</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void beginTransformFeedback(mode, &amp;binding)</p>\n<p>&lt;!--\n<em>syntax: beginTransformFeedback(mode, &amp;binding)</em>\n<em>name: beginTransformFeedback</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: GLenum mode, const vector&lt; TransformFeedbackBaseBinding &gt; &amp;binding</em>\n<em>access: public</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void bindAttribute(location, &amp;name)</p>\n<p>&lt;!--\n<em>syntax: bindAttribute(location, &amp;name)</em>\n<em>name: bindAttribute</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: GLuint location, const string &amp;name</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p><code>bindAttribute</code> is used for faster access to attributes. The idea is to set attributes by location (an integer) instead of querying attribute locations multiple times by name. This method is used internally by OF in <code>ofShader<span class=\"token operator\">::</span><span class=\"token function\">bindDefaults</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code> to set the default locations of the <code>position</code>, <code>color</code>, <code>normal</code> and <code>texcoord</code> attributes.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool bindDefaults()</p>\n<p>&lt;!--\n<em>syntax: bindDefaults()</em>\n<em>name: bindDefaults</em>\n<em>returns: bool</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Binds default uniforms and attributes, only useful for fixed pipeline simulation under programmable renderer.\nHas to be called before linkProgram().</p>\n<p>See setupShaderFromSource() example.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void bindUniformBlock(bindind, &amp;name)</p>\n<p>&lt;!--\n<em>syntax: bindUniformBlock(bindind, &amp;name)</em>\n<em>name: bindUniformBlock</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: GLuint bindind, const string &amp;name</em>\n<em>access: public</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void checkAndCreateProgram()</p>\n<p>&lt;!--\n<em>syntax: checkAndCreateProgram()</em>\n<em>name: checkAndCreateProgram</em>\n<em>returns: void</em>\n_returns_description: _\n_parameters: _\n<em>access: private</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void checkProgramInfoLog()</p>\n<p>&lt;!--\n<em>syntax: checkProgramInfoLog()</em>\n<em>name: checkProgramInfoLog</em>\n<em>returns: void</em>\n_returns_description: _\n_parameters: _\n<em>access: private</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool checkProgramLinkStatus()</p>\n<p>&lt;!--\n<em>syntax: checkProgramLinkStatus()</em>\n<em>name: checkProgramLinkStatus</em>\n<em>returns: bool</em>\n_returns_description: _\n_parameters: _\n<em>access: private</em>\n<em>version_started: 0071</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void checkShaderInfoLog(shader, type, logLevel)</p>\n<p>&lt;!--\n<em>syntax: checkShaderInfoLog(shader, type, logLevel)</em>\n<em>name: checkShaderInfoLog</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: GLuint shader, GLenum type, ofLogLevel logLevel</em>\n<em>access: private</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void dispatchCompute(x, y, z)</p>\n<p>&lt;!--\n<em>syntax: dispatchCompute(x, y, z)</em>\n<em>name: dispatchCompute</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: GLuint x, GLuint y, GLuint z</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void end()</p>\n<p>&lt;!--\n<em>syntax: end()</em>\n<em>name: end</em>\n<em>returns: void</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>After you call end() any drawing, vertexes and textures, do not have the effect of the shader applied to them.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void endTransformFeedback(&amp;binding)</p>\n<p>&lt;!--\n<em>syntax: endTransformFeedback(&amp;binding)</em>\n<em>name: endTransformFeedback</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const ofShader::TransformFeedbackRangeBinding &amp;binding</em>\n<em>access: public</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void endTransformFeedback(&amp;binding)</p>\n<p>&lt;!--\n<em>syntax: endTransformFeedback(&amp;binding)</em>\n<em>name: endTransformFeedback</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const vector&lt; TransformFeedbackRangeBinding &gt; &amp;binding</em>\n<em>access: public</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void endTransformFeedback(&amp;binding)</p>\n<p>&lt;!--\n<em>syntax: endTransformFeedback(&amp;binding)</em>\n<em>name: endTransformFeedback</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const ofShader::TransformFeedbackBaseBinding &amp;binding</em>\n<em>access: public</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void endTransformFeedback(&amp;binding)</p>\n<p>&lt;!--\n<em>syntax: endTransformFeedback(&amp;binding)</em>\n<em>name: endTransformFeedback</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const vector&lt; TransformFeedbackBaseBinding &gt; &amp;binding</em>\n<em>access: public</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void endTransformFeedback()</p>\n<p>&lt;!--\n<em>syntax: endTransformFeedback()</em>\n<em>name: endTransformFeedback</em>\n<em>returns: void</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###GLint getAttributeLocation(&amp;name)</p>\n<p>&lt;!--\n<em>syntax: getAttributeLocation(&amp;name)</em>\n<em>name: getAttributeLocation</em>\n<em>returns: GLint</em>\n_returns_description: _\n<em>parameters: const string &amp;name</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###int getGeometryMaxOutputCount()</p>\n<p>&lt;!--\n<em>syntax: getGeometryMaxOutputCount()</em>\n<em>name: getGeometryMaxOutputCount</em>\n<em>returns: int</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>returns maximum number of supported vertices for your graphics card</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###GLuint getProgram()</p>\n<p>&lt;!--\n<em>syntax: getProgram()</em>\n<em>name: getProgram</em>\n<em>returns: GLuint</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This returns the GLuint for the actual shader object that is active on the graphics card. This is more of an advanced usage method, but can be helpful if you need to do something that the ofShader doesn't support currently. This is all the shaders: vertex, geom, and frag.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###GLuint getShader(type)</p>\n<p>&lt;!--\n<em>syntax: getShader(type)</em>\n<em>name: getShader</em>\n<em>returns: GLuint</em>\n_returns_description: _\n<em>parameters: GLenum type</em>\n<em>access: public</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This returns the GLuint for the actual shader object that is active on the graphics card. This is more of an advanced usage method, but can be helpful if you need to do something that the ofShader doesn't support currently. This returns only one of the shaders. You can pass GL_VERTEX_SHADER, GL_GEOMETRY_SHADER_EXT, GL_FRAGMENT_SHADER</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###string getShaderSource(type)</p>\n<p>&lt;!--\n<em>syntax: getShaderSource(type)</em>\n<em>name: getShaderSource</em>\n<em>returns: string</em>\n_returns_description: _\n<em>parameters: GLenum type</em>\n<em>access: public</em>\n<em>version_started: 0.8.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>@brief returns the shader source as it was passed to the GLSL compiler</p>\n<p><strong>Parameters:</strong></p>\n<p>type (GL_VERTEX_SHADER | GL_FRAGMENT_SHADER | GL_GEOMETRY_SHADER_EXT) the shader source you'd like to inspect.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###GLint getUniformBlockBinding(&amp;name)</p>\n<p>&lt;!--\n<em>syntax: getUniformBlockBinding(&amp;name)</em>\n<em>name: getUniformBlockBinding</em>\n<em>returns: GLint</em>\n_returns_description: _\n<em>parameters: const string &amp;name</em>\n<em>access: public</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###GLint getUniformBlockIndex(&amp;name)</p>\n<p>&lt;!--\n<em>syntax: getUniformBlockIndex(&amp;name)</em>\n<em>name: getUniformBlockIndex</em>\n<em>returns: GLint</em>\n_returns_description: _\n<em>parameters: const string &amp;name</em>\n<em>access: public</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###GLint getUniformLocation(&amp;name)</p>\n<p>&lt;!--\n<em>syntax: getUniformLocation(&amp;name)</em>\n<em>name: getUniformLocation</em>\n<em>returns: GLint</em>\n_returns_description: _\n<em>parameters: const string &amp;name</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool isLoaded()</p>\n<p>&lt;!--\n<em>syntax: isLoaded()</em>\n<em>name: isLoaded</em>\n<em>returns: bool</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool linkProgram()</p>\n<p>&lt;!--\n<em>syntax: linkProgram()</em>\n<em>name: linkProgram</em>\n<em>returns: bool</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Links program with all compiled shaders. This is more of an advanced use method, as this is done automatically for you.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool load(&amp;shaderName)</p>\n<p>&lt;!--\n<em>syntax: load(&amp;shaderName)</em>\n<em>name: load</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: const filesystem::path &amp;shaderName</em>\n<em>access: public</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This assumes that your vertex and fragment shaders have the same name, i.e. &quot;dof.vert&quot; and &quot;dof.frag&quot; and loads them using just the name of the shader:</p>\n<pre><code>shader<span class=\"token punctuation\">.</span><span class=\"token function\">load</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>dof<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// assumes the shaders are in /data</span>\n</code></pre>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool load(&amp;vertName, &amp;fragName, &amp;geomName)</p>\n<p>&lt;!--\n<em>syntax: load(&amp;vertName, &amp;fragName, &amp;geomName)</em>\n<em>name: load</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: const filesystem::path &amp;vertName, const filesystem::path &amp;fragName, const filesystem::path &amp;geomName</em>\n<em>access: public</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Here you can load shaders with whatever names you choose. The geometry shader is optional, but the vertex and fragment shaders aren't.</p>\n<pre><code>shader<span class=\"token punctuation\">.</span><span class=\"token function\">load</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>dof<span class=\"token punctuation\">.</span>vert<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>dof<span class=\"token punctuation\">.</span>frag<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// assumes the shaders are in /data</span>\n</code></pre>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool loadCompute(&amp;shaderName)</p>\n<p>&lt;!--\n<em>syntax: loadCompute(&amp;shaderName)</em>\n<em>name: loadCompute</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: const filesystem::path &amp;shaderName</em>\n<em>access: public</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###string nameForType(type)</p>\n<p>&lt;!--\n<em>syntax: nameForType(type)</em>\n<em>name: nameForType</em>\n<em>returns: string</em>\n_returns_description: _\n<em>parameters: GLenum type</em>\n<em>access: private</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: True</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<h3>ofShader(&amp;&amp;shader)</h3>\n<p>&lt;!--\n<em>syntax: ofShader(&amp;&amp;shader)</em>\n<em>name: ofShader</em>\n_returns: _\n_returns_description: _\n<em>parameters: ofShader &amp;&amp;shader</em>\n<em>access: public</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<h3>ofShader(&amp;shader)</h3>\n<p>&lt;!--\n<em>syntax: ofShader(&amp;shader)</em>\n<em>name: ofShader</em>\n_returns: _\n_returns_description: _\n<em>parameters: const ofShader &amp;shader</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<h3>ofShader()</h3>\n<p>&lt;!--\n<em>syntax: ofShader()</em>\n<em>name: ofShader</em>\n_returns: _\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool operator!=(&amp;other)</p>\n<p>&lt;!--\n<em>syntax: operator!=(&amp;other)</em>\n<em>name: operator!=</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: const ofShader &amp;other</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###ofShader &amp; operator=(&amp;&amp;shader)</p>\n<p>&lt;!--\n<em>syntax: operator=(&amp;&amp;shader)</em>\n<em>name: operator=</em>\n<em>returns: ofShader &amp;</em>\n_returns_description: _\n<em>parameters: ofShader &amp;&amp;shader</em>\n<em>access: public</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###ofShader &amp; operator=(&amp;shader)</p>\n<p>&lt;!--\n<em>syntax: operator=(&amp;shader)</em>\n<em>name: operator=</em>\n<em>returns: ofShader &amp;</em>\n_returns_description: _\n<em>parameters: const ofShader &amp;shader</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool operator==(&amp;other)</p>\n<p>&lt;!--\n<em>syntax: operator==(&amp;other)</em>\n<em>name: operator==</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: const ofShader &amp;other</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###string parseForIncludes(&amp;source, &amp;included, level = 0, &amp;sourceDirectoryPath)</p>\n<p>&lt;!--\n<em>syntax: parseForIncludes(&amp;source, &amp;included, level = 0, &amp;sourceDirectoryPath)</em>\n<em>name: parseForIncludes</em>\n<em>returns: string</em>\n_returns_description: _\n<em>parameters: const string &amp;source, vector&lt; string &gt; &amp;included, int level=0, const filesystem::path &amp;sourceDirectoryPath</em>\n<em>access: private</em>\n<em>version_started: 0.8.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: True</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###string parseForIncludes(&amp;source, &amp;sourceDirectoryPath)</p>\n<p>&lt;!--\n<em>syntax: parseForIncludes(&amp;source, &amp;sourceDirectoryPath)</em>\n<em>name: parseForIncludes</em>\n<em>returns: string</em>\n_returns_description: _\n<em>parameters: const string &amp;source, const filesystem::path &amp;sourceDirectoryPath</em>\n<em>access: private</em>\n<em>version_started: 0.8.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: True</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>@brief\t\t\tMimics the #include behaviour of the c preprocessor\n@description\tIncludes files specified using the\n'#pragma include &lt;filepath&gt;' directive.\n@note\t\t\tInclude paths are always specified <em>relative to the including file's current path</em>\n@note\t\t\tRecursive #pragma include statements are possible\n@note\t\t\tIncludes will be processed up to 32 levels deep</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void printActiveAttributes()</p>\n<p>&lt;!--\n<em>syntax: printActiveAttributes()</em>\n<em>name: printActiveAttributes</em>\n<em>returns: void</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This prints out all the active attributes to the console.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void printActiveUniformBlocks()</p>\n<p>&lt;!--\n<em>syntax: printActiveUniformBlocks()</em>\n<em>name: printActiveUniformBlocks</em>\n<em>returns: void</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void printActiveUniforms()</p>\n<p>&lt;!--\n<em>syntax: printActiveUniforms()</em>\n<em>name: printActiveUniforms</em>\n<em>returns: void</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This prints out all the active uniforms to the console.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setAttribute1d(location, v1)</p>\n<p>&lt;!--\n<em>syntax: setAttribute1d(location, v1)</em>\n<em>name: setAttribute1d</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: GLint location, double v1</em>\n<em>access: public</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Set one double attribute on the shader.\nAttributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setAttribute1f(location, v1)</p>\n<p>&lt;!--\n<em>syntax: setAttribute1f(location, v1)</em>\n<em>name: setAttribute1f</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: GLint location, float v1</em>\n<em>access: public</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Set one float attributes on the shader.\nAttributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setAttribute1fv(&amp;name, *v, stride)</p>\n<p>&lt;!--\n<em>syntax: setAttribute1fv(&amp;name, *v, stride)</em>\n<em>name: setAttribute1fv</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const string &amp;name, const float *v, GLsizei stride</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setAttribute1s(location, v1)</p>\n<p>&lt;!--\n<em>syntax: setAttribute1s(location, v1)</em>\n<em>name: setAttribute1s</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: GLint location, short v1</em>\n<em>access: public</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Set a short attribute, a short int, on the shader.\nAttributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setAttribute2d(location, v1, v2)</p>\n<p>&lt;!--\n<em>syntax: setAttribute2d(location, v1, v2)</em>\n<em>name: setAttribute2d</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: GLint location, double v1, double v2</em>\n<em>access: public</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Set two double attribute on the shader.\nAttributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setAttribute2f(location, v1, v2)</p>\n<p>&lt;!--\n<em>syntax: setAttribute2f(location, v1, v2)</em>\n<em>name: setAttribute2f</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: GLint location, float v1, float v2</em>\n<em>access: public</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Set two float attributes on the shader.\nAttributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setAttribute2fv(&amp;name, *v, stride)</p>\n<p>&lt;!--\n<em>syntax: setAttribute2fv(&amp;name, *v, stride)</em>\n<em>name: setAttribute2fv</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const string &amp;name, const float *v, GLsizei stride</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setAttribute2s(location, v1, v2)</p>\n<p>&lt;!--\n<em>syntax: setAttribute2s(location, v1, v2)</em>\n<em>name: setAttribute2s</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: GLint location, short v1, short v2</em>\n<em>access: public</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Set two short attributes, a short int, on the shader.\nAttributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setAttribute3d(location, v1, v2, v3)</p>\n<p>&lt;!--\n<em>syntax: setAttribute3d(location, v1, v2, v3)</em>\n<em>name: setAttribute3d</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: GLint location, double v1, double v2, double v3</em>\n<em>access: public</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Set three double attribute on the shader.\nAttributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setAttribute3f(location, v1, v2, v3)</p>\n<p>&lt;!--\n<em>syntax: setAttribute3f(location, v1, v2, v3)</em>\n<em>name: setAttribute3f</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: GLint location, float v1, float v2, float v3</em>\n<em>access: public</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Set three float attributes on the shader.\nAttributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setAttribute3fv(&amp;name, *v, stride)</p>\n<p>&lt;!--\n<em>syntax: setAttribute3fv(&amp;name, *v, stride)</em>\n<em>name: setAttribute3fv</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const string &amp;name, const float *v, GLsizei stride</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setAttribute3s(location, v1, v2, v3)</p>\n<p>&lt;!--\n<em>syntax: setAttribute3s(location, v1, v2, v3)</em>\n<em>name: setAttribute3s</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: GLint location, short v1, short v2, short v3</em>\n<em>access: public</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Set three short attributes, a short int, on the shader.\nAttributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setAttribute4d(location, v1, v2, v3, v4)</p>\n<p>&lt;!--\n<em>syntax: setAttribute4d(location, v1, v2, v3, v4)</em>\n<em>name: setAttribute4d</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: GLint location, double v1, double v2, double v3, double v4</em>\n<em>access: public</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Set four double attribute on the shader.\nAttributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setAttribute4f(location, v1, v2, v3, v4)</p>\n<p>&lt;!--\n<em>syntax: setAttribute4f(location, v1, v2, v3, v4)</em>\n<em>name: setAttribute4f</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: GLint location, float v1, float v2, float v3, float v4</em>\n<em>access: public</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Set four float attributes on the shader.\nAttributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setAttribute4fv(&amp;name, *v, stride)</p>\n<p>&lt;!--\n<em>syntax: setAttribute4fv(&amp;name, *v, stride)</em>\n<em>name: setAttribute4fv</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const string &amp;name, const float *v, GLsizei stride</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setAttribute4s(location, v1, v2, v3, v4)</p>\n<p>&lt;!--\n<em>syntax: setAttribute4s(location, v1, v2, v3, v4)</em>\n<em>name: setAttribute4s</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: GLint location, short v1, short v2, short v3, short v4</em>\n<em>access: public</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Set four short attributes, a short int, on the shader.\nAttributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setConstantTemp(&amp;name, &amp;type, value)</p>\n<p>&lt;!--\n<em>syntax: setConstantTemp(&amp;name, &amp;type, value)</em>\n<em>name: setConstantTemp</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const string &amp;name, const string &amp;type, T value</em>\n<em>access: private</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setDefineConstantTemp(&amp;name, value)</p>\n<p>&lt;!--\n<em>syntax: setDefineConstantTemp(&amp;name, value)</em>\n<em>name: setDefineConstantTemp</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const string &amp;name, T value</em>\n<em>access: private</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setGeometryInputType(type)</p>\n<p>&lt;!--\n<em>syntax: setGeometryInputType(type)</em>\n<em>name: setGeometryInputType</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: GLenum type</em>\n<em>access: public</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>You have to call this before linking the program with geometry shaders.\nPossible types are GL_POINTS, GL_LINES, GL_LINES_ADJACENCY_EXT, GL_TRIANGLES, GL_TRIANGLES_ADJACENCY_EXT</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setGeometryOutputCount(count)</p>\n<p>&lt;!--\n<em>syntax: setGeometryOutputCount(count)</em>\n<em>name: setGeometryOutputCount</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: int count</em>\n<em>access: public</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>You have to call this before linking the program with geometry shaders to set the number of output vertices, For quads, this should be 4, for points 1. Triangle strips can use up to the maximum number. You can check the maximum number supported on your graphics cards with getGeometryMaxOutputCount()</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setGeometryOutputType(type)</p>\n<p>&lt;!--\n<em>syntax: setGeometryOutputType(type)</em>\n<em>name: setGeometryOutputType</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: GLenum type</em>\n<em>access: public</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>You have to call this before linking the program with geometry shaders.\ntype: GL_POINTS, GL_LINE_STRIP or GL_TRIANGLE_STRIP</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setUniform1f(&amp;name, v1)</p>\n<p>&lt;!--\n<em>syntax: setUniform1f(&amp;name, v1)</em>\n<em>name: setUniform1f</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const string &amp;name, float v1</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>set a float uniform on the shader</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setUniform1fv(&amp;name, *v, count = 1)</p>\n<p>&lt;!--\n<em>syntax: setUniform1fv(&amp;name, *v, count = 1)</em>\n<em>name: setUniform1fv</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const string &amp;name, const float *v, int count=1</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setUniform1i(&amp;name, v1)</p>\n<p>&lt;!--\n<em>syntax: setUniform1i(&amp;name, v1)</em>\n<em>name: setUniform1i</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const string &amp;name, int v1</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setUniform1iv(&amp;name, *v, count = 1)</p>\n<p>&lt;!--\n<em>syntax: setUniform1iv(&amp;name, *v, count = 1)</em>\n<em>name: setUniform1iv</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const string &amp;name, const int *v, int count=1</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setUniform2f(&amp;name, &amp;v)</p>\n<p>&lt;!--\n<em>syntax: setUniform2f(&amp;name, &amp;v)</em>\n<em>name: setUniform2f</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const string &amp;name, const glm::vec2 &amp;v</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setUniform2f(&amp;name, v1, v2)</p>\n<p>&lt;!--\n<em>syntax: setUniform2f(&amp;name, v1, v2)</em>\n<em>name: setUniform2f</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const string &amp;name, float v1, float v2</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setUniform2fv(&amp;name, *v, count = 1)</p>\n<p>&lt;!--\n<em>syntax: setUniform2fv(&amp;name, *v, count = 1)</em>\n<em>name: setUniform2fv</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const string &amp;name, const float *v, int count=1</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This allows you to set multiple vec2 uniforms.</p>\n<pre><code>vec2 v<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setUniform2i(&amp;name, v1, v2)</p>\n<p>&lt;!--\n<em>syntax: setUniform2i(&amp;name, v1, v2)</em>\n<em>name: setUniform2i</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const string &amp;name, int v1, int v2</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setUniform2iv(&amp;name, *v, count = 1)</p>\n<p>&lt;!--\n<em>syntax: setUniform2iv(&amp;name, *v, count = 1)</em>\n<em>name: setUniform2iv</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const string &amp;name, const int *v, int count=1</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>set an array of uniform values on the shader using int[2] value. On the shader this looks like:</p>\n<pre><code>ivec2 iv<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setUniform3f(&amp;name, &amp;v)</p>\n<p>&lt;!--\n<em>syntax: setUniform3f(&amp;name, &amp;v)</em>\n<em>name: setUniform3f</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const string &amp;name, const glm::vec3 &amp;v</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setUniform3f(&amp;name, v1, v2, v3)</p>\n<p>&lt;!--\n<em>syntax: setUniform3f(&amp;name, v1, v2, v3)</em>\n<em>name: setUniform3f</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const string &amp;name, float v1, float v2, float v3</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>set a vec3 uniform on the shader</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setUniform3fv(&amp;name, *v, count = 1)</p>\n<p>&lt;!--\n<em>syntax: setUniform3fv(&amp;name, *v, count = 1)</em>\n<em>name: setUniform3fv</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const string &amp;name, const float *v, int count=1</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This allows you to set multiple vec3 uniforms.</p>\n<pre><code>vec3 v<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setUniform3i(&amp;name, v1, v2, v3)</p>\n<p>&lt;!--\n<em>syntax: setUniform3i(&amp;name, v1, v2, v3)</em>\n<em>name: setUniform3i</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const string &amp;name, int v1, int v2, int v3</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<pre><code>uniform ivec3 texture<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setUniform3iv(&amp;name, *v, count = 1)</p>\n<p>&lt;!--\n<em>syntax: setUniform3iv(&amp;name, *v, count = 1)</em>\n<em>name: setUniform3iv</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const string &amp;name, const int *v, int count=1</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>set an array of uniform values on the shader using int[2] value. On the shader this looks like:</p>\n<pre><code>ivec3 iv<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setUniform4f(&amp;name, &amp;v)</p>\n<p>&lt;!--\n<em>syntax: setUniform4f(&amp;name, &amp;v)</em>\n<em>name: setUniform4f</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const string &amp;name, const glm::vec4 &amp;v</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setUniform4f(&amp;name, &amp;v)</p>\n<p>&lt;!--\n<em>syntax: setUniform4f(&amp;name, &amp;v)</em>\n<em>name: setUniform4f</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const string &amp;name, const ofFloatColor &amp;v</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setUniform4f(&amp;name, v1, v2, v3, v4)</p>\n<p>&lt;!--\n<em>syntax: setUniform4f(&amp;name, v1, v2, v3, v4)</em>\n<em>name: setUniform4f</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const string &amp;name, float v1, float v2, float v3, float v4</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>set a vec4 uniform on the shader</p>\n<pre><code>vec4 fv<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setUniform4fv(&amp;name, *v, count = 1)</p>\n<p>&lt;!--\n<em>syntax: setUniform4fv(&amp;name, *v, count = 1)</em>\n<em>name: setUniform4fv</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const string &amp;name, const float *v, int count=1</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This allows you to set multiple vec4 uniforms.</p>\n<pre><code>vec4 v<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setUniform4i(&amp;name, v1, v2, v3, v4)</p>\n<p>&lt;!--\n<em>syntax: setUniform4i(&amp;name, v1, v2, v3, v4)</em>\n<em>name: setUniform4i</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const string &amp;name, int v1, int v2, int v3, int v4</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setUniform4iv(&amp;name, *v, count = 1)</p>\n<p>&lt;!--\n<em>syntax: setUniform4iv(&amp;name, *v, count = 1)</em>\n<em>name: setUniform4iv</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const string &amp;name, const int *v, int count=1</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>set an array of uniform values on the shader using int[2] value. On the shader this looks like:</p>\n<pre><code>ivec4 iv<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setUniformMatrix3f(&amp;name, &amp;m, count = 1)</p>\n<p>&lt;!--\n<em>syntax: setUniformMatrix3f(&amp;name, &amp;m, count = 1)</em>\n<em>name: setUniformMatrix3f</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const string &amp;name, const glm::mat3 &amp;m, int count=1</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setUniformMatrix4f(&amp;name, &amp;m, count = 1)</p>\n<p>&lt;!--\n<em>syntax: setUniformMatrix4f(&amp;name, &amp;m, count = 1)</em>\n<em>name: setUniformMatrix4f</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const string &amp;name, const glm::mat4 &amp;m, int count=1</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setUniformTexture(&amp;name, &amp;img, textureLocation)</p>\n<p>&lt;!--\n<em>syntax: setUniformTexture(&amp;name, &amp;img, textureLocation)</em>\n<em>name: setUniformTexture</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const string &amp;name, const ofBaseHasTexture &amp;img, int textureLocation</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>set a texture reference\nOn your shader it should look like this:</p>\n<pre><code>uniform sampler2DRect texture<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setUniformTexture(&amp;name, &amp;img, textureLocation)</p>\n<p>&lt;!--\n<em>syntax: setUniformTexture(&amp;name, &amp;img, textureLocation)</em>\n<em>name: setUniformTexture</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const string &amp;name, const ofTexture &amp;img, int textureLocation</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setUniformTexture(&amp;name, textureTarget, textureID, textureLocation)</p>\n<p>&lt;!--\n<em>syntax: setUniformTexture(&amp;name, textureTarget, textureID, textureLocation)</em>\n<em>name: setUniformTexture</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const string &amp;name, int textureTarget, GLint textureID, int textureLocation</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setUniforms(&amp;parameters)</p>\n<p>&lt;!--\n<em>syntax: setUniforms(&amp;parameters)</em>\n<em>name: setUniforms</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const ofParameterGroup &amp;parameters</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool setup(&amp;settings)</p>\n<p>&lt;!--\n<em>syntax: setup(&amp;settings)</em>\n<em>name: setup</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: const ofShaderSettings &amp;settings</em>\n<em>access: public</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool setup(&amp;settings)</p>\n<p>&lt;!--\n<em>syntax: setup(&amp;settings)</em>\n<em>name: setup</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: const ofShader::TransformFeedbackSettings &amp;settings</em>\n<em>access: public</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool setupShaderFromFile(type, &amp;filename)</p>\n<p>&lt;!--\n<em>syntax: setupShaderFromFile(type, &amp;filename)</em>\n<em>name: setupShaderFromFile</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: GLenum type, const filesystem::path &amp;filename</em>\n<em>access: public</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This are more of advanced use function and doesn't need.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool setupShaderFromSource(&amp;&amp;source)</p>\n<p>&lt;!--\n<em>syntax: setupShaderFromSource(&amp;&amp;source)</em>\n<em>name: setupShaderFromSource</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: ofShader::Source &amp;&amp;source</em>\n<em>access: private</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool setupShaderFromSource(type, source, sourceDirectoryPath)</p>\n<p>&lt;!--\n<em>syntax: setupShaderFromSource(type, source, sourceDirectoryPath)</em>\n<em>name: setupShaderFromSource</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: GLenum type, string source, string sourceDirectoryPath</em>\n<em>access: public</em>\n<em>version_started: 0.8.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This method create and compile a shader from source.\nWorking with OpenGL 3 or OpenGL ES 2.0, remember to call bindDefaults() before linkProgram()</p>\n<p>Example of a simple shader to display a texture, using the ofGLProgrammableRenderer:</p>\n<pre><code>stringstream vertexSrc<span class=\"token punctuation\">;</span>\nvertexSrc <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>#version <span class=\"token number\">150</span>\\n<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\nvertexSrc <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>uniform mat4 modelViewProjectionMatrix<span class=\"token punctuation\">;</span>\\n<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\nvertexSrc  <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>in vec4 position<span class=\"token punctuation\">;</span>\\n<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\nvertexSrc  <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>in vec2 texcoord<span class=\"token punctuation\">;</span>\\n<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\nvertexSrc  <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>out vec2 texCoordVarying<span class=\"token punctuation\">;</span>\\n<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\nvertexSrc  <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\\n<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\nvertexSrc  <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>\\tgl_Position<span class=\"token operator\">=</span>modelViewProjectionMatrix<span class=\"token operator\">*</span>position<span class=\"token punctuation\">;</span>\\n<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\nvertexSrc  <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>\\ttexCoordVarying <span class=\"token operator\">=</span> texcoord<span class=\"token punctuation\">;</span>\\n<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\nvertexSrc  <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\\n<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n\nstringstream fragmentSrc<span class=\"token punctuation\">;</span>\nfragmentSrc <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>#version <span class=\"token number\">150</span>\\n<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\nfragmentSrc <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>uniform sampler2DRect tex0<span class=\"token punctuation\">;</span>\\n<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\nfragmentSrc <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>in vec2 texCoordVarying<span class=\"token punctuation\">;</span>\\n<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\nfragmentSrc <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>out vec4 outputColor<span class=\"token punctuation\">;</span>\\n<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\nfragmentSrc <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>uniform vec2 direction<span class=\"token punctuation\">;</span>\\n<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\nfragmentSrc <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\\n<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\nfragmentSrc <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>\\toutputColor <span class=\"token operator\">=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>tex0<span class=\"token punctuation\">,</span> texCoordVarying<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\\n<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\nfragmentSrc <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\\n<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n\nshader<span class=\"token punctuation\">.</span><span class=\"token function\">setupShaderFromSource</span><span class=\"token punctuation\">(</span> GL_VERTEX_SHADER<span class=\"token punctuation\">,</span> vertexSrc<span class=\"token punctuation\">.</span><span class=\"token function\">str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nshader<span class=\"token punctuation\">.</span><span class=\"token function\">setupShaderFromSource</span><span class=\"token punctuation\">(</span> GL_FRAGMENT_SHADER<span class=\"token punctuation\">,</span> fragmentSrc<span class=\"token punctuation\">.</span><span class=\"token function\">str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nshader<span class=\"token punctuation\">.</span><span class=\"token function\">bindDefaults</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nshader<span class=\"token punctuation\">.</span><span class=\"token function\">linkProgram</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###ofShader::Source sourceFromFile(type, &amp;filename)</p>\n<p>&lt;!--\n<em>syntax: sourceFromFile(type, &amp;filename)</em>\n<em>name: sourceFromFile</em>\n<em>returns: ofShader::Source</em>\n_returns_description: _\n<em>parameters: GLenum type, const filesystem::path &amp;filename</em>\n<em>access: private</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void unload()</p>\n<p>&lt;!--\n<em>syntax: unload()</em>\n<em>name: unload</em>\n<em>returns: void</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This unload the shader, which means that it will not be active on the graphics card any longer.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<h3>~ofShader()</h3>\n<p>&lt;!--\n<em>syntax: ~ofShader()</em>\n<em>name: ~ofShader</em>\n_returns: _\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>##Variables</p>\n<p>###unordered_map&lt; string, GLint &gt; attributesBindingsCache</p>\n<p>&lt;!--\n<em>name: attributesBindingsCache</em>\n<em>type: unordered_map&lt; string, GLint &gt;</em>\n<em>access: private</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>visible: True</em>\n<em>constant: False</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool bLoaded</p>\n<p>&lt;!--\n<em>name: bLoaded</em>\n<em>type: bool</em>\n<em>access: private</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>visible: True</em>\n<em>constant: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###GLuint program</p>\n<p>&lt;!--\n<em>name: program</em>\n<em>type: GLuint</em>\n<em>access: private</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>visible: True</em>\n<em>constant: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###map&lt; GLenum, GLuint &gt; shaders</p>\n<p>&lt;!--\n<em>name: shaders</em>\n<em>type: map&lt; GLenum, GLuint &gt;</em>\n<em>access: private</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>visible: True</em>\n<em>constant: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###int uniformBlocksCache</p>\n<p>&lt;!--\n<em>name: uniformBlocksCache</em>\n<em>type: int</em>\n<em>access: private</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>visible: True</em>\n<em>constant: False</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###unordered_map&lt; string, GLint &gt; uniformsCache</p>\n<p>&lt;!--\n<em>name: uniformsCache</em>\n<em>type: unordered_map&lt; string, GLint &gt;</em>\n<em>access: private</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>visible: True</em>\n<em>constant: False</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n","raw":"#class ofShader\n\n\n<!--\n_visible: True_\n_advanced: False_\n_istemplated: False_\n_extends: _\n-->\n\n##InlineDescription\n\n\n\n\n\n\n##Description\n\nGraphics Language Shading Language (GLSL) can be used in oF by using the ofShader object. Shading happens in two distinct steps: the vertex shader creates values for each vertex in the model, and the fragment shader creates values for each pixel in the rendered object. To define a shader, create a .frag file for the fragment shader and a .vert file for the vertex shader.\nA vertex shader has attributes about a location in space or vertex, which means not only the actual coordinates of that location but also its color, how any textures should be mapped onto it, and how the vertices are modified in the operation. A vertex shader can change the positions of each vertex, the number of lighting computations per vertex, and the color that will be applied to each vertex.\nA geometry shader can generate new graphics primitives like points, lines, and triangles, from those primitives that were sent to the graphics card from the CPU. This means that you could get a point and turn it into a triangle or even a bunch of triangles, or get a line and turn it into a rectangle, or do real-time extrusion. They are very powerful and can be quite tricky to get right, but they're becoming more popular.\nThe fragment shader is somewhat misleadingly named because what it really allows you to do is to change values assigned to each pixel. The vertex shader operates on the vertices, and the fragment shader operates on the pixels. By the time the fragment shader gets information passed into it by the graphics card, the color of a particular pixel has already been computed and in the fragment shader can be combined with an element like a lighting effecting, a fog effect, or a blur among many other options. The usual end result of this stage per fragment is a color value and a depth for the fragment.\n\n\n\n\n\n##Methods\n\n\n\n###void begin()\n\n<!--\n_syntax: begin()_\n_name: begin_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nAfter you call begin() everything that you draw, vertexes and textures, in your of application have the effects of the shader applied to them.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void beginTransformFeedback(mode)\n\n<!--\n_syntax: beginTransformFeedback(mode)_\n_name: beginTransformFeedback_\n_returns: void_\n_returns_description: _\n_parameters: GLenum mode_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void beginTransformFeedback(mode, &binding)\n\n<!--\n_syntax: beginTransformFeedback(mode, &binding)_\n_name: beginTransformFeedback_\n_returns: void_\n_returns_description: _\n_parameters: GLenum mode, const ofShader::TransformFeedbackRangeBinding &binding_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void beginTransformFeedback(mode, &binding)\n\n<!--\n_syntax: beginTransformFeedback(mode, &binding)_\n_name: beginTransformFeedback_\n_returns: void_\n_returns_description: _\n_parameters: GLenum mode, const vector< TransformFeedbackRangeBinding > &binding_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void beginTransformFeedback(mode, &binding)\n\n<!--\n_syntax: beginTransformFeedback(mode, &binding)_\n_name: beginTransformFeedback_\n_returns: void_\n_returns_description: _\n_parameters: GLenum mode, const ofShader::TransformFeedbackBaseBinding &binding_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void beginTransformFeedback(mode, &binding)\n\n<!--\n_syntax: beginTransformFeedback(mode, &binding)_\n_name: beginTransformFeedback_\n_returns: void_\n_returns_description: _\n_parameters: GLenum mode, const vector< TransformFeedbackBaseBinding > &binding_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void bindAttribute(location, &name)\n\n<!--\n_syntax: bindAttribute(location, &name)_\n_name: bindAttribute_\n_returns: void_\n_returns_description: _\n_parameters: GLuint location, const string &name_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n`bindAttribute` is used for faster access to attributes. The idea is to set attributes by location (an integer) instead of querying attribute locations multiple times by name. This method is used internally by OF in `ofShader::bindDefaults()` to set the default locations of the `position`, `color`, `normal` and `texcoord` attributes.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool bindDefaults()\n\n<!--\n_syntax: bindDefaults()_\n_name: bindDefaults_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nBinds default uniforms and attributes, only useful for fixed pipeline simulation under programmable renderer.\nHas to be called before linkProgram().\n\nSee setupShaderFromSource() example.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void bindUniformBlock(bindind, &name)\n\n<!--\n_syntax: bindUniformBlock(bindind, &name)_\n_name: bindUniformBlock_\n_returns: void_\n_returns_description: _\n_parameters: GLuint bindind, const string &name_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void checkAndCreateProgram()\n\n<!--\n_syntax: checkAndCreateProgram()_\n_name: checkAndCreateProgram_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: private_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void checkProgramInfoLog()\n\n<!--\n_syntax: checkProgramInfoLog()_\n_name: checkProgramInfoLog_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: private_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool checkProgramLinkStatus()\n\n<!--\n_syntax: checkProgramLinkStatus()_\n_name: checkProgramLinkStatus_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: private_\n_version_started: 0071_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void checkShaderInfoLog(shader, type, logLevel)\n\n<!--\n_syntax: checkShaderInfoLog(shader, type, logLevel)_\n_name: checkShaderInfoLog_\n_returns: void_\n_returns_description: _\n_parameters: GLuint shader, GLenum type, ofLogLevel logLevel_\n_access: private_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void dispatchCompute(x, y, z)\n\n<!--\n_syntax: dispatchCompute(x, y, z)_\n_name: dispatchCompute_\n_returns: void_\n_returns_description: _\n_parameters: GLuint x, GLuint y, GLuint z_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void end()\n\n<!--\n_syntax: end()_\n_name: end_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nAfter you call end() any drawing, vertexes and textures, do not have the effect of the shader applied to them.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void endTransformFeedback(&binding)\n\n<!--\n_syntax: endTransformFeedback(&binding)_\n_name: endTransformFeedback_\n_returns: void_\n_returns_description: _\n_parameters: const ofShader::TransformFeedbackRangeBinding &binding_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void endTransformFeedback(&binding)\n\n<!--\n_syntax: endTransformFeedback(&binding)_\n_name: endTransformFeedback_\n_returns: void_\n_returns_description: _\n_parameters: const vector< TransformFeedbackRangeBinding > &binding_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void endTransformFeedback(&binding)\n\n<!--\n_syntax: endTransformFeedback(&binding)_\n_name: endTransformFeedback_\n_returns: void_\n_returns_description: _\n_parameters: const ofShader::TransformFeedbackBaseBinding &binding_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void endTransformFeedback(&binding)\n\n<!--\n_syntax: endTransformFeedback(&binding)_\n_name: endTransformFeedback_\n_returns: void_\n_returns_description: _\n_parameters: const vector< TransformFeedbackBaseBinding > &binding_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void endTransformFeedback()\n\n<!--\n_syntax: endTransformFeedback()_\n_name: endTransformFeedback_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###GLint getAttributeLocation(&name)\n\n<!--\n_syntax: getAttributeLocation(&name)_\n_name: getAttributeLocation_\n_returns: GLint_\n_returns_description: _\n_parameters: const string &name_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###int getGeometryMaxOutputCount()\n\n<!--\n_syntax: getGeometryMaxOutputCount()_\n_name: getGeometryMaxOutputCount_\n_returns: int_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nreturns maximum number of supported vertices for your graphics card\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###GLuint getProgram()\n\n<!--\n_syntax: getProgram()_\n_name: getProgram_\n_returns: GLuint_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis returns the GLuint for the actual shader object that is active on the graphics card. This is more of an advanced usage method, but can be helpful if you need to do something that the ofShader doesn't support currently. This is all the shaders: vertex, geom, and frag.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###GLuint getShader(type)\n\n<!--\n_syntax: getShader(type)_\n_name: getShader_\n_returns: GLuint_\n_returns_description: _\n_parameters: GLenum type_\n_access: public_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis returns the GLuint for the actual shader object that is active on the graphics card. This is more of an advanced usage method, but can be helpful if you need to do something that the ofShader doesn't support currently. This returns only one of the shaders. You can pass GL_VERTEX_SHADER, GL_GEOMETRY_SHADER_EXT, GL_FRAGMENT_SHADER\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###string getShaderSource(type)\n\n<!--\n_syntax: getShaderSource(type)_\n_name: getShaderSource_\n_returns: string_\n_returns_description: _\n_parameters: GLenum type_\n_access: public_\n_version_started: 0.8.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n@brief returns the shader source as it was passed to the GLSL compiler\n\n**Parameters:**\n\ntype (GL_VERTEX_SHADER | GL_FRAGMENT_SHADER | GL_GEOMETRY_SHADER_EXT) the shader source you'd like to inspect.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###GLint getUniformBlockBinding(&name)\n\n<!--\n_syntax: getUniformBlockBinding(&name)_\n_name: getUniformBlockBinding_\n_returns: GLint_\n_returns_description: _\n_parameters: const string &name_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###GLint getUniformBlockIndex(&name)\n\n<!--\n_syntax: getUniformBlockIndex(&name)_\n_name: getUniformBlockIndex_\n_returns: GLint_\n_returns_description: _\n_parameters: const string &name_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###GLint getUniformLocation(&name)\n\n<!--\n_syntax: getUniformLocation(&name)_\n_name: getUniformLocation_\n_returns: GLint_\n_returns_description: _\n_parameters: const string &name_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool isLoaded()\n\n<!--\n_syntax: isLoaded()_\n_name: isLoaded_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool linkProgram()\n\n<!--\n_syntax: linkProgram()_\n_name: linkProgram_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nLinks program with all compiled shaders. This is more of an advanced use method, as this is done automatically for you.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool load(&shaderName)\n\n<!--\n_syntax: load(&shaderName)_\n_name: load_\n_returns: bool_\n_returns_description: _\n_parameters: const filesystem::path &shaderName_\n_access: public_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis assumes that your vertex and fragment shaders have the same name, i.e. \"dof.vert\" and \"dof.frag\" and loads them using just the name of the shader:\n\n~~~~{.cpp}\nshader.load(\"dof\"); // assumes the shaders are in /data\n~~~~\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool load(&vertName, &fragName, &geomName)\n\n<!--\n_syntax: load(&vertName, &fragName, &geomName)_\n_name: load_\n_returns: bool_\n_returns_description: _\n_parameters: const filesystem::path &vertName, const filesystem::path &fragName, const filesystem::path &geomName_\n_access: public_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nHere you can load shaders with whatever names you choose. The geometry shader is optional, but the vertex and fragment shaders aren't.\n\n~~~~{.cpp}\nshader.load(\"dof.vert\", \"dof.frag\"); // assumes the shaders are in /data\n~~~~\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool loadCompute(&shaderName)\n\n<!--\n_syntax: loadCompute(&shaderName)_\n_name: loadCompute_\n_returns: bool_\n_returns_description: _\n_parameters: const filesystem::path &shaderName_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###string nameForType(type)\n\n<!--\n_syntax: nameForType(type)_\n_name: nameForType_\n_returns: string_\n_returns_description: _\n_parameters: GLenum type_\n_access: private_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: True_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n### ofShader(&&shader)\n\n<!--\n_syntax: ofShader(&&shader)_\n_name: ofShader_\n_returns: _\n_returns_description: _\n_parameters: ofShader &&shader_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n### ofShader(&shader)\n\n<!--\n_syntax: ofShader(&shader)_\n_name: ofShader_\n_returns: _\n_returns_description: _\n_parameters: const ofShader &shader_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n### ofShader()\n\n<!--\n_syntax: ofShader()_\n_name: ofShader_\n_returns: _\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool operator!=(&other)\n\n<!--\n_syntax: operator!=(&other)_\n_name: operator!=_\n_returns: bool_\n_returns_description: _\n_parameters: const ofShader &other_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###ofShader & operator=(&&shader)\n\n<!--\n_syntax: operator=(&&shader)_\n_name: operator=_\n_returns: ofShader &_\n_returns_description: _\n_parameters: ofShader &&shader_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###ofShader & operator=(&shader)\n\n<!--\n_syntax: operator=(&shader)_\n_name: operator=_\n_returns: ofShader &_\n_returns_description: _\n_parameters: const ofShader &shader_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool operator==(&other)\n\n<!--\n_syntax: operator==(&other)_\n_name: operator==_\n_returns: bool_\n_returns_description: _\n_parameters: const ofShader &other_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###string parseForIncludes(&source, &included, level = 0, &sourceDirectoryPath)\n\n<!--\n_syntax: parseForIncludes(&source, &included, level = 0, &sourceDirectoryPath)_\n_name: parseForIncludes_\n_returns: string_\n_returns_description: _\n_parameters: const string &source, vector< string > &included, int level=0, const filesystem::path &sourceDirectoryPath_\n_access: private_\n_version_started: 0.8.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: True_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###string parseForIncludes(&source, &sourceDirectoryPath)\n\n<!--\n_syntax: parseForIncludes(&source, &sourceDirectoryPath)_\n_name: parseForIncludes_\n_returns: string_\n_returns_description: _\n_parameters: const string &source, const filesystem::path &sourceDirectoryPath_\n_access: private_\n_version_started: 0.8.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: True_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n@brief\t\t\tMimics the #include behaviour of the c preprocessor\n@description\tIncludes files specified using the\n\t\t\t\t\t'#pragma include <filepath>' directive.\n@note\t\t\tInclude paths are always specified _relative to the including file's current path_\n\t@note\t\t\tRecursive #pragma include statements are possible\n@note\t\t\tIncludes will be processed up to 32 levels deep\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void printActiveAttributes()\n\n<!--\n_syntax: printActiveAttributes()_\n_name: printActiveAttributes_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis prints out all the active attributes to the console.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void printActiveUniformBlocks()\n\n<!--\n_syntax: printActiveUniformBlocks()_\n_name: printActiveUniformBlocks_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void printActiveUniforms()\n\n<!--\n_syntax: printActiveUniforms()_\n_name: printActiveUniforms_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis prints out all the active uniforms to the console.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setAttribute1d(location, v1)\n\n<!--\n_syntax: setAttribute1d(location, v1)_\n_name: setAttribute1d_\n_returns: void_\n_returns_description: _\n_parameters: GLint location, double v1_\n_access: public_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nSet one double attribute on the shader.\nAttributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setAttribute1f(location, v1)\n\n<!--\n_syntax: setAttribute1f(location, v1)_\n_name: setAttribute1f_\n_returns: void_\n_returns_description: _\n_parameters: GLint location, float v1_\n_access: public_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nSet one float attributes on the shader.\nAttributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setAttribute1fv(&name, *v, stride)\n\n<!--\n_syntax: setAttribute1fv(&name, *v, stride)_\n_name: setAttribute1fv_\n_returns: void_\n_returns_description: _\n_parameters: const string &name, const float *v, GLsizei stride_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setAttribute1s(location, v1)\n\n<!--\n_syntax: setAttribute1s(location, v1)_\n_name: setAttribute1s_\n_returns: void_\n_returns_description: _\n_parameters: GLint location, short v1_\n_access: public_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nSet a short attribute, a short int, on the shader.\nAttributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setAttribute2d(location, v1, v2)\n\n<!--\n_syntax: setAttribute2d(location, v1, v2)_\n_name: setAttribute2d_\n_returns: void_\n_returns_description: _\n_parameters: GLint location, double v1, double v2_\n_access: public_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nSet two double attribute on the shader.\nAttributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setAttribute2f(location, v1, v2)\n\n<!--\n_syntax: setAttribute2f(location, v1, v2)_\n_name: setAttribute2f_\n_returns: void_\n_returns_description: _\n_parameters: GLint location, float v1, float v2_\n_access: public_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nSet two float attributes on the shader.\nAttributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setAttribute2fv(&name, *v, stride)\n\n<!--\n_syntax: setAttribute2fv(&name, *v, stride)_\n_name: setAttribute2fv_\n_returns: void_\n_returns_description: _\n_parameters: const string &name, const float *v, GLsizei stride_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setAttribute2s(location, v1, v2)\n\n<!--\n_syntax: setAttribute2s(location, v1, v2)_\n_name: setAttribute2s_\n_returns: void_\n_returns_description: _\n_parameters: GLint location, short v1, short v2_\n_access: public_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nSet two short attributes, a short int, on the shader.\nAttributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setAttribute3d(location, v1, v2, v3)\n\n<!--\n_syntax: setAttribute3d(location, v1, v2, v3)_\n_name: setAttribute3d_\n_returns: void_\n_returns_description: _\n_parameters: GLint location, double v1, double v2, double v3_\n_access: public_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nSet three double attribute on the shader.\nAttributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setAttribute3f(location, v1, v2, v3)\n\n<!--\n_syntax: setAttribute3f(location, v1, v2, v3)_\n_name: setAttribute3f_\n_returns: void_\n_returns_description: _\n_parameters: GLint location, float v1, float v2, float v3_\n_access: public_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nSet three float attributes on the shader.\nAttributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setAttribute3fv(&name, *v, stride)\n\n<!--\n_syntax: setAttribute3fv(&name, *v, stride)_\n_name: setAttribute3fv_\n_returns: void_\n_returns_description: _\n_parameters: const string &name, const float *v, GLsizei stride_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setAttribute3s(location, v1, v2, v3)\n\n<!--\n_syntax: setAttribute3s(location, v1, v2, v3)_\n_name: setAttribute3s_\n_returns: void_\n_returns_description: _\n_parameters: GLint location, short v1, short v2, short v3_\n_access: public_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nSet three short attributes, a short int, on the shader.\nAttributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setAttribute4d(location, v1, v2, v3, v4)\n\n<!--\n_syntax: setAttribute4d(location, v1, v2, v3, v4)_\n_name: setAttribute4d_\n_returns: void_\n_returns_description: _\n_parameters: GLint location, double v1, double v2, double v3, double v4_\n_access: public_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nSet four double attribute on the shader.\nAttributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setAttribute4f(location, v1, v2, v3, v4)\n\n<!--\n_syntax: setAttribute4f(location, v1, v2, v3, v4)_\n_name: setAttribute4f_\n_returns: void_\n_returns_description: _\n_parameters: GLint location, float v1, float v2, float v3, float v4_\n_access: public_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nSet four float attributes on the shader.\nAttributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setAttribute4fv(&name, *v, stride)\n\n<!--\n_syntax: setAttribute4fv(&name, *v, stride)_\n_name: setAttribute4fv_\n_returns: void_\n_returns_description: _\n_parameters: const string &name, const float *v, GLsizei stride_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setAttribute4s(location, v1, v2, v3, v4)\n\n<!--\n_syntax: setAttribute4s(location, v1, v2, v3, v4)_\n_name: setAttribute4s_\n_returns: void_\n_returns_description: _\n_parameters: GLint location, short v1, short v2, short v3, short v4_\n_access: public_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nSet four short attributes, a short int, on the shader.\nAttributes are different than uniforms in that you can pass an attribute to each vertex or fragment that is being shaded.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setConstantTemp(&name, &type, value)\n\n<!--\n_syntax: setConstantTemp(&name, &type, value)_\n_name: setConstantTemp_\n_returns: void_\n_returns_description: _\n_parameters: const string &name, const string &type, T value_\n_access: private_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setDefineConstantTemp(&name, value)\n\n<!--\n_syntax: setDefineConstantTemp(&name, value)_\n_name: setDefineConstantTemp_\n_returns: void_\n_returns_description: _\n_parameters: const string &name, T value_\n_access: private_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setGeometryInputType(type)\n\n<!--\n_syntax: setGeometryInputType(type)_\n_name: setGeometryInputType_\n_returns: void_\n_returns_description: _\n_parameters: GLenum type_\n_access: public_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nYou have to call this before linking the program with geometry shaders.\nPossible types are GL_POINTS, GL_LINES, GL_LINES_ADJACENCY_EXT, GL_TRIANGLES, GL_TRIANGLES_ADJACENCY_EXT\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setGeometryOutputCount(count)\n\n<!--\n_syntax: setGeometryOutputCount(count)_\n_name: setGeometryOutputCount_\n_returns: void_\n_returns_description: _\n_parameters: int count_\n_access: public_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nYou have to call this before linking the program with geometry shaders to set the number of output vertices, For quads, this should be 4, for points 1. Triangle strips can use up to the maximum number. You can check the maximum number supported on your graphics cards with getGeometryMaxOutputCount()\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setGeometryOutputType(type)\n\n<!--\n_syntax: setGeometryOutputType(type)_\n_name: setGeometryOutputType_\n_returns: void_\n_returns_description: _\n_parameters: GLenum type_\n_access: public_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nYou have to call this before linking the program with geometry shaders.\ntype: GL_POINTS, GL_LINE_STRIP or GL_TRIANGLE_STRIP\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setUniform1f(&name, v1)\n\n<!--\n_syntax: setUniform1f(&name, v1)_\n_name: setUniform1f_\n_returns: void_\n_returns_description: _\n_parameters: const string &name, float v1_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nset a float uniform on the shader\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setUniform1fv(&name, *v, count = 1)\n\n<!--\n_syntax: setUniform1fv(&name, *v, count = 1)_\n_name: setUniform1fv_\n_returns: void_\n_returns_description: _\n_parameters: const string &name, const float *v, int count=1_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setUniform1i(&name, v1)\n\n<!--\n_syntax: setUniform1i(&name, v1)_\n_name: setUniform1i_\n_returns: void_\n_returns_description: _\n_parameters: const string &name, int v1_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setUniform1iv(&name, *v, count = 1)\n\n<!--\n_syntax: setUniform1iv(&name, *v, count = 1)_\n_name: setUniform1iv_\n_returns: void_\n_returns_description: _\n_parameters: const string &name, const int *v, int count=1_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setUniform2f(&name, &v)\n\n<!--\n_syntax: setUniform2f(&name, &v)_\n_name: setUniform2f_\n_returns: void_\n_returns_description: _\n_parameters: const string &name, const glm::vec2 &v_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setUniform2f(&name, v1, v2)\n\n<!--\n_syntax: setUniform2f(&name, v1, v2)_\n_name: setUniform2f_\n_returns: void_\n_returns_description: _\n_parameters: const string &name, float v1, float v2_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setUniform2fv(&name, *v, count = 1)\n\n<!--\n_syntax: setUniform2fv(&name, *v, count = 1)_\n_name: setUniform2fv_\n_returns: void_\n_returns_description: _\n_parameters: const string &name, const float *v, int count=1_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis allows you to set multiple vec2 uniforms.\n~~~~{.cpp}\nvec2 v[2];\n~~~~\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setUniform2i(&name, v1, v2)\n\n<!--\n_syntax: setUniform2i(&name, v1, v2)_\n_name: setUniform2i_\n_returns: void_\n_returns_description: _\n_parameters: const string &name, int v1, int v2_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setUniform2iv(&name, *v, count = 1)\n\n<!--\n_syntax: setUniform2iv(&name, *v, count = 1)_\n_name: setUniform2iv_\n_returns: void_\n_returns_description: _\n_parameters: const string &name, const int *v, int count=1_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nset an array of uniform values on the shader using int[2] value. On the shader this looks like:\n~~~~{.cpp}\nivec2 iv[2];\n~~~~\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setUniform3f(&name, &v)\n\n<!--\n_syntax: setUniform3f(&name, &v)_\n_name: setUniform3f_\n_returns: void_\n_returns_description: _\n_parameters: const string &name, const glm::vec3 &v_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setUniform3f(&name, v1, v2, v3)\n\n<!--\n_syntax: setUniform3f(&name, v1, v2, v3)_\n_name: setUniform3f_\n_returns: void_\n_returns_description: _\n_parameters: const string &name, float v1, float v2, float v3_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nset a vec3 uniform on the shader\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setUniform3fv(&name, *v, count = 1)\n\n<!--\n_syntax: setUniform3fv(&name, *v, count = 1)_\n_name: setUniform3fv_\n_returns: void_\n_returns_description: _\n_parameters: const string &name, const float *v, int count=1_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis allows you to set multiple vec3 uniforms.\n~~~~{.cpp}\nvec3 v[2];\n~~~~\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setUniform3i(&name, v1, v2, v3)\n\n<!--\n_syntax: setUniform3i(&name, v1, v2, v3)_\n_name: setUniform3i_\n_returns: void_\n_returns_description: _\n_parameters: const string &name, int v1, int v2, int v3_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n~~~~{.cpp}\nuniform ivec3 texture;\n~~~~\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setUniform3iv(&name, *v, count = 1)\n\n<!--\n_syntax: setUniform3iv(&name, *v, count = 1)_\n_name: setUniform3iv_\n_returns: void_\n_returns_description: _\n_parameters: const string &name, const int *v, int count=1_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nset an array of uniform values on the shader using int[2] value. On the shader this looks like:\n~~~~{.cpp}\nivec3 iv[2];\n~~~~\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setUniform4f(&name, &v)\n\n<!--\n_syntax: setUniform4f(&name, &v)_\n_name: setUniform4f_\n_returns: void_\n_returns_description: _\n_parameters: const string &name, const glm::vec4 &v_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setUniform4f(&name, &v)\n\n<!--\n_syntax: setUniform4f(&name, &v)_\n_name: setUniform4f_\n_returns: void_\n_returns_description: _\n_parameters: const string &name, const ofFloatColor &v_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setUniform4f(&name, v1, v2, v3, v4)\n\n<!--\n_syntax: setUniform4f(&name, v1, v2, v3, v4)_\n_name: setUniform4f_\n_returns: void_\n_returns_description: _\n_parameters: const string &name, float v1, float v2, float v3, float v4_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nset a vec4 uniform on the shader\n~~~~{.cpp}\nvec4 fv;\n~~~~\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setUniform4fv(&name, *v, count = 1)\n\n<!--\n_syntax: setUniform4fv(&name, *v, count = 1)_\n_name: setUniform4fv_\n_returns: void_\n_returns_description: _\n_parameters: const string &name, const float *v, int count=1_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis allows you to set multiple vec4 uniforms.\n~~~~{.cpp}\nvec4 v[2];\n~~~~\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setUniform4i(&name, v1, v2, v3, v4)\n\n<!--\n_syntax: setUniform4i(&name, v1, v2, v3, v4)_\n_name: setUniform4i_\n_returns: void_\n_returns_description: _\n_parameters: const string &name, int v1, int v2, int v3, int v4_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setUniform4iv(&name, *v, count = 1)\n\n<!--\n_syntax: setUniform4iv(&name, *v, count = 1)_\n_name: setUniform4iv_\n_returns: void_\n_returns_description: _\n_parameters: const string &name, const int *v, int count=1_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nset an array of uniform values on the shader using int[2] value. On the shader this looks like:\n~~~~{.cpp}\nivec4 iv[2];\n~~~~\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setUniformMatrix3f(&name, &m, count = 1)\n\n<!--\n_syntax: setUniformMatrix3f(&name, &m, count = 1)_\n_name: setUniformMatrix3f_\n_returns: void_\n_returns_description: _\n_parameters: const string &name, const glm::mat3 &m, int count=1_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setUniformMatrix4f(&name, &m, count = 1)\n\n<!--\n_syntax: setUniformMatrix4f(&name, &m, count = 1)_\n_name: setUniformMatrix4f_\n_returns: void_\n_returns_description: _\n_parameters: const string &name, const glm::mat4 &m, int count=1_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setUniformTexture(&name, &img, textureLocation)\n\n<!--\n_syntax: setUniformTexture(&name, &img, textureLocation)_\n_name: setUniformTexture_\n_returns: void_\n_returns_description: _\n_parameters: const string &name, const ofBaseHasTexture &img, int textureLocation_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nset a texture reference\nOn your shader it should look like this:\n~~~~{.cpp}\nuniform sampler2DRect texture;\n~~~~\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setUniformTexture(&name, &img, textureLocation)\n\n<!--\n_syntax: setUniformTexture(&name, &img, textureLocation)_\n_name: setUniformTexture_\n_returns: void_\n_returns_description: _\n_parameters: const string &name, const ofTexture &img, int textureLocation_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setUniformTexture(&name, textureTarget, textureID, textureLocation)\n\n<!--\n_syntax: setUniformTexture(&name, textureTarget, textureID, textureLocation)_\n_name: setUniformTexture_\n_returns: void_\n_returns_description: _\n_parameters: const string &name, int textureTarget, GLint textureID, int textureLocation_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setUniforms(&parameters)\n\n<!--\n_syntax: setUniforms(&parameters)_\n_name: setUniforms_\n_returns: void_\n_returns_description: _\n_parameters: const ofParameterGroup &parameters_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool setup(&settings)\n\n<!--\n_syntax: setup(&settings)_\n_name: setup_\n_returns: bool_\n_returns_description: _\n_parameters: const ofShaderSettings &settings_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool setup(&settings)\n\n<!--\n_syntax: setup(&settings)_\n_name: setup_\n_returns: bool_\n_returns_description: _\n_parameters: const ofShader::TransformFeedbackSettings &settings_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool setupShaderFromFile(type, &filename)\n\n<!--\n_syntax: setupShaderFromFile(type, &filename)_\n_name: setupShaderFromFile_\n_returns: bool_\n_returns_description: _\n_parameters: GLenum type, const filesystem::path &filename_\n_access: public_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis are more of advanced use function and doesn't need.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool setupShaderFromSource(&&source)\n\n<!--\n_syntax: setupShaderFromSource(&&source)_\n_name: setupShaderFromSource_\n_returns: bool_\n_returns_description: _\n_parameters: ofShader::Source &&source_\n_access: private_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool setupShaderFromSource(type, source, sourceDirectoryPath)\n\n<!--\n_syntax: setupShaderFromSource(type, source, sourceDirectoryPath)_\n_name: setupShaderFromSource_\n_returns: bool_\n_returns_description: _\n_parameters: GLenum type, string source, string sourceDirectoryPath_\n_access: public_\n_version_started: 0.8.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis method create and compile a shader from source.\nWorking with OpenGL 3 or OpenGL ES 2.0, remember to call bindDefaults() before linkProgram()\n\nExample of a simple shader to display a texture, using the ofGLProgrammableRenderer:\n~~~~{.cpp}\nstringstream vertexSrc;\nvertexSrc << \"#version 150\\n\";\nvertexSrc << \"uniform mat4 modelViewProjectionMatrix;\\n\";\nvertexSrc  << \"in vec4 position;\\n\";\nvertexSrc  << \"in vec2 texcoord;\\n\";\nvertexSrc  << \"out vec2 texCoordVarying;\\n\";\nvertexSrc  << \"void main(void){\\n\";\nvertexSrc  << \"\\tgl_Position=modelViewProjectionMatrix*position;\\n\";\nvertexSrc  << \"\\ttexCoordVarying = texcoord;\\n\";\nvertexSrc  << \"}\\n\";\n\nstringstream fragmentSrc;\nfragmentSrc << \"#version 150\\n\";\nfragmentSrc << \"uniform sampler2DRect tex0;\\n\";\nfragmentSrc << \"in vec2 texCoordVarying;\\n\";\nfragmentSrc << \"out vec4 outputColor;\\n\";\nfragmentSrc << \"uniform vec2 direction;\\n\";\nfragmentSrc << \"void main(void) {\\n\";\nfragmentSrc << \"\\toutputColor = texture(tex0, texCoordVarying);\\n\";\nfragmentSrc << \"}\\n\";\n\nshader.setupShaderFromSource( GL_VERTEX_SHADER, vertexSrc.str() );\nshader.setupShaderFromSource( GL_FRAGMENT_SHADER, fragmentSrc.str() );\nshader.bindDefaults();\nshader.linkProgram();\n~~~~\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###ofShader::Source sourceFromFile(type, &filename)\n\n<!--\n_syntax: sourceFromFile(type, &filename)_\n_name: sourceFromFile_\n_returns: ofShader::Source_\n_returns_description: _\n_parameters: GLenum type, const filesystem::path &filename_\n_access: private_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void unload()\n\n<!--\n_syntax: unload()_\n_name: unload_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis unload the shader, which means that it will not be active on the graphics card any longer.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n### ~ofShader()\n\n<!--\n_syntax: ~ofShader()_\n_name: ~ofShader_\n_returns: _\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n##Variables\n\n\n\n###unordered_map< string, GLint > attributesBindingsCache\n\n<!--\n_name: attributesBindingsCache_\n_type: unordered_map< string, GLint >_\n_access: private_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: False_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool bLoaded\n\n<!--\n_name: bLoaded_\n_type: bool_\n_access: private_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###GLuint program\n\n<!--\n_name: program_\n_type: GLuint_\n_access: private_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###map< GLenum, GLuint > shaders\n\n<!--\n_name: shaders_\n_type: map< GLenum, GLuint >_\n_access: private_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###int uniformBlocksCache\n\n<!--\n_name: uniformBlocksCache_\n_type: int_\n_access: private_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: False_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###unordered_map< string, GLint > uniformsCache\n\n<!--\n_name: uniformsCache_\n_type: unordered_map< string, GLint >_\n_access: private_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: False_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n","type":"page"}}],"fetch":[]}