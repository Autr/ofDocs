{"data":[{"page":{"entry":{"name":"ofFile","filename":"ofFile.markdown","absolute":"/Users/gilbertsinnott/Code/openFrameworks/ofSite/documentation/utils/ofFile.markdown","path":"/documentation/utils/ofFile","route":"/documentation/utils/ofFile.markdown","dir":"../ofSite/documentation/utils","ext":"markdown","type":"page","id":2206,"parent":2196,"breadcrumbs":[2196,1718],"siblings":[],"translations":{}},"description":{"short":"<p>path to a file or directory</p>\n<p>inherits from an fstream so you can read/write using the stream operators\nonce a file path has been opened</p>\n","full":"<p>ofFile wraps functionality for opening, reading, writing, and modifying files on your computer.</p>\n<pre><code>\nofFile file<span class=\"token punctuation\">;</span>\n\nfile<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token function\">ofToDataPath</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>temp<span class=\"token punctuation\">.</span>xml<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> ofFile<span class=\"token operator\">::</span>ReadWrite<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nofBuffer buff <span class=\"token operator\">=</span> file<span class=\"token punctuation\">.</span><span class=\"token function\">readToBuffer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>You can do the same with the bufferFromFile method:</p>\n<pre><code>ofBuffer <span class=\"token function\">ofBufferFromFile</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>amp<span class=\"token punctuation\">;</span> path<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> binary<span class=\"token operator\">=</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>To write a buffer to a file, use ofBufferToFile()</p>\n<pre><code>ofBuffer dataBuffer<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// fill the buffer with something important</span>\n<span class=\"token keyword\">bool</span> fileWritten <span class=\"token operator\">=</span> <span class=\"token function\">ofBufferToFile</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>data<span class=\"token punctuation\">.</span>dat<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">,</span> dataBuffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\n</code></pre>\n<p>You can also compare files using the ==, !=, &lt;,</p>\n"},"config":{"visible":"True","advanced":"False","istemplated":"False","extends":"std::fstream"},"methods":[{"syntax":"canExecute()","name":"canExecute","returns":"bool","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Check if the current path is executable.</p>\n<p><strong>Returns</strong>: true if executable</p>\n","desc":"<p>Whether the file is an executable file.</p>\n"},{"syntax":"canRead()","name":"canRead","returns":"bool","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Check if the current path is readable.</p>\n<p><strong>Returns</strong>: true if readable</p>\n","desc":"<p>Whether the file can be read or not.</p>\n"},{"syntax":"canWrite()","name":"canWrite","returns":"bool","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Check if the current path is writable.</p>\n<p><strong>Returns</strong>: true if writable</p>\n","desc":"<p>Whether the file can be written to or not.</p>\n"},{"syntax":"changeMode(mode, binary = true)","name":"changeMode","returns":"bool","returns_description":null,"parameters":"ofFile<span class=\"token operator\">::</span>Mode mode<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> binary<span class=\"token operator\">=</span><span class=\"token boolean\">true</span>","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Reopen the current file path with a different access mode.</p>\n<p><strong>Parameters:</strong></p>\n<p>mode file access mode depending on how you plan to use the file\n(read only, read write, etc)</p>\n<p>binary set to false if you are reading a text file &amp; want lines\nsplit at endline characters automatically</p>\n<p><strong>Returns</strong>: true if the file was reopened with the new access mode(s).</p>\n","desc":"<p>Changes the mode of the file from the current mode to the one passed in.</p>\n"},{"syntax":"close()","name":"close","returns":"void","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Close a currently open file.</p>\n","desc":"<p>Closes the ofFile instance.</p>\n"},{"syntax":"copyFrom(&mom)","name":"copyFrom","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofFile <span class=\"token operator\">&amp;</span>mom","access":"private","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"copyFromTo(&pathSrc, &pathDst, bRelativeToData = true, overwrite = false)","name":"copyFromTo","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> filesystem<span class=\"token operator\">::</span>path <span class=\"token operator\">&amp;</span>pathSrc<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> filesystem<span class=\"token operator\">::</span>path <span class=\"token operator\">&amp;</span>pathDst<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> bRelativeToData<span class=\"token operator\">=</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> overwrite<span class=\"token operator\">=</span><span class=\"token boolean\">false</span>","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"True","visible":"True","advanced":"False","short":"<p>Copy source path to destination path.</p>\n<p>Copies relative to the data path &amp; does <em>not</em> overwrite by default\nassumes the source &amp; destination path is in the data directory.</p>\n<p><strong>Parameters:</strong></p>\n<p>pathSrc source file or directory path</p>\n<p>pathDst destination file or directory path</p>\n<p>bRelativeToData set to false if you are working with paths that\nare <em>not</em> in the data directory</p>\n<p>overwrite set to true if you want to overwrite the file or\ndirectory at the new path</p>\n<p><strong>Returns</strong>: true if the copy was successful</p>\n","desc":""},{"syntax":"copyTo(&path, bRelativeToData = true, overwrite = false)","name":"copyTo","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> filesystem<span class=\"token operator\">::</span>path <span class=\"token operator\">&amp;</span>path<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> bRelativeToData<span class=\"token operator\">=</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> overwrite<span class=\"token operator\">=</span><span class=\"token boolean\">false</span>","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Copy the current file or directory path to a new path.</p>\n<p>Copies relative to the data path &amp; does <em>not</em> overwrite by default\ndoes not change the current path &amp; assumes the new path is in the data\nfolder.</p>\n<p><strong>Parameters:</strong></p>\n<p>path destination file or directory path</p>\n<p>bRelativeToData set to false if you are working with paths that\nare <em>not</em> in the data folder</p>\n<p>overwrite set to true if you want to overwrite the file or\ndirectory at the new path</p>\n<p><strong>Returns</strong>: true if the copy was successful</p>\n","desc":"<p>Copy the file from its current location into the path parameter. This is similar to the cp command.</p>\n"},{"syntax":"create(&path)","name":"create","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> filesystem<span class=\"token operator\">::</span>path <span class=\"token operator\">&amp;</span>path","access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Create a file at a given path.</p>\n<p>Creates as a write only binary file by default.</p>\n<p><strong>Parameters:</strong></p>\n<p>path file path</p>\n<p><strong>Returns</strong>: true if the file was created</p>\n","desc":""},{"syntax":"create()","name":"create","returns":"bool","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Create a file at the current path.</p>\n<p>Creates as a write only binary file by default.</p>\n<p><strong>Returns</strong>: true if the file was created</p>\n","desc":"<p>If the ofFile contains a file path that doesn't exist yet, calling create() generates the file.</p>\n<pre><code>ofFile <span class=\"token function\">newFile</span><span class=\"token punctuation\">(</span><span class=\"token function\">ofToDataPath</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>temp<span class=\"token punctuation\">.</span>txt<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> ofFile<span class=\"token operator\">::</span>Write<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// file doesn't exist yet</span>\nnewFile<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// now file exists</span>\n</code></pre>\n"},{"syntax":"doesFileExist(&fPath, bRelativeToData = true)","name":"doesFileExist","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> filesystem<span class=\"token operator\">::</span>path <span class=\"token operator\">&amp;</span>fPath<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> bRelativeToData<span class=\"token operator\">=</span><span class=\"token boolean\">true</span>","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"True","visible":"True","advanced":"False","short":"<p>Check if a file or directory exists at a given path.</p>\n<p><strong>Parameters:</strong></p>\n<p>fPath file path</p>\n<p>bRelativeToData set to false if you are working with paths that\nare <em>not</em> in the data folder and want the direct path without relative\n&quot;../../&quot;</p>\n<p><strong>Returns</strong>: true if a file or directory exists</p>\n","desc":""},{"syntax":"exists()","name":"exists","returns":"bool","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Check if a file exists at the current path.</p>\n<p><strong>Returns</strong>: true if the file exists</p>\n","desc":"<p>Tests whether a file path exists or not.</p>\n"},{"syntax":"getAbsolutePath()","name":"getAbsolutePath","returns":"string","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","desc":"<p>Returns the absolute path to the file, on OSX this will be something like /Users/name/openFrameworks/apps/app/data/file.xml on Windows it will something like C:\\Documents\\openframeworks\\apps\\app\\data\\file.xml</p>\n"},{"syntax":"getBaseName()","name":"getBaseName","returns":"string","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","desc":""},{"syntax":"getEnclosingDirectory()","name":"getEnclosingDirectory","returns":"string","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","desc":"<p>Returns the relative path to the directory containing the file, for instance:</p>\n<pre><code>\nofFile <span class=\"token function\">file</span><span class=\"token punctuation\">(</span><span class=\"token function\">ofToDataPath</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>foo<span class=\"token punctuation\">.</span>xml<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ncout <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> file<span class=\"token punctuation\">.</span><span class=\"token function\">getEnclosingDirectory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// prints &amp;quot;../../../data/xml&amp;quot;</span>\n\n</code></pre>\n"},{"syntax":"getExtension()","name":"getExtension","returns":"string","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","desc":"<p>Returns the extension of the file.</p>\n<pre><code>    ofFile <span class=\"token function\">file</span><span class=\"token punctuation\">(</span><span class=\"token function\">ofToDataPath</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>foo<span class=\"token punctuation\">.</span>xml<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cout <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> file<span class=\"token punctuation\">.</span><span class=\"token function\">getExtension</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n"},{"syntax":"getFileBuffer()","name":"getFileBuffer","returns":"filebuf *","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Read the entire contents of the currently opened file into an\noutput stream.</p>\n<p>This is basically an easy to use equivalent to rdbuf():\nie. ofLogNotice() &lt;&lt; file.getFileBuffer();\nwrite_file &lt;&lt; file.getFileBuffer();</p>\n<p>\\return output stream</p>\n","desc":""},{"syntax":"getFileName()","name":"getFileName","returns":"string","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","desc":"<p>Returns the actual file name.</p>\n"},{"syntax":"getSize()","name":"getSize","returns":"uint64_t","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>get the size of the file at the current file path</p>\n<p><strong>Returns</strong>: size in bytes</p>\n","desc":"<p>Gets the size of the file at the file path.</p>\n"},{"syntax":"isDevice()","name":"isDevice","returns":"bool","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Check if the current path is a device file.</p>\n<p>Works on Mac &amp; Linux which can represent devices as files, however\nalways returns false on Windows.</p>\n<p><strong>Returns</strong>: true if a device file</p>\n","desc":"<p>Returns whether the file path points to a mounted device.</p>\n"},{"syntax":"isDirectory()","name":"isDirectory","returns":"bool","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Check if the current path is a directory and not a file.</p>\n<p><strong>Returns</strong>: true if a directory</p>\n","desc":"<p>Returns whether the file path points to a directory or not.</p>\n"},{"syntax":"isFile()","name":"isFile","returns":"bool","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Check if the current path is a file and not a directory.</p>\n<p><strong>Returns</strong>: true if a file</p>\n","desc":"<p>Whether the file path points to a file (it could also be a directory)</p>\n"},{"syntax":"isHidden()","name":"isHidden","returns":"bool","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","desc":"<p>Returns whether the file path points to a hidden file or not.</p>\n"},{"syntax":"isLink()","name":"isLink","returns":"bool","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Check if the current path is a system link to another file or\ndirectory.</p>\n<p><strong>Returns</strong>: true if a system link</p>\n","desc":"<p>Returns whether file is an alias or not.</p>\n"},{"syntax":"isWriteMode()","name":"isWriteMode","returns":"bool","returns_description":null,"parameters":null,"access":"private","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"moveFromTo(&pathSrc, &pathDst, bRelativeToData = true, overwrite = false)","name":"moveFromTo","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> filesystem<span class=\"token operator\">::</span>path <span class=\"token operator\">&amp;</span>pathSrc<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> filesystem<span class=\"token operator\">::</span>path <span class=\"token operator\">&amp;</span>pathDst<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> bRelativeToData<span class=\"token operator\">=</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> overwrite<span class=\"token operator\">=</span><span class=\"token boolean\">false</span>","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"True","visible":"True","advanced":"False","short":"<p>Move source path to destination path.</p>\n<p>Moves relative to the data path &amp; does <em>not</em> overwrite by default\nassumes the source &amp; destination path is in the data directory.</p>\n<p><strong>Parameters:</strong></p>\n<p>pathSrc source file or directory path</p>\n<p>pathDst destination file or directory path</p>\n<p>bRelativeToData set to false if you are working with paths that\nare <em>not</em> in the data folder</p>\n<p>overwrite set to true if you want to overwrite the file or\ndirectory at the new path</p>\n<p><strong>Warning</strong>: be careful with slashes here, appending a slash when moving a\nfolder may cause mad headaches in OSX</p>\n<p><strong>Returns</strong>: true if the move was successful</p>\n","desc":""},{"syntax":"moveTo(&path, bRelativeToData = true, overwrite = false)","name":"moveTo","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> filesystem<span class=\"token operator\">::</span>path <span class=\"token operator\">&amp;</span>path<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> bRelativeToData<span class=\"token operator\">=</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> overwrite<span class=\"token operator\">=</span><span class=\"token boolean\">false</span>","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Move the current file or directory path to a new path.</p>\n<p>Moves relative to the data path &amp; does <em>not</em> overwrite by default\ndoes not change the current path &amp; assumes the new path is in the data\nfolder.</p>\n<p><strong>Parameters:</strong></p>\n<p>path destination file or directory path</p>\n<p>bRelativeToData set to false if you are working with paths that\nare <em>not</em> in the data folder</p>\n<p>overwrite set to true if you want to overwrite the file or\ndirectory at the new path</p>\n<p><strong>Returns</strong>: true if the copy was successful</p>\n","desc":"<p>Moves the file to the location specified by path. This is similar to the mv command.</p>\n"},{"syntax":"ofFile(&mom)","name":"ofFile","returns":null,"returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofFile <span class=\"token operator\">&amp;</span>mom","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Create a new file path using the same path &amp; settings of another\nfile.</p>\n<p><strong>Parameters:</strong></p>\n<p>mom ofFile instance source</p>\n","desc":"<p>Copy constructor for copying one ofFile into another</p>\n"},{"syntax":"ofFile(&path, mode = ReadOnly, binary = true)","name":"ofFile","returns":null,"returns_description":null,"parameters":"<span class=\"token keyword\">const</span> filesystem<span class=\"token operator\">::</span>path <span class=\"token operator\">&amp;</span>path<span class=\"token punctuation\">,</span> ofFile<span class=\"token operator\">::</span>Mode mode<span class=\"token operator\">=</span>ReadOnly<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> binary<span class=\"token operator\">=</span><span class=\"token boolean\">true</span>","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Create a new ofFile instance and attempt to open the path as a\nfile.</p>\n<p>Opens as a binary file with read only access by default.</p>\n<p><strong>Parameters:</strong></p>\n<p>path file path</p>\n<p>mode file access mode depending on how you plan to use the file\n(read only, read write, etc)</p>\n<p>binary set to false if you are working with a text file &amp; want\nlines split at endline characters automatically</p>\n","desc":"<p>Creates an ofFile using the file path and mode specified. Note that if the file doesn't actually exist on the file system this doesn't actually create file until you call create().</p>\n<pre><code>ofFile <span class=\"token function\">fileToRead</span><span class=\"token punctuation\">(</span><span class=\"token function\">ofToDataPath</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>dictionary<span class=\"token punctuation\">.</span>txt<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// a file that exists</span>\n</code></pre>\n<pre><code>ofFile <span class=\"token function\">newFile</span><span class=\"token punctuation\">(</span><span class=\"token function\">ofToDataPath</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>temp<span class=\"token punctuation\">.</span>txt<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> ofFile<span class=\"token operator\">::</span>Write<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// file doesn't exist yet</span>\nnewFile<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// now file exists </span>\n</code></pre>\n"},{"syntax":"ofFile()","name":"ofFile","returns":null,"returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Create an ofFile instance.</p>\n<p>Does not refer to a specific file until you either open a file or create\na file or directory path.</p>\n","desc":"<p>Creates an empty ofFile.</p>\n"},{"syntax":"open(&path, mode = ReadOnly, binary = true)","name":"open","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> filesystem<span class=\"token operator\">::</span>path <span class=\"token operator\">&amp;</span>path<span class=\"token punctuation\">,</span> ofFile<span class=\"token operator\">::</span>Mode mode<span class=\"token operator\">=</span>ReadOnly<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> binary<span class=\"token operator\">=</span><span class=\"token boolean\">true</span>","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Open the path as a file.</p>\n<p>Opens as a text file with read only access by default.</p>\n<p><strong>Parameters:</strong></p>\n<p>path file path</p>\n<p>mode file access mode depending on how you plan to use the file\n(read only, read write, etc)</p>\n<p>binary set to false if you are reading a text file &amp; want lines\nsplit at endline characters automatically</p>\n<p><strong>Returns</strong>: true if the path was opened</p>\n","desc":"<p>Opens the file with the file mode, either Reference, ReadOnly, WriteOnly, ReadWrite, Append</p>\n"},{"syntax":"openFromCWD(&path, mode = ReadOnly, binary = true)","name":"openFromCWD","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> filesystem<span class=\"token operator\">::</span>path <span class=\"token operator\">&amp;</span>path<span class=\"token punctuation\">,</span> ofFile<span class=\"token operator\">::</span>Mode mode<span class=\"token operator\">=</span>ReadOnly<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> binary<span class=\"token operator\">=</span><span class=\"token boolean\">true</span>","access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Open the path as a file.</p>\n<p>Opens as a text file with read only access by default from the current working directory without internally calling ofToDataPath.</p>\n<p><strong>Parameters:</strong></p>\n<p>path file path</p>\n<p>mode file access mode depending on how you plan to use the file\n(read only, read write, etc)</p>\n<p>binary set to false if you are reading a text file &amp; want lines\nsplit at endline characters automatically</p>\n<p><strong>Returns</strong>: true if the path was opened</p>\n","desc":""},{"syntax":"openStream(_mode, binary)","name":"openStream","returns":"bool","returns_description":null,"parameters":"ofFile<span class=\"token operator\">::</span>Mode _mode<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> binary","access":"private","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"operator!=(&file)","name":"operator!=","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofFile <span class=\"token operator\">&amp;</span>file","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Tests whether a file path is not equal to the file path of the ofFile on the right hand side.</p>\n"},{"syntax":"operator<(&file)","name":"operator<","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofFile <span class=\"token operator\">&amp;</span>file","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Tests whether a file path is greater than the file path of the ofFile on the right hand side.</p>\n"},{"syntax":"operator<=(&file)","name":"operator<=","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofFile <span class=\"token operator\">&amp;</span>file","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Tests whether a file path is lesser or equal than the file path of the ofFile on the right hand side.</p>\n"},{"syntax":"operator=(&mom)","name":"operator=","returns":"ofFile &","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofFile <span class=\"token operator\">&amp;</span>mom","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Copy the path and settings of an ofFile into this instance.</p>\n<p><strong>Parameters:</strong></p>\n<p>mom ofFile instance source</p>\n","desc":"<p>Equals operator which allows you to do this:</p>\n<pre><code>ofFile f1 <span class=\"token operator\">=</span> f2<span class=\"token punctuation\">;</span>\n</code></pre>\n"},{"syntax":"operator==(&file)","name":"operator==","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofFile <span class=\"token operator\">&amp;</span>file","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Tests whether a file path is equal to the file path of the  ofFile on the right hand side.</p>\n"},{"short":"","desc":"<p>Tests whether a file path is greater than the file path of the ofFile on the right hand side.</p>\n"},{"short":"","desc":"<p>Tests whether a file path is greater than or equal to the file path of the ofFile on the right hand side.</p>\n"},{"syntax":"path()","name":"path","returns":"string","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Get the current path.</p>\n<p><strong>Returns</strong>: current path</p>\n","desc":"<p>Returns the string of the ofFile file path.</p>\n"},{"syntax":"readToBuffer()","name":"readToBuffer","returns":"ofBuffer","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Read the contents of a file at the current path into a buffer.</p>\n<p><strong>Returns</strong>: buffer with file contents</p>\n","desc":"<p>Read the file into an ofBuffer object and return it.</p>\n"},{"syntax":"remove(recursive = false)","name":"remove","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">bool</span> recursive<span class=\"token operator\">=</span><span class=\"token boolean\">false</span>","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Removes the file or directory at the current path.</p>\n<p>Does not remove non-empty directories by default.</p>\n<p><strong>Warning</strong>: Be careful! This deletes a file or folder. :)</p>\n<p><strong>Parameters:</strong></p>\n<p>recursive set to true to remove a non-empty directory and its\ncontents</p>\n<p><strong>Returns</strong>: true if the path was removed successfully</p>\n","desc":"<p>deletes a file or folder, be careful as this is not undo-able.</p>\n"},{"syntax":"removeFile(&path, bRelativeToData = true)","name":"removeFile","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> filesystem<span class=\"token operator\">::</span>path <span class=\"token operator\">&amp;</span>path<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> bRelativeToData<span class=\"token operator\">=</span><span class=\"token boolean\">true</span>","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"True","visible":"True","advanced":"False","short":"<p>Remove a file or directory at a given path.</p>\n<p><strong>Parameters:</strong></p>\n<p>bRelativeToData set to false if you are working with paths that\nare <em>not</em> in the data folder and want the direct path without relative\n&quot;../../&quot;</p>\n<p><strong>Returns</strong>: true if the path was removed successfully</p>\n","desc":""},{"syntax":"renameTo(&path, bRelativeToData = true, overwrite = false)","name":"renameTo","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> filesystem<span class=\"token operator\">::</span>path <span class=\"token operator\">&amp;</span>path<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> bRelativeToData<span class=\"token operator\">=</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> overwrite<span class=\"token operator\">=</span><span class=\"token boolean\">false</span>","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Rename the current file or directory path to a new path.</p>\n<p>Renames relative to the data path &amp; does <em>not</em> overwrite by default\ndoes not change the current path &amp; assumes the new path is in the data\nfolder.</p>\n<p><strong>Parameters:</strong></p>\n<p>path destination file or directory path</p>\n<p>bRelativeToData set to false if you are working with paths that\nare <em>not</em> in the data folder</p>\n<p>overwrite set to true if you want to overwrite the file or\ndirectory at the new path</p>\n<p><strong>Returns</strong>: true if the copy was successful</p>\n","desc":"<p>Renames the file with the new file name. If you specify a different path then this will move the file as well.</p>\n"},{"syntax":"setExecutable(executable = true)","name":"setExecutable","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">bool</span> executable<span class=\"token operator\">=</span><span class=\"token boolean\">true</span>","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Set the executable flag of the current path.</p>\n","desc":"<p>Toggles the file as executable or not executable.</p>\n"},{"syntax":"setReadable(readable = true)","name":"setReadable","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">bool</span> readable<span class=\"token operator\">=</span><span class=\"token boolean\">true</span>","access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Set the readable flag of the current path.</p>\n","desc":""},{"syntax":"setWriteable(writeable = true)","name":"setWriteable","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">bool</span> writeable<span class=\"token operator\">=</span><span class=\"token boolean\">true</span>","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Set the writable flag of the current path.</p>\n","desc":"<p>Toggles the file as writeable or not writeable.</p>\n"},{"syntax":"writeFromBuffer(&buffer)","name":"writeFromBuffer","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofBuffer <span class=\"token operator\">&amp;</span>buffer","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Write the contents of a buffer into a file at the current path.</p>\n<p><strong>Parameters:</strong></p>\n<p>buffer source byte buffer</p>\n<p><strong>Returns</strong>: true if buffer's contents written successfully</p>\n","desc":"<p>Write an ofBuffer instance to the file path.</p>\n"},{"syntax":"~ofFile()","name":"~ofFile","returns":null,"returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Destructor</p>\n"},{"name":"binary","type":"bool ","access":"private","version_started":"0.8.0","version_deprecated":null,"summary":null,"visible":"True","constant":"True","advanced":"False","short":"","desc":""},{"name":"mode","type":"Mode","access":"private","version_started":"007","version_deprecated":null,"summary":null,"visible":"True","constant":"True","advanced":"False","short":"","desc":""},{"name":"myFile","type":"Poco","access":"private","version_started":"007","version_deprecated":null,"summary":null,"visible":"True","constant":"True","advanced":"False","short":"","desc":""},{}],"document":"<p>#class ofFile</p>\n<p>&lt;!--\n<em>visible: True</em>\n<em>advanced: False</em>\n<em>istemplated: False</em>\n<em>extends: std::fstream</em>\n--&gt;</p>\n<p>##InlineDescription</p>\n<p>path to a file or directory</p>\n<p>inherits from an fstream so you can read/write using the stream operators\nonce a file path has been opened</p>\n<p>##Description</p>\n<p>ofFile wraps functionality for opening, reading, writing, and modifying files on your computer.</p>\n<pre><code>\nofFile file<span class=\"token punctuation\">;</span>\n\nfile<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token function\">ofToDataPath</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>temp<span class=\"token punctuation\">.</span>xml<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> ofFile<span class=\"token operator\">::</span>ReadWrite<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nofBuffer buff <span class=\"token operator\">=</span> file<span class=\"token punctuation\">.</span><span class=\"token function\">readToBuffer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>You can do the same with the bufferFromFile method:</p>\n<pre><code>ofBuffer <span class=\"token function\">ofBufferFromFile</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>amp<span class=\"token punctuation\">;</span> path<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> binary<span class=\"token operator\">=</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>To write a buffer to a file, use ofBufferToFile()</p>\n<pre><code>ofBuffer dataBuffer<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// fill the buffer with something important</span>\n<span class=\"token keyword\">bool</span> fileWritten <span class=\"token operator\">=</span> <span class=\"token function\">ofBufferToFile</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>data<span class=\"token punctuation\">.</span>dat<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">,</span> dataBuffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\n</code></pre>\n<p>You can also compare files using the ==, !=, &lt;, &gt;, &lt;=, &gt;= operators. This is done so that the files can be stored in std::containers and sorted.</p>\n<pre><code>ofFile <span class=\"token function\">file</span><span class=\"token punctuation\">(</span><span class=\"token function\">ofToDataPath</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>foo<span class=\"token punctuation\">.</span>xml<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nofFile <span class=\"token function\">file2</span><span class=\"token punctuation\">(</span><span class=\"token function\">ofToDataPath</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>foo2<span class=\"token punctuation\">.</span>xml<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    \ncout <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>is foo less than foo2<span class=\"token operator\">?</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span> <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>file <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> file2<span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token boolean\">true</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span> <span class=\"token operator\">:</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token boolean\">false</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> endl<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>##Methods</p>\n<p>###bool canExecute()</p>\n<p>&lt;!--\n<em>syntax: canExecute()</em>\n<em>name: canExecute</em>\n<em>returns: bool</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Check if the current path is executable.</p>\n<p><strong>Returns</strong>: true if executable</p>\n<p>_description: _</p>\n<p>Whether the file is an executable file.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool canRead()</p>\n<p>&lt;!--\n<em>syntax: canRead()</em>\n<em>name: canRead</em>\n<em>returns: bool</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Check if the current path is readable.</p>\n<p><strong>Returns</strong>: true if readable</p>\n<p>_description: _</p>\n<p>Whether the file can be read or not.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool canWrite()</p>\n<p>&lt;!--\n<em>syntax: canWrite()</em>\n<em>name: canWrite</em>\n<em>returns: bool</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Check if the current path is writable.</p>\n<p><strong>Returns</strong>: true if writable</p>\n<p>_description: _</p>\n<p>Whether the file can be written to or not.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool changeMode(mode, binary = true)</p>\n<p>&lt;!--\n<em>syntax: changeMode(mode, binary = true)</em>\n<em>name: changeMode</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: ofFile::Mode mode, bool binary=true</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Reopen the current file path with a different access mode.</p>\n<p><strong>Parameters:</strong></p>\n<p>mode file access mode depending on how you plan to use the file\n(read only, read write, etc)</p>\n<p>binary set to false if you are reading a text file &amp; want lines\nsplit at endline characters automatically</p>\n<p><strong>Returns</strong>: true if the file was reopened with the new access mode(s).</p>\n<p>_description: _</p>\n<p>Changes the mode of the file from the current mode to the one passed in.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void close()</p>\n<p>&lt;!--\n<em>syntax: close()</em>\n<em>name: close</em>\n<em>returns: void</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Close a currently open file.</p>\n<p>_description: _</p>\n<p>Closes the ofFile instance.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void copyFrom(&amp;mom)</p>\n<p>&lt;!--\n<em>syntax: copyFrom(&amp;mom)</em>\n<em>name: copyFrom</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const ofFile &amp;mom</em>\n<em>access: private</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool copyFromTo(&amp;pathSrc, &amp;pathDst, bRelativeToData = true, overwrite = false)</p>\n<p>&lt;!--\n<em>syntax: copyFromTo(&amp;pathSrc, &amp;pathDst, bRelativeToData = true, overwrite = false)</em>\n<em>name: copyFromTo</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: const filesystem::path &amp;pathSrc, const filesystem::path &amp;pathDst, bool bRelativeToData=true, bool overwrite=false</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: True</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Copy source path to destination path.</p>\n<p>Copies relative to the data path &amp; does <em>not</em> overwrite by default\nassumes the source &amp; destination path is in the data directory.</p>\n<p><strong>Parameters:</strong></p>\n<p>pathSrc source file or directory path</p>\n<p>pathDst destination file or directory path</p>\n<p>bRelativeToData set to false if you are working with paths that\nare <em>not</em> in the data directory</p>\n<p>overwrite set to true if you want to overwrite the file or\ndirectory at the new path</p>\n<p><strong>Returns</strong>: true if the copy was successful</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool copyTo(&amp;path, bRelativeToData = true, overwrite = false)</p>\n<p>&lt;!--\n<em>syntax: copyTo(&amp;path, bRelativeToData = true, overwrite = false)</em>\n<em>name: copyTo</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: const filesystem::path &amp;path, bool bRelativeToData=true, bool overwrite=false</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Copy the current file or directory path to a new path.</p>\n<p>Copies relative to the data path &amp; does <em>not</em> overwrite by default\ndoes not change the current path &amp; assumes the new path is in the data\nfolder.</p>\n<p><strong>Parameters:</strong></p>\n<p>path destination file or directory path</p>\n<p>bRelativeToData set to false if you are working with paths that\nare <em>not</em> in the data folder</p>\n<p>overwrite set to true if you want to overwrite the file or\ndirectory at the new path</p>\n<p><strong>Returns</strong>: true if the copy was successful</p>\n<p>_description: _</p>\n<p>Copy the file from its current location into the path parameter. This is similar to the cp command.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool create(&amp;path)</p>\n<p>&lt;!--\n<em>syntax: create(&amp;path)</em>\n<em>name: create</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: const filesystem::path &amp;path</em>\n<em>access: public</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Create a file at a given path.</p>\n<p>Creates as a write only binary file by default.</p>\n<p><strong>Parameters:</strong></p>\n<p>path file path</p>\n<p><strong>Returns</strong>: true if the file was created</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool create()</p>\n<p>&lt;!--\n<em>syntax: create()</em>\n<em>name: create</em>\n<em>returns: bool</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Create a file at the current path.</p>\n<p>Creates as a write only binary file by default.</p>\n<p><strong>Returns</strong>: true if the file was created</p>\n<p>_description: _</p>\n<p>If the ofFile contains a file path that doesn't exist yet, calling create() generates the file.</p>\n<pre><code>ofFile <span class=\"token function\">newFile</span><span class=\"token punctuation\">(</span><span class=\"token function\">ofToDataPath</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>temp<span class=\"token punctuation\">.</span>txt<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> ofFile<span class=\"token operator\">::</span>Write<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// file doesn't exist yet</span>\nnewFile<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// now file exists</span>\n</code></pre>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool doesFileExist(&amp;fPath, bRelativeToData = true)</p>\n<p>&lt;!--\n<em>syntax: doesFileExist(&amp;fPath, bRelativeToData = true)</em>\n<em>name: doesFileExist</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: const filesystem::path &amp;fPath, bool bRelativeToData=true</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: True</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Check if a file or directory exists at a given path.</p>\n<p><strong>Parameters:</strong></p>\n<p>fPath file path</p>\n<p>bRelativeToData set to false if you are working with paths that\nare <em>not</em> in the data folder and want the direct path without relative\n&quot;../../&quot;</p>\n<p><strong>Returns</strong>: true if a file or directory exists</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool exists()</p>\n<p>&lt;!--\n<em>syntax: exists()</em>\n<em>name: exists</em>\n<em>returns: bool</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Check if a file exists at the current path.</p>\n<p><strong>Returns</strong>: true if the file exists</p>\n<p>_description: _</p>\n<p>Tests whether a file path exists or not.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###string getAbsolutePath()</p>\n<p>&lt;!--\n<em>syntax: getAbsolutePath()</em>\n<em>name: getAbsolutePath</em>\n<em>returns: string</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>\\biref Get the absolute, full path of the file,\nie. &quot;images&quot; -&gt; &quot;/Users/mickey/of/apps/myApps/Donald/bin/data/images&quot;.</p>\n<p><strong>Returns</strong>: current path as an absolute path</p>\n<p>_description: _</p>\n<p>Returns the absolute path to the file, on OSX this will be something like /Users/name/openFrameworks/apps/app/data/file.xml on Windows it will something like C:\\Documents\\openframeworks\\apps\\app\\data\\file.xml</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###string getBaseName()</p>\n<p>&lt;!--\n<em>syntax: getBaseName()</em>\n<em>name: getBaseName</em>\n<em>returns: string</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>\\biref Get the current path without its last component,\nie. &quot;images/duck.jpg&quot; -&gt; &quot;images&quot; and\n&quot;images/some/folder&quot; -&gt; &quot;images/some&quot;.</p>\n<p><strong>Returns</strong>: current path basename</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###string getEnclosingDirectory()</p>\n<p>&lt;!--\n<em>syntax: getEnclosingDirectory()</em>\n<em>name: getEnclosingDirectory</em>\n<em>returns: string</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Get the enclosing parent directory of a path,\nie. &quot;images/duck.jpg&quot; -&gt; &quot;images&quot;, assumes the path is in the data\ndirectory.</p>\n<p><strong>Returns</strong>: current path's enclosing directory</p>\n<p>_description: _</p>\n<p>Returns the relative path to the directory containing the file, for instance:</p>\n<pre><code>\nofFile <span class=\"token function\">file</span><span class=\"token punctuation\">(</span><span class=\"token function\">ofToDataPath</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>foo<span class=\"token punctuation\">.</span>xml<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ncout <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> file<span class=\"token punctuation\">.</span><span class=\"token function\">getEnclosingDirectory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// prints &amp;quot;../../../data/xml&amp;quot;</span>\n\n</code></pre>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###string getExtension()</p>\n<p>&lt;!--\n<em>syntax: getExtension()</em>\n<em>name: getExtension</em>\n<em>returns: string</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Get the current path without its extension,\nie. &quot;duck.jpg&quot; -&gt;&quot;duck&quot;.</p>\n<p><strong>Returns</strong>: current path file extension</p>\n<p>_description: _</p>\n<p>Returns the extension of the file.</p>\n<pre><code>    ofFile <span class=\"token function\">file</span><span class=\"token punctuation\">(</span><span class=\"token function\">ofToDataPath</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>foo<span class=\"token punctuation\">.</span>xml<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cout <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> file<span class=\"token punctuation\">.</span><span class=\"token function\">getExtension</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###filebuf * getFileBuffer()</p>\n<p>&lt;!--\n<em>syntax: getFileBuffer()</em>\n<em>name: getFileBuffer</em>\n<em>returns: filebuf *</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Read the entire contents of the currently opened file into an\noutput stream.</p>\n<p>This is basically an easy to use equivalent to rdbuf():\nie. ofLogNotice() &lt;&lt; file.getFileBuffer();\nwrite_file &lt;&lt; file.getFileBuffer();</p>\n<p>\\return output stream</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###string getFileName()</p>\n<p>&lt;!--\n<em>syntax: getFileName()</em>\n<em>name: getFileName</em>\n<em>returns: string</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Get the filename of the current path by stripping the parent\ndirectories, ie. &quot;images/duck.jpg&quot;  -&gt; &quot;duck.jpg&quot;.</p>\n<p><strong>Returns</strong>: current path filename</p>\n<p>_description: _</p>\n<p>Returns the actual file name.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###uint64_t getSize()</p>\n<p>&lt;!--\n<em>syntax: getSize()</em>\n<em>name: getSize</em>\n<em>returns: uint64_t</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>get the size of the file at the current file path</p>\n<p><strong>Returns</strong>: size in bytes</p>\n<p>_description: _</p>\n<p>Gets the size of the file at the file path.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool isDevice()</p>\n<p>&lt;!--\n<em>syntax: isDevice()</em>\n<em>name: isDevice</em>\n<em>returns: bool</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Check if the current path is a device file.</p>\n<p>Works on Mac &amp; Linux which can represent devices as files, however\nalways returns false on Windows.</p>\n<p><strong>Returns</strong>: true if a device file</p>\n<p>_description: _</p>\n<p>Returns whether the file path points to a mounted device.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool isDirectory()</p>\n<p>&lt;!--\n<em>syntax: isDirectory()</em>\n<em>name: isDirectory</em>\n<em>returns: bool</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Check if the current path is a directory and not a file.</p>\n<p><strong>Returns</strong>: true if a directory</p>\n<p>_description: _</p>\n<p>Returns whether the file path points to a directory or not.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool isFile()</p>\n<p>&lt;!--\n<em>syntax: isFile()</em>\n<em>name: isFile</em>\n<em>returns: bool</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Check if the current path is a file and not a directory.</p>\n<p><strong>Returns</strong>: true if a file</p>\n<p>_description: _</p>\n<p>Whether the file path points to a file (it could also be a directory)</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool isHidden()</p>\n<p>&lt;!--\n<em>syntax: isHidden()</em>\n<em>name: isHidden</em>\n<em>returns: bool</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Check if the current path is hidden.</p>\n<p>Works on Mac &amp; Linux which denote hidden files by prepending a period\nto the filename -&gt; &quot;.hello&quot;, however always returns false on Windows.</p>\n<p><strong>Returns</strong>: true if hidden</p>\n<p>_description: _</p>\n<p>Returns whether the file path points to a hidden file or not.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool isLink()</p>\n<p>&lt;!--\n<em>syntax: isLink()</em>\n<em>name: isLink</em>\n<em>returns: bool</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Check if the current path is a system link to another file or\ndirectory.</p>\n<p><strong>Returns</strong>: true if a system link</p>\n<p>_description: _</p>\n<p>Returns whether file is an alias or not.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool isWriteMode()</p>\n<p>&lt;!--\n<em>syntax: isWriteMode()</em>\n<em>name: isWriteMode</em>\n<em>returns: bool</em>\n_returns_description: _\n_parameters: _\n<em>access: private</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool moveFromTo(&amp;pathSrc, &amp;pathDst, bRelativeToData = true, overwrite = false)</p>\n<p>&lt;!--\n<em>syntax: moveFromTo(&amp;pathSrc, &amp;pathDst, bRelativeToData = true, overwrite = false)</em>\n<em>name: moveFromTo</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: const filesystem::path &amp;pathSrc, const filesystem::path &amp;pathDst, bool bRelativeToData=true, bool overwrite=false</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: True</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Move source path to destination path.</p>\n<p>Moves relative to the data path &amp; does <em>not</em> overwrite by default\nassumes the source &amp; destination path is in the data directory.</p>\n<p><strong>Parameters:</strong></p>\n<p>pathSrc source file or directory path</p>\n<p>pathDst destination file or directory path</p>\n<p>bRelativeToData set to false if you are working with paths that\nare <em>not</em> in the data folder</p>\n<p>overwrite set to true if you want to overwrite the file or\ndirectory at the new path</p>\n<p><strong>Warning</strong>: be careful with slashes here, appending a slash when moving a\nfolder may cause mad headaches in OSX</p>\n<p><strong>Returns</strong>: true if the move was successful</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool moveTo(&amp;path, bRelativeToData = true, overwrite = false)</p>\n<p>&lt;!--\n<em>syntax: moveTo(&amp;path, bRelativeToData = true, overwrite = false)</em>\n<em>name: moveTo</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: const filesystem::path &amp;path, bool bRelativeToData=true, bool overwrite=false</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Move the current file or directory path to a new path.</p>\n<p>Moves relative to the data path &amp; does <em>not</em> overwrite by default\ndoes not change the current path &amp; assumes the new path is in the data\nfolder.</p>\n<p><strong>Parameters:</strong></p>\n<p>path destination file or directory path</p>\n<p>bRelativeToData set to false if you are working with paths that\nare <em>not</em> in the data folder</p>\n<p>overwrite set to true if you want to overwrite the file or\ndirectory at the new path</p>\n<p><strong>Returns</strong>: true if the copy was successful</p>\n<p>_description: _</p>\n<p>Moves the file to the location specified by path. This is similar to the mv command.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<h3>ofFile(&amp;mom)</h3>\n<p>&lt;!--\n<em>syntax: ofFile(&amp;mom)</em>\n<em>name: ofFile</em>\n_returns: _\n_returns_description: _\n<em>parameters: const ofFile &amp;mom</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Create a new file path using the same path &amp; settings of another\nfile.</p>\n<p><strong>Parameters:</strong></p>\n<p>mom ofFile instance source</p>\n<p>_description: _</p>\n<p>Copy constructor for copying one ofFile into another</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<h3>ofFile(&amp;path, mode = ReadOnly, binary = true)</h3>\n<p>&lt;!--\n<em>syntax: ofFile(&amp;path, mode = ReadOnly, binary = true)</em>\n<em>name: ofFile</em>\n_returns: _\n_returns_description: _\n<em>parameters: const filesystem::path &amp;path, ofFile::Mode mode=ReadOnly, bool binary=true</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Create a new ofFile instance and attempt to open the path as a\nfile.</p>\n<p>Opens as a binary file with read only access by default.</p>\n<p><strong>Parameters:</strong></p>\n<p>path file path</p>\n<p>mode file access mode depending on how you plan to use the file\n(read only, read write, etc)</p>\n<p>binary set to false if you are working with a text file &amp; want\nlines split at endline characters automatically</p>\n<p>_description: _</p>\n<p>Creates an ofFile using the file path and mode specified. Note that if the file doesn't actually exist on the file system this doesn't actually create file until you call create().</p>\n<pre><code>ofFile <span class=\"token function\">fileToRead</span><span class=\"token punctuation\">(</span><span class=\"token function\">ofToDataPath</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>dictionary<span class=\"token punctuation\">.</span>txt<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// a file that exists</span>\n</code></pre>\n<pre><code>ofFile <span class=\"token function\">newFile</span><span class=\"token punctuation\">(</span><span class=\"token function\">ofToDataPath</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>temp<span class=\"token punctuation\">.</span>txt<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> ofFile<span class=\"token operator\">::</span>Write<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// file doesn't exist yet</span>\nnewFile<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// now file exists </span>\n</code></pre>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<h3>ofFile()</h3>\n<p>&lt;!--\n<em>syntax: ofFile()</em>\n<em>name: ofFile</em>\n_returns: _\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Create an ofFile instance.</p>\n<p>Does not refer to a specific file until you either open a file or create\na file or directory path.</p>\n<p>_description: _</p>\n<p>Creates an empty ofFile.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool open(&amp;path, mode = ReadOnly, binary = true)</p>\n<p>&lt;!--\n<em>syntax: open(&amp;path, mode = ReadOnly, binary = true)</em>\n<em>name: open</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: const filesystem::path &amp;path, ofFile::Mode mode=ReadOnly, bool binary=true</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Open the path as a file.</p>\n<p>Opens as a text file with read only access by default.</p>\n<p><strong>Parameters:</strong></p>\n<p>path file path</p>\n<p>mode file access mode depending on how you plan to use the file\n(read only, read write, etc)</p>\n<p>binary set to false if you are reading a text file &amp; want lines\nsplit at endline characters automatically</p>\n<p><strong>Returns</strong>: true if the path was opened</p>\n<p>_description: _</p>\n<p>Opens the file with the file mode, either Reference, ReadOnly, WriteOnly, ReadWrite, Append</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool openFromCWD(&amp;path, mode = ReadOnly, binary = true)</p>\n<p>&lt;!--\n<em>syntax: openFromCWD(&amp;path, mode = ReadOnly, binary = true)</em>\n<em>name: openFromCWD</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: const filesystem::path &amp;path, ofFile::Mode mode=ReadOnly, bool binary=true</em>\n<em>access: public</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Open the path as a file.</p>\n<p>Opens as a text file with read only access by default from the current working directory without internally calling ofToDataPath.</p>\n<p><strong>Parameters:</strong></p>\n<p>path file path</p>\n<p>mode file access mode depending on how you plan to use the file\n(read only, read write, etc)</p>\n<p>binary set to false if you are reading a text file &amp; want lines\nsplit at endline characters automatically</p>\n<p><strong>Returns</strong>: true if the path was opened</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool openStream(_mode, binary)</p>\n<p>&lt;!--\n_syntax: openStream(<em>mode, binary)</em>\n<em>name: openStream</em>\n<em>returns: bool</em>\n_returns_description: _\n_parameters: ofFile::Mode <em>mode, bool binary</em>\n<em>access: private</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool operator!=(&amp;file)</p>\n<p>&lt;!--\n<em>syntax: operator!=(&amp;file)</em>\n<em>name: operator!=</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: const ofFile &amp;file</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Tests whether a file path is not equal to the file path of the ofFile on the right hand side.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool operator&lt;(&amp;file)</p>\n<p>&lt;!--\n<em>syntax: operator&lt;(&amp;file)</em>\n<em>name: operator&lt;</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: const ofFile &amp;file</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Tests whether a file path is greater than the file path of the ofFile on the right hand side.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool operator&lt;=(&amp;file)</p>\n<p>&lt;!--\n<em>syntax: operator&lt;=(&amp;file)</em>\n<em>name: operator&lt;=</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: const ofFile &amp;file</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Tests whether a file path is lesser or equal than the file path of the ofFile on the right hand side.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###ofFile &amp; operator=(&amp;mom)</p>\n<p>&lt;!--\n<em>syntax: operator=(&amp;mom)</em>\n<em>name: operator=</em>\n<em>returns: ofFile &amp;</em>\n_returns_description: _\n<em>parameters: const ofFile &amp;mom</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Copy the path and settings of an ofFile into this instance.</p>\n<p><strong>Parameters:</strong></p>\n<p>mom ofFile instance source</p>\n<p>_description: _</p>\n<p>Equals operator which allows you to do this:</p>\n<pre><code>ofFile f1 <span class=\"token operator\">=</span> f2<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool operator==(&amp;file)</p>\n<p>&lt;!--\n<em>syntax: operator==(&amp;file)</em>\n<em>name: operator==</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: const ofFile &amp;file</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Tests whether a file path is equal to the file path of the  ofFile on the right hand side.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool operator&gt;(&amp;file)</p>\n<p>&lt;!--\n<em>syntax: operator&gt;(&amp;file)</em>\n<em>name: operator&gt;</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: const ofFile &amp;file</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Tests whether a file path is greater than the file path of the ofFile on the right hand side.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool operator&gt;=(&amp;file)</p>\n<p>&lt;!--\n<em>syntax: operator&gt;=(&amp;file)</em>\n<em>name: operator&gt;=</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: const ofFile &amp;file</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Tests whether a file path is greater than or equal to the file path of the ofFile on the right hand side.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###string path()</p>\n<p>&lt;!--\n<em>syntax: path()</em>\n<em>name: path</em>\n<em>returns: string</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Get the current path.</p>\n<p><strong>Returns</strong>: current path</p>\n<p>_description: _</p>\n<p>Returns the string of the ofFile file path.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###ofBuffer readToBuffer()</p>\n<p>&lt;!--\n<em>syntax: readToBuffer()</em>\n<em>name: readToBuffer</em>\n<em>returns: ofBuffer</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Read the contents of a file at the current path into a buffer.</p>\n<p><strong>Returns</strong>: buffer with file contents</p>\n<p>_description: _</p>\n<p>Read the file into an ofBuffer object and return it.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool remove(recursive = false)</p>\n<p>&lt;!--\n<em>syntax: remove(recursive = false)</em>\n<em>name: remove</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: bool recursive=false</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Removes the file or directory at the current path.</p>\n<p>Does not remove non-empty directories by default.</p>\n<p><strong>Warning</strong>: Be careful! This deletes a file or folder. :)</p>\n<p><strong>Parameters:</strong></p>\n<p>recursive set to true to remove a non-empty directory and its\ncontents</p>\n<p><strong>Returns</strong>: true if the path was removed successfully</p>\n<p>_description: _</p>\n<p>deletes a file or folder, be careful as this is not undo-able.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool removeFile(&amp;path, bRelativeToData = true)</p>\n<p>&lt;!--\n<em>syntax: removeFile(&amp;path, bRelativeToData = true)</em>\n<em>name: removeFile</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: const filesystem::path &amp;path, bool bRelativeToData=true</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: True</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Remove a file or directory at a given path.</p>\n<p><strong>Parameters:</strong></p>\n<p>bRelativeToData set to false if you are working with paths that\nare <em>not</em> in the data folder and want the direct path without relative\n&quot;../../&quot;</p>\n<p><strong>Returns</strong>: true if the path was removed successfully</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool renameTo(&amp;path, bRelativeToData = true, overwrite = false)</p>\n<p>&lt;!--\n<em>syntax: renameTo(&amp;path, bRelativeToData = true, overwrite = false)</em>\n<em>name: renameTo</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: const filesystem::path &amp;path, bool bRelativeToData=true, bool overwrite=false</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Rename the current file or directory path to a new path.</p>\n<p>Renames relative to the data path &amp; does <em>not</em> overwrite by default\ndoes not change the current path &amp; assumes the new path is in the data\nfolder.</p>\n<p><strong>Parameters:</strong></p>\n<p>path destination file or directory path</p>\n<p>bRelativeToData set to false if you are working with paths that\nare <em>not</em> in the data folder</p>\n<p>overwrite set to true if you want to overwrite the file or\ndirectory at the new path</p>\n<p><strong>Returns</strong>: true if the copy was successful</p>\n<p>_description: _</p>\n<p>Renames the file with the new file name. If you specify a different path then this will move the file as well.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setExecutable(executable = true)</p>\n<p>&lt;!--\n<em>syntax: setExecutable(executable = true)</em>\n<em>name: setExecutable</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: bool executable=true</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Set the executable flag of the current path.</p>\n<p>_description: _</p>\n<p>Toggles the file as executable or not executable.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setReadable(readable = true)</p>\n<p>&lt;!--\n<em>syntax: setReadable(readable = true)</em>\n<em>name: setReadable</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: bool readable=true</em>\n<em>access: public</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Set the readable flag of the current path.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setWriteable(writeable = true)</p>\n<p>&lt;!--\n<em>syntax: setWriteable(writeable = true)</em>\n<em>name: setWriteable</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: bool writeable=true</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Set the writable flag of the current path.</p>\n<p>_description: _</p>\n<p>Toggles the file as writeable or not writeable.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool writeFromBuffer(&amp;buffer)</p>\n<p>&lt;!--\n<em>syntax: writeFromBuffer(&amp;buffer)</em>\n<em>name: writeFromBuffer</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: const ofBuffer &amp;buffer</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Write the contents of a buffer into a file at the current path.</p>\n<p><strong>Parameters:</strong></p>\n<p>buffer source byte buffer</p>\n<p><strong>Returns</strong>: true if buffer's contents written successfully</p>\n<p>_description: _</p>\n<p>Write an ofBuffer instance to the file path.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<h3>~ofFile()</h3>\n<p>&lt;!--\n<em>syntax: ~ofFile()</em>\n<em>name: ~ofFile</em>\n_returns: _\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Destructor</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>##Variables</p>\n<p>###bool  binary</p>\n<p>&lt;!--\n<em>name: binary</em>\n_type: bool _\n<em>access: private</em>\n<em>version_started: 0.8.0</em>\n_version_deprecated: _\n_summary: _\n<em>visible: True</em>\n<em>constant: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###Mode mode</p>\n<p>&lt;!--\n<em>name: mode</em>\n<em>type: Mode</em>\n<em>access: private</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>visible: True</em>\n<em>constant: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###Poco myFile</p>\n<p>&lt;!--\n<em>name: myFile</em>\n<em>type: Poco</em>\n<em>access: private</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>visible: True</em>\n<em>constant: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n","raw":"#class ofFile\n\n\n<!--\n_visible: True_\n_advanced: False_\n_istemplated: False_\n_extends: std::fstream_\n-->\n\n##InlineDescription\n\n\n\npath to a file or directory\n\ninherits from an fstream so you can read/write using the stream operators\nonce a file path has been opened\n\n\n\n\n\n##Description\n\nofFile wraps functionality for opening, reading, writing, and modifying files on your computer.\n\n~~~~{.cpp}\n\nofFile file;\n\nfile.open(ofToDataPath(\"temp.xml\"), ofFile::ReadWrite, false);\nofBuffer buff = file.readToBuffer();\n~~~~\n\nYou can do the same with the bufferFromFile method:\n\n~~~~{.cpp}\nofBuffer ofBufferFromFile(const string & path, bool binary=false);\n~~~~\n\nTo write a buffer to a file, use ofBufferToFile()\n\n~~~~{.cpp}\nofBuffer dataBuffer;\n// fill the buffer with something important\nbool fileWritten = ofBufferToFile(\"data.dat\", dataBuffer); \n\n~~~~\n\nYou can also compare files using the ==, !=, <, >, <=, >= operators. This is done so that the files can be stored in std::containers and sorted.\n\n~~~~{.cpp}    \nofFile file(ofToDataPath(\"foo.xml\"));\nofFile file2(ofToDataPath(\"foo2.xml\"));    \ncout << \"is foo less than foo2? \" << ((file < file2) ? \"true\" : \"false\") << endl;\n~~~~\n\n\n\n\n\n##Methods\n\n\n\n###bool canExecute()\n\n<!--\n_syntax: canExecute()_\n_name: canExecute_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCheck if the current path is executable.\n\n\n**Returns**: true if executable\n\n\n\n\n\n_description: _\n\nWhether the file is an executable file.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool canRead()\n\n<!--\n_syntax: canRead()_\n_name: canRead_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCheck if the current path is readable.\n\n\n**Returns**: true if readable\n\n\n\n\n\n_description: _\n\nWhether the file can be read or not.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool canWrite()\n\n<!--\n_syntax: canWrite()_\n_name: canWrite_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCheck if the current path is writable.\n\n\n**Returns**: true if writable\n\n\n\n\n\n_description: _\n\nWhether the file can be written to or not.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool changeMode(mode, binary = true)\n\n<!--\n_syntax: changeMode(mode, binary = true)_\n_name: changeMode_\n_returns: bool_\n_returns_description: _\n_parameters: ofFile::Mode mode, bool binary=true_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nReopen the current file path with a different access mode.\n\n\n**Parameters:**\n\nmode file access mode depending on how you plan to use the file\n(read only, read write, etc)\n\nbinary set to false if you are reading a text file & want lines\nsplit at endline characters automatically\n\n**Returns**: true if the file was reopened with the new access mode(s).\n\n\n\n\n\n_description: _\n\nChanges the mode of the file from the current mode to the one passed in.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void close()\n\n<!--\n_syntax: close()_\n_name: close_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nClose a currently open file.\n\n\n\n\n\n_description: _\n\nCloses the ofFile instance.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void copyFrom(&mom)\n\n<!--\n_syntax: copyFrom(&mom)_\n_name: copyFrom_\n_returns: void_\n_returns_description: _\n_parameters: const ofFile &mom_\n_access: private_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool copyFromTo(&pathSrc, &pathDst, bRelativeToData = true, overwrite = false)\n\n<!--\n_syntax: copyFromTo(&pathSrc, &pathDst, bRelativeToData = true, overwrite = false)_\n_name: copyFromTo_\n_returns: bool_\n_returns_description: _\n_parameters: const filesystem::path &pathSrc, const filesystem::path &pathDst, bool bRelativeToData=true, bool overwrite=false_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: True_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCopy source path to destination path.\n\nCopies relative to the data path & does *not* overwrite by default\nassumes the source & destination path is in the data directory.\n\n\n**Parameters:**\n\npathSrc source file or directory path\n\npathDst destination file or directory path\n\nbRelativeToData set to false if you are working with paths that\nare *not* in the data directory\n\noverwrite set to true if you want to overwrite the file or\ndirectory at the new path\n\n**Returns**: true if the copy was successful\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool copyTo(&path, bRelativeToData = true, overwrite = false)\n\n<!--\n_syntax: copyTo(&path, bRelativeToData = true, overwrite = false)_\n_name: copyTo_\n_returns: bool_\n_returns_description: _\n_parameters: const filesystem::path &path, bool bRelativeToData=true, bool overwrite=false_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCopy the current file or directory path to a new path.\n\nCopies relative to the data path & does *not* overwrite by default\ndoes not change the current path & assumes the new path is in the data\nfolder.\n\n\n**Parameters:**\n\npath destination file or directory path\n\nbRelativeToData set to false if you are working with paths that\nare *not* in the data folder\n\noverwrite set to true if you want to overwrite the file or\ndirectory at the new path\n\n**Returns**: true if the copy was successful\n\n\n\n\n\n_description: _\n\nCopy the file from its current location into the path parameter. This is similar to the cp command.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool create(&path)\n\n<!--\n_syntax: create(&path)_\n_name: create_\n_returns: bool_\n_returns_description: _\n_parameters: const filesystem::path &path_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCreate a file at a given path.\n\nCreates as a write only binary file by default.\n\n\n**Parameters:**\n\npath file path\n\n**Returns**: true if the file was created\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool create()\n\n<!--\n_syntax: create()_\n_name: create_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCreate a file at the current path.\n\nCreates as a write only binary file by default.\n\n\n**Returns**: true if the file was created\n\n\n\n\n\n_description: _\n\nIf the ofFile contains a file path that doesn't exist yet, calling create() generates the file.\n\n~~~~{.cpp}\nofFile newFile(ofToDataPath(\"temp.txt\"), ofFile::Write); // file doesn't exist yet\nnewFile.create(); // now file exists\n~~~~\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool doesFileExist(&fPath, bRelativeToData = true)\n\n<!--\n_syntax: doesFileExist(&fPath, bRelativeToData = true)_\n_name: doesFileExist_\n_returns: bool_\n_returns_description: _\n_parameters: const filesystem::path &fPath, bool bRelativeToData=true_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: True_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCheck if a file or directory exists at a given path.\n\n\n**Parameters:**\n\nfPath file path\n\nbRelativeToData set to false if you are working with paths that\nare *not* in the data folder and want the direct path without relative\n\"../../\"\n\n**Returns**: true if a file or directory exists\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool exists()\n\n<!--\n_syntax: exists()_\n_name: exists_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCheck if a file exists at the current path.\n\n\n**Returns**: true if the file exists\n\n\n\n\n\n_description: _\n\nTests whether a file path exists or not.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###string getAbsolutePath()\n\n<!--\n_syntax: getAbsolutePath()_\n_name: getAbsolutePath_\n_returns: string_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\\biref Get the absolute, full path of the file,\nie. \"images\" -> \"/Users/mickey/of/apps/myApps/Donald/bin/data/images\".\n\n\n**Returns**: current path as an absolute path\n\n\n\n\n\n_description: _\n\nReturns the absolute path to the file, on OSX this will be something like /Users/name/openFrameworks/apps/app/data/file.xml on Windows it will something like C:\\Documents\\openframeworks\\apps\\app\\data\\file.xml\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###string getBaseName()\n\n<!--\n_syntax: getBaseName()_\n_name: getBaseName_\n_returns: string_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\\biref Get the current path without its last component,\nie. \"images/duck.jpg\" -> \"images\" and\n\"images/some/folder\" -> \"images/some\".\n\n\n**Returns**: current path basename\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###string getEnclosingDirectory()\n\n<!--\n_syntax: getEnclosingDirectory()_\n_name: getEnclosingDirectory_\n_returns: string_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nGet the enclosing parent directory of a path,\nie. \"images/duck.jpg\" -> \"images\", assumes the path is in the data\ndirectory.\n\n\n**Returns**: current path's enclosing directory\n\n\n\n\n\n_description: _\n\nReturns the relative path to the directory containing the file, for instance:\n\n~~~~{.cpp}\n\nofFile file(ofToDataPath(\"foo.xml\"));\ncout << file.getEnclosingDirectory(); // prints \"../../../data/xml\"\n\n~~~~\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###string getExtension()\n\n<!--\n_syntax: getExtension()_\n_name: getExtension_\n_returns: string_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nGet the current path without its extension,\nie. \"duck.jpg\" ->\"duck\".\n\n\n**Returns**: current path file extension\n\n\n\n\n\n_description: _\n\nReturns the extension of the file.\n\n~~~~{.cpp}\n    ofFile file(ofToDataPath(\"foo.xml\"));\n    cout << file.getExtension();\n~~~~\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###filebuf * getFileBuffer()\n\n<!--\n_syntax: getFileBuffer()_\n_name: getFileBuffer_\n_returns: filebuf *_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nRead the entire contents of the currently opened file into an\noutput stream.\n\nThis is basically an easy to use equivalent to rdbuf():\nie. ofLogNotice() << file.getFileBuffer();\n    write_file << file.getFileBuffer();\n\n\\return output stream\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###string getFileName()\n\n<!--\n_syntax: getFileName()_\n_name: getFileName_\n_returns: string_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nGet the filename of the current path by stripping the parent\ndirectories, ie. \"images/duck.jpg\"  -> \"duck.jpg\".\n\n\n**Returns**: current path filename\n\n\n\n\n\n_description: _\n\nReturns the actual file name.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###uint64_t getSize()\n\n<!--\n_syntax: getSize()_\n_name: getSize_\n_returns: uint64_t_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nget the size of the file at the current file path\n\n\n**Returns**: size in bytes\n\n\n\n\n\n_description: _\n\nGets the size of the file at the file path.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool isDevice()\n\n<!--\n_syntax: isDevice()_\n_name: isDevice_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCheck if the current path is a device file.\n\nWorks on Mac & Linux which can represent devices as files, however\nalways returns false on Windows.\n\n\n**Returns**: true if a device file\n\n\n\n\n\n_description: _\n\nReturns whether the file path points to a mounted device.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool isDirectory()\n\n<!--\n_syntax: isDirectory()_\n_name: isDirectory_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCheck if the current path is a directory and not a file.\n\n\n**Returns**: true if a directory\n\n\n\n\n\n_description: _\n\nReturns whether the file path points to a directory or not.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool isFile()\n\n<!--\n_syntax: isFile()_\n_name: isFile_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCheck if the current path is a file and not a directory.\n\n\n**Returns**: true if a file\n\n\n\n\n\n_description: _\n\nWhether the file path points to a file (it could also be a directory)\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool isHidden()\n\n<!--\n_syntax: isHidden()_\n_name: isHidden_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCheck if the current path is hidden.\n\nWorks on Mac & Linux which denote hidden files by prepending a period\nto the filename -> \".hello\", however always returns false on Windows.\n\n\n**Returns**: true if hidden\n\n\n\n\n\n_description: _\n\nReturns whether the file path points to a hidden file or not.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool isLink()\n\n<!--\n_syntax: isLink()_\n_name: isLink_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCheck if the current path is a system link to another file or\ndirectory.\n\n\n**Returns**: true if a system link\n\n\n\n\n\n_description: _\n\nReturns whether file is an alias or not.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool isWriteMode()\n\n<!--\n_syntax: isWriteMode()_\n_name: isWriteMode_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: private_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool moveFromTo(&pathSrc, &pathDst, bRelativeToData = true, overwrite = false)\n\n<!--\n_syntax: moveFromTo(&pathSrc, &pathDst, bRelativeToData = true, overwrite = false)_\n_name: moveFromTo_\n_returns: bool_\n_returns_description: _\n_parameters: const filesystem::path &pathSrc, const filesystem::path &pathDst, bool bRelativeToData=true, bool overwrite=false_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: True_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nMove source path to destination path.\n\nMoves relative to the data path & does *not* overwrite by default\nassumes the source & destination path is in the data directory.\n\n\n**Parameters:**\n\npathSrc source file or directory path\n\npathDst destination file or directory path\n\nbRelativeToData set to false if you are working with paths that\nare *not* in the data folder\n\noverwrite set to true if you want to overwrite the file or\ndirectory at the new path\n\n**Warning**: be careful with slashes here, appending a slash when moving a\nfolder may cause mad headaches in OSX\n\n**Returns**: true if the move was successful\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool moveTo(&path, bRelativeToData = true, overwrite = false)\n\n<!--\n_syntax: moveTo(&path, bRelativeToData = true, overwrite = false)_\n_name: moveTo_\n_returns: bool_\n_returns_description: _\n_parameters: const filesystem::path &path, bool bRelativeToData=true, bool overwrite=false_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nMove the current file or directory path to a new path.\n\nMoves relative to the data path & does *not* overwrite by default\ndoes not change the current path & assumes the new path is in the data\nfolder.\n\n\n**Parameters:**\n\npath destination file or directory path\n\nbRelativeToData set to false if you are working with paths that\nare *not* in the data folder\n\noverwrite set to true if you want to overwrite the file or\ndirectory at the new path\n\n**Returns**: true if the copy was successful\n\n\n\n\n\n_description: _\n\nMoves the file to the location specified by path. This is similar to the mv command.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n### ofFile(&mom)\n\n<!--\n_syntax: ofFile(&mom)_\n_name: ofFile_\n_returns: _\n_returns_description: _\n_parameters: const ofFile &mom_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCreate a new file path using the same path & settings of another\nfile.\n\n\n**Parameters:**\n\nmom ofFile instance source\n\n\n\n\n\n_description: _\n\nCopy constructor for copying one ofFile into another \n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n### ofFile(&path, mode = ReadOnly, binary = true)\n\n<!--\n_syntax: ofFile(&path, mode = ReadOnly, binary = true)_\n_name: ofFile_\n_returns: _\n_returns_description: _\n_parameters: const filesystem::path &path, ofFile::Mode mode=ReadOnly, bool binary=true_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCreate a new ofFile instance and attempt to open the path as a\nfile.\n\nOpens as a binary file with read only access by default.\n\n\n**Parameters:**\n\npath file path\n\nmode file access mode depending on how you plan to use the file\n(read only, read write, etc)\n\nbinary set to false if you are working with a text file & want\nlines split at endline characters automatically\n\n\n\n\n\n_description: _\n\nCreates an ofFile using the file path and mode specified. Note that if the file doesn't actually exist on the file system this doesn't actually create file until you call create().\n\n~~~~{.cpp}\nofFile fileToRead(ofToDataPath(\"dictionary.txt\")); // a file that exists\n~~~~\n\n~~~~{.cpp}\nofFile newFile(ofToDataPath(\"temp.txt\"), ofFile::Write); // file doesn't exist yet\nnewFile.create(); // now file exists \n~~~~\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n### ofFile()\n\n<!--\n_syntax: ofFile()_\n_name: ofFile_\n_returns: _\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCreate an ofFile instance.\n\nDoes not refer to a specific file until you either open a file or create\na file or directory path.\n\n\n\n\n\n_description: _\n\nCreates an empty ofFile.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool open(&path, mode = ReadOnly, binary = true)\n\n<!--\n_syntax: open(&path, mode = ReadOnly, binary = true)_\n_name: open_\n_returns: bool_\n_returns_description: _\n_parameters: const filesystem::path &path, ofFile::Mode mode=ReadOnly, bool binary=true_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nOpen the path as a file.\n\nOpens as a text file with read only access by default.\n\n\n**Parameters:**\n\npath file path\n\nmode file access mode depending on how you plan to use the file\n(read only, read write, etc)\n\nbinary set to false if you are reading a text file & want lines\nsplit at endline characters automatically\n\n**Returns**: true if the path was opened\n\n\n\n\n\n_description: _\n\nOpens the file with the file mode, either Reference, ReadOnly, WriteOnly, ReadWrite, Append\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool openFromCWD(&path, mode = ReadOnly, binary = true)\n\n<!--\n_syntax: openFromCWD(&path, mode = ReadOnly, binary = true)_\n_name: openFromCWD_\n_returns: bool_\n_returns_description: _\n_parameters: const filesystem::path &path, ofFile::Mode mode=ReadOnly, bool binary=true_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nOpen the path as a file.\n\nOpens as a text file with read only access by default from the current working directory without internally calling ofToDataPath.\n\n\n**Parameters:**\n\npath file path\n\nmode file access mode depending on how you plan to use the file\n(read only, read write, etc)\n\nbinary set to false if you are reading a text file & want lines\nsplit at endline characters automatically\n\n**Returns**: true if the path was opened\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool openStream(_mode, binary)\n\n<!--\n_syntax: openStream(_mode, binary)_\n_name: openStream_\n_returns: bool_\n_returns_description: _\n_parameters: ofFile::Mode _mode, bool binary_\n_access: private_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool operator!=(&file)\n\n<!--\n_syntax: operator!=(&file)_\n_name: operator!=_\n_returns: bool_\n_returns_description: _\n_parameters: const ofFile &file_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nTests whether a file path is not equal to the file path of the ofFile on the right hand side. \n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool operator<(&file)\n\n<!--\n_syntax: operator<(&file)_\n_name: operator<_\n_returns: bool_\n_returns_description: _\n_parameters: const ofFile &file_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nTests whether a file path is greater than the file path of the ofFile on the right hand side. \n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool operator<=(&file)\n\n<!--\n_syntax: operator<=(&file)_\n_name: operator<=_\n_returns: bool_\n_returns_description: _\n_parameters: const ofFile &file_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nTests whether a file path is lesser or equal than the file path of the ofFile on the right hand side.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###ofFile & operator=(&mom)\n\n<!--\n_syntax: operator=(&mom)_\n_name: operator=_\n_returns: ofFile &_\n_returns_description: _\n_parameters: const ofFile &mom_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCopy the path and settings of an ofFile into this instance.\n\n\n**Parameters:**\n\nmom ofFile instance source\n\n\n\n\n\n_description: _\n\nEquals operator which allows you to do this:\n\n~~~~{.cpp}\nofFile f1 = f2;\n~~~~\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool operator==(&file)\n\n<!--\n_syntax: operator==(&file)_\n_name: operator==_\n_returns: bool_\n_returns_description: _\n_parameters: const ofFile &file_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nTests whether a file path is equal to the file path of the  ofFile on the right hand side. \n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool operator>(&file)\n\n<!--\n_syntax: operator>(&file)_\n_name: operator>_\n_returns: bool_\n_returns_description: _\n_parameters: const ofFile &file_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nTests whether a file path is greater than the file path of the ofFile on the right hand side.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool operator>=(&file)\n\n<!--\n_syntax: operator>=(&file)_\n_name: operator>=_\n_returns: bool_\n_returns_description: _\n_parameters: const ofFile &file_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nTests whether a file path is greater than or equal to the file path of the ofFile on the right hand side.\n \n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###string path()\n\n<!--\n_syntax: path()_\n_name: path_\n_returns: string_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nGet the current path.\n\n\n**Returns**: current path\n\n\n\n\n\n_description: _\n\nReturns the string of the ofFile file path.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###ofBuffer readToBuffer()\n\n<!--\n_syntax: readToBuffer()_\n_name: readToBuffer_\n_returns: ofBuffer_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nRead the contents of a file at the current path into a buffer.\n\n\n**Returns**: buffer with file contents\n\n\n\n\n\n_description: _\n\nRead the file into an ofBuffer object and return it.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool remove(recursive = false)\n\n<!--\n_syntax: remove(recursive = false)_\n_name: remove_\n_returns: bool_\n_returns_description: _\n_parameters: bool recursive=false_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nRemoves the file or directory at the current path.\n\nDoes not remove non-empty directories by default.\n\n\n**Warning**: Be careful! This deletes a file or folder. :)\n\n**Parameters:**\n\nrecursive set to true to remove a non-empty directory and its\ncontents\n\n**Returns**: true if the path was removed successfully\n\n\n\n\n\n_description: _\n\ndeletes a file or folder, be careful as this is not undo-able. \n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool removeFile(&path, bRelativeToData = true)\n\n<!--\n_syntax: removeFile(&path, bRelativeToData = true)_\n_name: removeFile_\n_returns: bool_\n_returns_description: _\n_parameters: const filesystem::path &path, bool bRelativeToData=true_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: True_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nRemove a file or directory at a given path.\n\n\n**Parameters:**\n\nbRelativeToData set to false if you are working with paths that\nare *not* in the data folder and want the direct path without relative\n\"../../\"\n\n**Returns**: true if the path was removed successfully\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool renameTo(&path, bRelativeToData = true, overwrite = false)\n\n<!--\n_syntax: renameTo(&path, bRelativeToData = true, overwrite = false)_\n_name: renameTo_\n_returns: bool_\n_returns_description: _\n_parameters: const filesystem::path &path, bool bRelativeToData=true, bool overwrite=false_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nRename the current file or directory path to a new path.\n\nRenames relative to the data path & does *not* overwrite by default\ndoes not change the current path & assumes the new path is in the data\nfolder.\n\n\n**Parameters:**\n\npath destination file or directory path\n\nbRelativeToData set to false if you are working with paths that\nare *not* in the data folder\n\noverwrite set to true if you want to overwrite the file or\ndirectory at the new path\n\n**Returns**: true if the copy was successful\n\n\n\n\n\n_description: _\n\nRenames the file with the new file name. If you specify a different path then this will move the file as well.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setExecutable(executable = true)\n\n<!--\n_syntax: setExecutable(executable = true)_\n_name: setExecutable_\n_returns: void_\n_returns_description: _\n_parameters: bool executable=true_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nSet the executable flag of the current path.\n\n\n\n\n\n_description: _\n\nToggles the file as executable or not executable.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setReadable(readable = true)\n\n<!--\n_syntax: setReadable(readable = true)_\n_name: setReadable_\n_returns: void_\n_returns_description: _\n_parameters: bool readable=true_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nSet the readable flag of the current path.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setWriteable(writeable = true)\n\n<!--\n_syntax: setWriteable(writeable = true)_\n_name: setWriteable_\n_returns: void_\n_returns_description: _\n_parameters: bool writeable=true_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nSet the writable flag of the current path.\n\n\n\n\n\n_description: _\n\nToggles the file as writeable or not writeable.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool writeFromBuffer(&buffer)\n\n<!--\n_syntax: writeFromBuffer(&buffer)_\n_name: writeFromBuffer_\n_returns: bool_\n_returns_description: _\n_parameters: const ofBuffer &buffer_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nWrite the contents of a buffer into a file at the current path.\n\n\n**Parameters:**\n\nbuffer source byte buffer\n\n**Returns**: true if buffer's contents written successfully\n\n\n\n\n\n_description: _\n\nWrite an ofBuffer instance to the file path.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n### ~ofFile()\n\n<!--\n_syntax: ~ofFile()_\n_name: ~ofFile_\n_returns: _\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nDestructor\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n##Variables\n\n\n\n###bool  binary\n\n<!--\n_name: binary_\n_type: bool _\n_access: private_\n_version_started: 0.8.0_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###Mode mode\n\n<!--\n_name: mode_\n_type: Mode_\n_access: private_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###Poco myFile\n\n<!--\n_name: myFile_\n_type: Poco_\n_access: private_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n","type":"page"}}],"fetch":[]}