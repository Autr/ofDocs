{"data":[{"page":{"entry":{"name":"ofThreadChannel","filename":"ofThreadChannel.markdown","absolute":"/Users/gilbertsinnott/Code/openFrameworks/ofSite/documentation/utils/ofThreadChannel.markdown","path":"/documentation/utils/ofThreadChannel","route":"/documentation/utils/ofThreadChannel.markdown","dir":"../ofSite/documentation/utils","ext":"markdown","type":"page","id":2224,"parent":2196,"breadcrumbs":[2196,1718],"siblings":[],"translations":{}},"description":{"short":"<p>Safely send data between threads without additional synchronization.</p>\n<p>ofThreadChannel makes it easy to safely and efficiently share data between\nthreads without the need for shared memory, mutexes, or other\nsynchronization techniques. Additionally, ofThreadChannel employs a\nsignalling system that allows receiving threads to sleep until new data\narrives or the ofThreadChannel is closed.</p>\n<p>A single ofThreadChannel class is designed for one-way communication. In\nmost cases an additional ofThreadChannel can be used for two-way\ncommunication.</p>\n<p>Data is sent through the ofThreadChannel in a FIFO (first in, first out)\norder, guaranteeing that that data will be received in the same order that\nit was sent.</p>\n<p>If multiple threads attempt to send data using the same ofThreadChannel, the\nsend method will block the calling thread until it is free.</p>\n<p><strong>See also</strong>: https://github.com/openframeworks/ofBook/blob/master/chapters/threads/chapter.md\n\\tparam T The data type sent by the ofThreadChannel.</p>\n","full":"<h1></h1>\n"},"config":{"visible":"True","advanced":"False","istemplated":"False","extends":null},"methods":[{"syntax":"close()","name":"close","returns":"void","returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Close the ofThreadChannel.</p>\n<p>Closing the ofThreadChannel means that no new messages can be sent or\nreceived. All threads waiting to receive new values will be notified and\nall ofThreadChannel::receive and ofThreadChannel::tryReceive methods\nwill return false.</p>\n","desc":""},{"syntax":"empty()","name":"empty","returns":"bool","returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Queries empty channel.</p>\n<p>This call is only an approximation, since messages come from a different\nthread the channel can return true when calling empty() and then receive\na message right afterwards</p>\n","desc":""},{"syntax":"ofThreadChannel()","name":"ofThreadChannel","returns":null,"returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","desc":""},{"syntax":"receive(&sentValue)","name":"receive","returns":"bool","returns_description":null,"parameters":"T <span class=\"token operator\">&amp;</span>sentValue","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","desc":""},{"syntax":"send(&&value)","name":"send","returns":"bool","returns_description":null,"parameters":"T <span class=\"token operator\">&amp;&amp;</span>value","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","desc":""},{"syntax":"send(&value)","name":"send","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> T <span class=\"token operator\">&amp;</span>value","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","desc":""},{"syntax":"tryReceive(&sentValue)","name":"tryReceive","returns":"bool","returns_description":null,"parameters":"T <span class=\"token operator\">&amp;</span>sentValue","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","desc":""},{"syntax":"tryReceive(&sentValue, timeoutMs)","name":"tryReceive","returns":"bool","returns_description":null,"parameters":"T <span class=\"token operator\">&amp;</span>sentValue<span class=\"token punctuation\">,</span> int64_t timeoutMs","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","desc":""},{"name":"closed","type":"bool","access":"private","version_started":"0.9.0","version_deprecated":null,"summary":null,"visible":"True","constant":"False","advanced":"False","short":"<p>True if the channel is closed.</p>\n","desc":""},{"name":"condition","type":"condition_variable","access":"private","version_started":"0.9.0","version_deprecated":null,"summary":null,"visible":"True","constant":"False","advanced":"False","short":"<p>The condition even to notify receivers.</p>\n","desc":""},{"name":"mutex","type":"mutex","access":"private","version_started":"0.9.0","version_deprecated":null,"summary":null,"visible":"True","constant":"False","advanced":"False","short":"<p>The mutext to protect the data.</p>\n","desc":""},{"short":"<p>The FIFO data queue.</p>\n","desc":""},{}],"document":"<p>#class ofThreadChannel</p>\n<p>&lt;!--\n<em>visible: True</em>\n<em>advanced: False</em>\n<em>istemplated: False</em>\n_extends: _\n--&gt;</p>\n<p>##InlineDescription</p>\n<p>Safely send data between threads without additional synchronization.</p>\n<p>ofThreadChannel makes it easy to safely and efficiently share data between\nthreads without the need for shared memory, mutexes, or other\nsynchronization techniques. Additionally, ofThreadChannel employs a\nsignalling system that allows receiving threads to sleep until new data\narrives or the ofThreadChannel is closed.</p>\n<p>A single ofThreadChannel class is designed for one-way communication. In\nmost cases an additional ofThreadChannel can be used for two-way\ncommunication.</p>\n<p>Data is sent through the ofThreadChannel in a FIFO (first in, first out)\norder, guaranteeing that that data will be received in the same order that\nit was sent.</p>\n<p>If multiple threads attempt to send data using the same ofThreadChannel, the\nsend method will block the calling thread until it is free.</p>\n<p><strong>See also</strong>: https://github.com/openframeworks/ofBook/blob/master/chapters/threads/chapter.md\n\\tparam T The data type sent by the ofThreadChannel.</p>\n<p>##Description</p>\n<p>##Methods</p>\n<p>###void close()</p>\n<p>&lt;!--\n<em>syntax: close()</em>\n<em>name: close</em>\n<em>returns: void</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Close the ofThreadChannel.</p>\n<p>Closing the ofThreadChannel means that no new messages can be sent or\nreceived. All threads waiting to receive new values will be notified and\nall ofThreadChannel::receive and ofThreadChannel::tryReceive methods\nwill return false.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool empty()</p>\n<p>&lt;!--\n<em>syntax: empty()</em>\n<em>name: empty</em>\n<em>returns: bool</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Queries empty channel.</p>\n<p>This call is only an approximation, since messages come from a different\nthread the channel can return true when calling empty() and then receive\na message right afterwards</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<h3>ofThreadChannel()</h3>\n<p>&lt;!--\n<em>syntax: ofThreadChannel()</em>\n<em>name: ofThreadChannel</em>\n_returns: _\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Create a default ofThreadChannel.</p>\n<p>ofThreadChannel must be instantiated with a template parameter such as:</p>\n<pre><code>\tofThreadChannel<span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span>ofPixels<span class=\"token operator\">&amp;</span>gt<span class=\"token punctuation\">;</span> myThreadChannel<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool receive(&amp;sentValue)</p>\n<p>&lt;!--\n<em>syntax: receive(&amp;sentValue)</em>\n<em>name: receive</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: T &amp;sentValue</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Block the receiving thread until a new sent value is available.</p>\n<p>The receiving thread will block until a new sent value is available. In\norder to receive data, the user must create an instance of the data\ntype, and pass it to the receive method to be set.</p>\n<p>ofThreadChannel::receive will not make a copy or reallocate data.</p>\n<pre><code>ofThreadChannel<span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span>ofPixels<span class=\"token operator\">&amp;</span>gt<span class=\"token punctuation\">;</span> myThreadChannel<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// ofThreadChannel&amp;lt;ofPixels&amp;gt; declared elsewhere.</span>\n\nofPixels myPixelsToSet<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>myThreadChannel<span class=\"token punctuation\">.</span><span class=\"token function\">receive</span><span class=\"token punctuation\">(</span>myPixelsToSet<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// If true, `myPixelsToSet` can be used.</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// If false, thread channel was closed and the value of</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// `myPixelsToSet` may be invalid depending on the scope of</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// `myPixelsToSet`.</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><strong>Parameters:</strong></p>\n<p>sentValue A reference to a sent value.</p>\n<p><strong>Returns</strong>: True if a new value was received or false if the ofThreadChannel was closed.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool send(&amp;&amp;value)</p>\n<p>&lt;!--\n<em>syntax: send(&amp;&amp;value)</em>\n<em>name: send</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: T &amp;&amp;value</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Send a value to the receiver without making a copy.</p>\n<p>This method moves the contents of the sent value using <code>std<span class=\"token operator\">::</span>move</code>\nsemantics. This avoids copying the data, but the original data data will\nbe invalidated. Note that the original data will be invalideated even if\nthe send fails because the channel is already closed.</p>\n<pre><code>ofThreadChannel<span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span>ofPixels<span class=\"token operator\">&amp;</span>gt<span class=\"token punctuation\">;</span> myThreadChannel<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// ofThreadChannel&amp;lt;ofPixels&amp;gt; initialized elsewhere.</span>\n\nofPixels myPixelsToSend<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// Fill the pixels with valid data, an image for example.</span>\n\n<span class=\"token function\">ofLoadImage</span><span class=\"token punctuation\">(</span>myPixelsToSend<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>myImage<span class=\"token punctuation\">.</span>jpg<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// Send `myPixelsToSend` by moving it. `myPixelsToSend` will no longer</span>\n<span class=\"token comment\" spellcheck=\"true\">// be valid, even if the send fails because the channel is closed.</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>myThreadChannel<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>std<span class=\"token operator\">::</span><span class=\"token function\">move</span><span class=\"token punctuation\">(</span>myPixelsToSend<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// If true, `myPixelsToSend` was sent successfully.</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// `myPixelsToSend` is no longer valid because it was moved.</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// If false, the thread channel was closed.</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// `myPixelsToSend` is no longer valid because it was moved.</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p><strong>Returns</strong>: true if the value was sent successfully or false if the channel was closed.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool send(&amp;value)</p>\n<p>&lt;!--\n<em>syntax: send(&amp;value)</em>\n<em>name: send</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: const T &amp;value</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Send a value to the receiver by making a copy.</p>\n<p>This method copies the contents of the sent value, leaving the original\ndata unchanged.</p>\n<pre><code>ofThreadChannel<span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span>ofPixels<span class=\"token operator\">&amp;</span>gt<span class=\"token punctuation\">;</span> myThreadChannel<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// ofThreadChannel&amp;lt;ofPixels&amp;gt; initialized elsewhere.</span>\n\nofPixels myPixelsToSend<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// Fill the pixels with valid data, an image for example.</span>\n\n<span class=\"token function\">ofLoadImage</span><span class=\"token punctuation\">(</span>myPixelsToSend<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>myImage<span class=\"token punctuation\">.</span>jpg<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// Send `myPixelsToSend` by copying it. `myPixelsToSend` is still valid</span>\n<span class=\"token comment\" spellcheck=\"true\">// after sending.</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>myThreadChannel<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>myPixelsToSend<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// If true, `myPixelsToSend` was sent successfully.</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// If false, the thread channel was closed.</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><strong>Returns</strong>: true if the value was sent successfully or false if the channel was closed.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool tryReceive(&amp;sentValue)</p>\n<p>&lt;!--\n<em>syntax: tryReceive(&amp;sentValue)</em>\n<em>name: tryReceive</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: T &amp;sentValue</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>If available, receive a new sent value without blocking.</p>\n<p>ofThreadChannel::tryReceive is similar to ofThreadChannel::receive,\nexcept that it will not block the receiving thread.  If no data is\navailable, it will return false and continue immediately.</p>\n<p>ofThreadChannel::tryReceive will not make a copy or reallocate data.</p>\n<p>Like ofThreadChannel::receive, in order to receive data, the user must\ncreate an instance of the data type, and pass it to the receive method\nto be set.</p>\n<pre><code>ofThreadChannel<span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span>ofPixels<span class=\"token operator\">&amp;</span>gt<span class=\"token punctuation\">;</span> myThreadChannel<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// ofThreadChannel&amp;lt;ofPixels&amp;gt; initialized elsewhere.</span>\n\nofPixels myPixelsToSet<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>myThreadChannel<span class=\"token punctuation\">.</span><span class=\"token function\">tryReceive</span><span class=\"token punctuation\">(</span>myPixelsToSet<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// If true, `myPixelsToSet` can be used.</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// If false, there was no new data OR the thread channel was closed.</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// Either way, the value of `myPixelsToSet` may be invalid depending</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// on the scope of `myPixelsToSet`.</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><strong>Parameters:</strong></p>\n<p>sentValue A reference to a sent value.</p>\n<p><strong>Returns</strong>: True if a new value was received or false if the ofThreadChannel was closed.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool tryReceive(&amp;sentValue, timeoutMs)</p>\n<p>&lt;!--\n<em>syntax: tryReceive(&amp;sentValue, timeoutMs)</em>\n<em>name: tryReceive</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: T &amp;sentValue, int64_t timeoutMs</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>If available, receive a new sent value or wait for a user-specified duration.</p>\n<p>ofThreadChannel::tryReceive is similar to ofThreadChannel::receive,\nexcept that it will block the receiving thread for a maximum of\n<code>timeoutMs</code> while it waits for sent data.  If no data is available\nduring that time, it will return false and continue.</p>\n<p>ofThreadChannel::tryReceive will not make a copy or reallocate data.</p>\n<p>Like ofThreadChannel::receive, in order to receive data, the user must\ncreate an instance of the data type, and pass it to the receive method\nto be set.</p>\n<pre><code>ofThreadChannel<span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span>ofPixels<span class=\"token operator\">&amp;</span>gt<span class=\"token punctuation\">;</span> myThreadChannel<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// ofThreadChannel&amp;lt;ofPixels&amp;gt; initialized elsewhere.</span>\n\nofPixels myPixelsToSet<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>myThreadChannel<span class=\"token punctuation\">.</span><span class=\"token function\">tryReceive</span><span class=\"token punctuation\">(</span>myPixelsToSet<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// If true, `myPixelsToSet` can be used.</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// If false, there was no new data OR the thread channel was closed.</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// Either way, the value of `myPixelsToSet` may be invalid depending</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// on the scope of `myPixelsToSet`.</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><strong>Parameters:</strong></p>\n<p>sentValue A reference to a sent value.</p>\n<p>timeoutMs The number of milliseconds to wait for new data before continuing.</p>\n<p><strong>Returns</strong>: True if a new value was received or false if the ofThreadChannel was closed.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>##Variables</p>\n<p>###bool closed</p>\n<p>&lt;!--\n<em>name: closed</em>\n<em>type: bool</em>\n<em>access: private</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>visible: True</em>\n<em>constant: False</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>True if the channel is closed.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###condition_variable condition</p>\n<p>&lt;!--\n<em>name: condition</em>\n<em>type: condition_variable</em>\n<em>access: private</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>visible: True</em>\n<em>constant: False</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>The condition even to notify receivers.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###mutex mutex</p>\n<p>&lt;!--\n<em>name: mutex</em>\n<em>type: mutex</em>\n<em>access: private</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>visible: True</em>\n<em>constant: False</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>The mutext to protect the data.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###queue&lt; T &gt; queue</p>\n<p>&lt;!--\n<em>name: queue</em>\n<em>type: queue&lt; T &gt;</em>\n<em>access: private</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>visible: True</em>\n<em>constant: False</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>The FIFO data queue.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n","raw":"#class ofThreadChannel\n\n\n<!--\n_visible: True_\n_advanced: False_\n_istemplated: False_\n_extends: _\n-->\n\n##InlineDescription\n\nSafely send data between threads without additional synchronization.\n\nofThreadChannel makes it easy to safely and efficiently share data between\nthreads without the need for shared memory, mutexes, or other\nsynchronization techniques. Additionally, ofThreadChannel employs a\nsignalling system that allows receiving threads to sleep until new data\narrives or the ofThreadChannel is closed.\n\nA single ofThreadChannel class is designed for one-way communication. In\nmost cases an additional ofThreadChannel can be used for two-way\ncommunication.\n\nData is sent through the ofThreadChannel in a FIFO (first in, first out)\norder, guaranteeing that that data will be received in the same order that\nit was sent.\n\nIf multiple threads attempt to send data using the same ofThreadChannel, the\nsend method will block the calling thread until it is free.\n\n\n**See also**: https://github.com/openframeworks/ofBook/blob/master/chapters/threads/chapter.md\n\\tparam T The data type sent by the ofThreadChannel.\n\n\n\n\n\n##Description\n\n\n\n\n\n##Methods\n\n\n\n###void close()\n\n<!--\n_syntax: close()_\n_name: close_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nClose the ofThreadChannel.\n\nClosing the ofThreadChannel means that no new messages can be sent or\nreceived. All threads waiting to receive new values will be notified and\nall ofThreadChannel::receive and ofThreadChannel::tryReceive methods\nwill return false.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool empty()\n\n<!--\n_syntax: empty()_\n_name: empty_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nQueries empty channel.\n\nThis call is only an approximation, since messages come from a different\nthread the channel can return true when calling empty() and then receive\na message right afterwards\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n### ofThreadChannel()\n\n<!--\n_syntax: ofThreadChannel()_\n_name: ofThreadChannel_\n_returns: _\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCreate a default ofThreadChannel.\n\nofThreadChannel must be instantiated with a template parameter such as:\n~~~~{.cpp}\n\tofThreadChannel<ofPixels> myThreadChannel;\n~~~~\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool receive(&sentValue)\n\n<!--\n_syntax: receive(&sentValue)_\n_name: receive_\n_returns: bool_\n_returns_description: _\n_parameters: T &sentValue_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nBlock the receiving thread until a new sent value is available.\n\nThe receiving thread will block until a new sent value is available. In\norder to receive data, the user must create an instance of the data\ntype, and pass it to the receive method to be set.\n\nofThreadChannel::receive will not make a copy or reallocate data.\n\n~~~~{.cpp}\nofThreadChannel<ofPixels> myThreadChannel;\n\n// ofThreadChannel<ofPixels> declared elsewhere.\n\nofPixels myPixelsToSet;\n\nif (myThreadChannel.receive(myPixelsToSet)) {\n\t\t// If true, `myPixelsToSet` can be used.\n} else {\n\t\t// If false, thread channel was closed and the value of\n\t\t// `myPixelsToSet` may be invalid depending on the scope of\n\t\t// `myPixelsToSet`.\n}\n~~~~\n\n\n**Parameters:**\n\nsentValue A reference to a sent value.\n\n**Returns**: True if a new value was received or false if the ofThreadChannel was closed.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool send(&&value)\n\n<!--\n_syntax: send(&&value)_\n_name: send_\n_returns: bool_\n_returns_description: _\n_parameters: T &&value_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nSend a value to the receiver without making a copy.\n\nThis method moves the contents of the sent value using `std::move`\nsemantics. This avoids copying the data, but the original data data will\nbe invalidated. Note that the original data will be invalideated even if\nthe send fails because the channel is already closed.\n\n~~~~{.cpp}\nofThreadChannel<ofPixels> myThreadChannel;\n\n// ofThreadChannel<ofPixels> initialized elsewhere.\n\nofPixels myPixelsToSend;\n\n// Fill the pixels with valid data, an image for example.\n\nofLoadImage(myPixelsToSend, \"myImage.jpg\");\n\n// Send `myPixelsToSend` by moving it. `myPixelsToSend` will no longer\n// be valid, even if the send fails because the channel is closed.\nif (myThreadChannel.send(std::move(myPixelsToSend))) {\n\t\t// If true, `myPixelsToSend` was sent successfully.\n\t\t// `myPixelsToSend` is no longer valid because it was moved.\n} else {\n\t\t// If false, the thread channel was closed.\n\t\t// `myPixelsToSend` is no longer valid because it was moved.\n}\n\n~~~~\n\n\n**Returns**: true if the value was sent successfully or false if the channel was closed.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool send(&value)\n\n<!--\n_syntax: send(&value)_\n_name: send_\n_returns: bool_\n_returns_description: _\n_parameters: const T &value_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nSend a value to the receiver by making a copy.\n\nThis method copies the contents of the sent value, leaving the original\ndata unchanged.\n\n~~~~{.cpp}\nofThreadChannel<ofPixels> myThreadChannel;\n\n// ofThreadChannel<ofPixels> initialized elsewhere.\n\nofPixels myPixelsToSend;\n\n// Fill the pixels with valid data, an image for example.\n\nofLoadImage(myPixelsToSend, \"myImage.jpg\");\n\n// Send `myPixelsToSend` by copying it. `myPixelsToSend` is still valid\n// after sending.\nif (myThreadChannel.send(myPixelsToSend)) {\n\t\t// If true, `myPixelsToSend` was sent successfully.\n} else {\n\t\t// If false, the thread channel was closed.\n}\n~~~~\n\n\n**Returns**: true if the value was sent successfully or false if the channel was closed.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool tryReceive(&sentValue)\n\n<!--\n_syntax: tryReceive(&sentValue)_\n_name: tryReceive_\n_returns: bool_\n_returns_description: _\n_parameters: T &sentValue_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nIf available, receive a new sent value without blocking.\n\nofThreadChannel::tryReceive is similar to ofThreadChannel::receive,\nexcept that it will not block the receiving thread.  If no data is\navailable, it will return false and continue immediately.\n\nofThreadChannel::tryReceive will not make a copy or reallocate data.\n\nLike ofThreadChannel::receive, in order to receive data, the user must\ncreate an instance of the data type, and pass it to the receive method\nto be set.\n\n~~~~{.cpp}\nofThreadChannel<ofPixels> myThreadChannel;\n\n// ofThreadChannel<ofPixels> initialized elsewhere.\n\nofPixels myPixelsToSet;\n\nif (myThreadChannel.tryReceive(myPixelsToSet)) {\n\t\t// If true, `myPixelsToSet` can be used.\n} else {\n\t\t// If false, there was no new data OR the thread channel was closed.\n\t\t// Either way, the value of `myPixelsToSet` may be invalid depending\n\t\t// on the scope of `myPixelsToSet`.\n}\n~~~~\n\n\n**Parameters:**\n\nsentValue A reference to a sent value.\n\n**Returns**: True if a new value was received or false if the ofThreadChannel was closed.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool tryReceive(&sentValue, timeoutMs)\n\n<!--\n_syntax: tryReceive(&sentValue, timeoutMs)_\n_name: tryReceive_\n_returns: bool_\n_returns_description: _\n_parameters: T &sentValue, int64_t timeoutMs_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nIf available, receive a new sent value or wait for a user-specified duration.\n\nofThreadChannel::tryReceive is similar to ofThreadChannel::receive,\nexcept that it will block the receiving thread for a maximum of\n`timeoutMs` while it waits for sent data.  If no data is available\nduring that time, it will return false and continue.\n\nofThreadChannel::tryReceive will not make a copy or reallocate data.\n\nLike ofThreadChannel::receive, in order to receive data, the user must\ncreate an instance of the data type, and pass it to the receive method\nto be set.\n\n~~~~{.cpp}\nofThreadChannel<ofPixels> myThreadChannel;\n\n// ofThreadChannel<ofPixels> initialized elsewhere.\n\nofPixels myPixelsToSet;\n\nif (myThreadChannel.tryReceive(myPixelsToSet)) {\n\t\t// If true, `myPixelsToSet` can be used.\n} else {\n\t\t// If false, there was no new data OR the thread channel was closed.\n\t\t// Either way, the value of `myPixelsToSet` may be invalid depending\n\t\t// on the scope of `myPixelsToSet`.\n}\n~~~~\n\n\n**Parameters:**\n\nsentValue A reference to a sent value.\n\ntimeoutMs The number of milliseconds to wait for new data before continuing.\n\n**Returns**: True if a new value was received or false if the ofThreadChannel was closed.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n##Variables\n\n\n\n###bool closed\n\n<!--\n_name: closed_\n_type: bool_\n_access: private_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: False_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nTrue if the channel is closed.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###condition_variable condition\n\n<!--\n_name: condition_\n_type: condition_variable_\n_access: private_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: False_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nThe condition even to notify receivers.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###mutex mutex\n\n<!--\n_name: mutex_\n_type: mutex_\n_access: private_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: False_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nThe mutext to protect the data.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###queue< T > queue\n\n<!--\n_name: queue_\n_type: queue< T >_\n_access: private_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: False_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nThe FIFO data queue.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n","type":"page","static":true}}],"fetch":[]}