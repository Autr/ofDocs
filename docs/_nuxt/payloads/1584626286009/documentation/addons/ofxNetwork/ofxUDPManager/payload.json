{"data":[{"page":{"entry":{"name":"ofxUDPManager","filename":"ofxUDPManager.markdown","absolute":"/Users/gilbertsinnott/Code/openFrameworks/ofSite/documentation/addons/ofxNetwork/ofxUDPManager.markdown","path":"/documentation/addons/ofxNetwork/ofxUDPManager","route":"/documentation/addons/ofxNetwork/ofxUDPManager.markdown","dir":"../ofSite/documentation/addons/ofxNetwork","ext":"markdown","type":"page","id":1832,"parent":1824,"breadcrumbs":[1824,1743,1718],"siblings":[],"translations":{}},"description":{"short":"","full":"<p>UDP is a network protocol that is faster and less rigid in its packet transmission requirements. Unlike TCP, UDP has no notion of connections nor does it check to see if a packet has been successfuly recieved by the client. A UDP socket can receive datagrams from any server on the network and send datagrams to any host on the network. In addition, datagrams may arrive in any order, never arrive at all, or be duplicated in transit. There are three modes of UDP servers: socket (aka unicast), broadcast, and multicast.</p>\n<p>Unicast refers to a unique host-client. This is a one-to one connection between the client and the server</p>\n<p>Multicast is the delivery of a message or information to a group of destination computers simultaneously in a single transmission. A packet sent to a unicast or broadcast address is only delivered to the host identified by that address. To the contrary, when packet is send to a multicast address, all interfaces identified by that address receive the data. However, multicast has the drawback that it is not well supported by routers and NAT.</p>\n<p>Broadcast allows you to call every host within a subnet. It's like Multicast but doesn't require that your network infrastructure support it.</p>\n<p>A very simple unicast server looks like this:</p>\n<pre><code>\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">setup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\n\t<span class=\"token comment\" spellcheck=\"true\">//create the socket and set to send to 127.0.0.1:11999</span>\n\tudpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">Create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tudpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">Connect</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token number\">127.0</span><span class=\"token punctuation\">.</span><span class=\"token number\">0.1</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">,</span><span class=\"token number\">11999</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tudpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">SetNonBlocking</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">keyPressed</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> key<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\tstring message <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>You pressed a key<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n\tudpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">Send</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">.</span><span class=\"token function\">c_str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> message<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>A very simple unicast client looks like this:</p>\n<pre><code>\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">setup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\n\t<span class=\"token comment\" spellcheck=\"true\">//create the socket and bind to port 11999</span>\n\tudpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">Create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tudpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">Bind</span><span class=\"token punctuation\">(</span><span class=\"token number\">11999</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tudpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">SetNonBlocking</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">char</span> udpMessage<span class=\"token punctuation\">[</span><span class=\"token number\">1000</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\tudpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">Receive</span><span class=\"token punctuation\">(</span>udpMessage<span class=\"token punctuation\">,</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tstring message<span class=\"token operator\">=</span>udpMessage<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>Notice that these are quite different than the creation of TCP servers and clients which you might be more familiar with.</p>\n<p>The basic usage of UDP for socket servers and clients looks like so:</p>\n<p>UDP Socket Server (sending):</p>\n<ol>\n<li>Create() - initialize the server</li>\n<li>Connect() - connect to an IP and a Port that you'll be sending messages on</li>\n<li>Send() - send the message</li>\n</ol>\n<p>UDP Socket Client (receiving):</p>\n<ol>\n<li>Create() - intialize the client</li>\n<li>Bind() - bind the client to a port and listen for any UDP messages on that port</li>\n<li>Receive() - receive any data broadcast over UDP on the port set up to receive on</li>\n</ol>\n<p>The basic usage of UDP for multicast looks like so:</p>\n<p>UDP Multicast (sending):</p>\n<ol>\n<li>Create() - initialize the server</li>\n<li>ConnectMcast() - connect to an IP and a Port that you'll broadcast on</li>\n<li>Send() - send a message to any listening clients</li>\n</ol>\n<p>UDP Multicast (receiving):</p>\n<ol>\n<li>Create() - initialize the client</li>\n<li>BindMcast() - bind to a port</li>\n<li>Receive() - check to see if any data has been received</li>\n</ol>\n<h1></h1>\n"},"config":{"visible":"True","advanced":"False","istemplated":"False","extends":null},"methods":[{"syntax":"Bind(usPort)","name":"Bind","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">short</span> usPort","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Bind a port to receive socket/unicast UDP:</p>\n<pre><code>udpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">Create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nudpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">Bind</span><span class=\"token punctuation\">(</span><span class=\"token number\">11999</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nudpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">SetNonBlocking</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n"},{"syntax":"BindMcast(*pMcast, usPort)","name":"BindMcast","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>pMcast<span class=\"token punctuation\">,</span> <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">short</span> usPort","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Bind to multicast address to receive data:</p>\n<pre><code>udpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">Create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nudpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">BindMcast</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token number\">224.0</span><span class=\"token punctuation\">.</span><span class=\"token number\">0.1</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">,</span> <span class=\"token number\">11999</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n"},{"syntax":"Close()","name":"Close","returns":"bool","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Stop listening on a given port. Works with both socket and multicast.</p>\n"},{"syntax":"Connect(*pHost, usPort)","name":"Connect","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>pHost<span class=\"token punctuation\">,</span> <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">short</span> usPort","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Connect to a socket client to send information.</p>\n<pre><code>\nudpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">Create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nudpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">Connect</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token number\">127.0</span><span class=\"token punctuation\">.</span><span class=\"token number\">0.1</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">,</span><span class=\"token number\">11999</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nudpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">SetNonBlocking</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n"},{"syntax":"ConnectMcast(*pMcast, usPort)","name":"ConnectMcast","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>pMcast<span class=\"token punctuation\">,</span> <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">short</span> usPort","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Connect to a multicast address.</p>\n<pre><code>\nudpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">Create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nudpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">Connect</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token number\">224.0</span><span class=\"token punctuation\">.</span><span class=\"token number\">0.1</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">,</span><span class=\"token number\">11999</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n"},{"syntax":"Create()","name":"Create","returns":"bool","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Create the UDP manager. Must be called before binding to any IP or sockets.</p>\n"},{"syntax":"GetListenAddr(&address, &port)","name":"GetListenAddr","returns":"bool","returns_description":null,"parameters":"string <span class=\"token operator\">&amp;</span>address<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> <span class=\"token operator\">&amp;</span>port","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"GetMaxMsgSize()","name":"GetMaxMsgSize","returns":"int","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"GetReceiveBufferSize()","name":"GetReceiveBufferSize","returns":"int","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Get the size of the receive buffer. The minimum (doubled) value for this option is 256. The max is determined by your OS.</p>\n"},{"syntax":"GetRemoteAddr(&address, &port)","name":"GetRemoteAddr","returns":"bool","returns_description":null,"parameters":"string <span class=\"token operator\">&amp;</span>address<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> <span class=\"token operator\">&amp;</span>port","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Returns the dots and numbers remote address in a string,</p>\n"},{"syntax":"GetSendBufferSize()","name":"GetSendBufferSize","returns":"int","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Get the size of the send buffer. The minimum (doubled) value for this option is 256. The max is determined by your OS.</p>\n"},{"syntax":"GetTTL()","name":"GetTTL","returns":"int","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>returns -1 on failure</p>\n","desc":""},{"syntax":"GetTimeoutReceive()","name":"GetTimeoutReceive","returns":"int","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Return the current receive timeout.</p>\n"},{"syntax":"GetTimeoutSend()","name":"GetTimeoutSend","returns":"int","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Return the current send timeout.</p>\n"},{"syntax":"HasSocket()","name":"HasSocket","returns":"bool","returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"PeekReceive()","name":"PeekReceive","returns":"int","returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"Receive(*pBuff, iSize)","name":"Receive","returns":"int","returns_description":null,"parameters":"<span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>pBuff<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> iSize","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Receives a message to a buffer of size iSize. Receive() returns the number of bytes actually received.</p>\n<pre><code><span class=\"token keyword\">char</span> udpMessage<span class=\"token punctuation\">[</span><span class=\"token number\">100000</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nudpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">Receive</span><span class=\"token punctuation\">(</span>udpMessage<span class=\"token punctuation\">,</span><span class=\"token number\">100000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nstring message<span class=\"token operator\">=</span>udpMessage<span class=\"token punctuation\">;</span>\n</code></pre>\n"},{"syntax":"Send(*pBuff, iSize)","name":"Send","returns":"int","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>pBuff<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> iSize","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Send a char* of data with length of iSize to all listeners.</p>\n<pre><code>string message <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>A message<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\nudpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">Send</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">.</span><span class=\"token function\">c_str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>message<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n"},{"syntax":"SendAll(*pBuff, iSize)","name":"SendAll","returns":"int","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>pBuff<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> iSize","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>The SendAll() method is useful for extremely large data objects that may need multiple sendto() calls to actually be completely.</p>\n"},{"syntax":"SetEnableBroadcast(enableBroadcast)","name":"SetEnableBroadcast","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">bool</span> enableBroadcast","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Broadcast allows sending of packets to a particular network layer. If you're only using a single local network without a large number of attached machines, using broadcast may make more sense than trying to use multicast.</p>\n"},{"syntax":"SetNonBlocking(useNonBlocking)","name":"SetNonBlocking","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">bool</span> useNonBlocking","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Determines whether calls to send or receive are allowed to block their thread until they've completed. If your network infrastructure is time critical, then this may be a good choice. Usually though, you should leave it off.</p>\n"},{"syntax":"SetReceiveBufferSize(sizeInByte)","name":"SetReceiveBufferSize","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">int</span> sizeInByte","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Set the size of the receive buffer. The minimum (doubled) value for this option is 256. The max is determined by your OS.</p>\n"},{"syntax":"SetReuseAddress(allowReuse)","name":"SetReuseAddress","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">bool</span> allowReuse","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"SetSendBufferSize(sizeInByte)","name":"SetSendBufferSize","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">int</span> sizeInByte","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Set the size of the send buffer. The minimum (doubled) value for this option is 256. The max is determined by your OS.</p>\n"},{"syntax":"SetTTL(nTTL)","name":"SetTTL","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">int</span> nTTL","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>The TTL (Time To Live) field in the IP header has a double significance in multicast. As always, it controls the live time of the datagram to avoid it being looped forever due to routing errors. Routers decrement the TTL of every datagram as it traverses from one network to another and when its value reaches 0 the packet is dropped.</p>\n<p>A list of TTL thresholds and their associated scope follows:</p>\n<h2>TTL     Scope</h2>\n<p>0    Restricted to the same host. Won't be output by any interface.\n1    Restricted to the same subnet. Won't be forwarded by a router.\n&lt;32         Restricted to the same site, organization or department.\n&lt;64 Restricted to the same region.\n&lt;128 Restricted to the same continent.\n&lt;255 Unrestricted in scope. Global.</p>\n"},{"syntax":"SetTimeoutReceive(timeoutInSeconds)","name":"SetTimeoutReceive","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">int</span> timeoutInSeconds","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Set a timeout for any receive operations in seconds.</p>\n"},{"syntax":"SetTimeoutSend(timeoutInSeconds)","name":"SetTimeoutSend","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">int</span> timeoutInSeconds","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Set a timeout for any send operations in seconds.</p>\n"},{"syntax":"Setup(&settings)","name":"Setup","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofxUDPSettings <span class=\"token operator\">&amp;</span>settings","access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"WaitReceive(timeoutSeconds, timeoutMillis)","name":"WaitReceive","returns":"int","returns_description":null,"parameters":"time_t timeoutSeconds<span class=\"token punctuation\">,</span> time_t timeoutMillis","access":"protected","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"WaitSend(timeoutSeconds, timeoutMillis)","name":"WaitSend","returns":"int","returns_description":null,"parameters":"time_t timeoutSeconds<span class=\"token punctuation\">,</span> time_t timeoutMillis","access":"protected","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"ofxUDPManager()","name":"ofxUDPManager","returns":null,"returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"~ofxUDPManager()","name":"~ofxUDPManager","returns":null,"returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"name":"canGetRemoteAddress","type":"bool","access":"protected","version_started":"007","version_deprecated":null,"summary":null,"visible":"True","constant":"True","advanced":"False","short":"","desc":""},{"name":"m_bWinsockInit","type":"bool","access":"protected","version_started":"007","version_deprecated":null,"summary":null,"visible":"True","constant":"True","advanced":"False","short":"","desc":""},{"name":"m_dwTimeoutReceive","type":"unsigned long","access":"protected","version_started":"007","version_deprecated":null,"summary":null,"visible":"True","constant":"True","advanced":"False","short":"","desc":""},{"name":"m_dwTimeoutSend","type":"unsigned long","access":"protected","version_started":"007","version_deprecated":null,"summary":null,"visible":"True","constant":"True","advanced":"False","short":"","desc":""},{"name":"m_hSocket","type":"int","access":"protected","version_started":"007","version_deprecated":null,"summary":null,"visible":"True","constant":"True","advanced":"False","short":"","desc":""},{"name":"nonBlocking","type":"bool","access":"protected","version_started":"007","version_deprecated":null,"summary":null,"visible":"True","constant":"True","advanced":"False","short":"","desc":""},{"name":"saClient","type":"struct sockaddr_in","access":"protected","version_started":"007","version_deprecated":null,"summary":null,"visible":"True","constant":"True","advanced":"False","short":"","desc":""},{"name":"saServer","type":"struct sockaddr_in","access":"protected","version_started":"007","version_deprecated":null,"summary":null,"visible":"True","constant":"True","advanced":"False","short":"","desc":""},{}],"document":"<p>#class ofxUDPManager</p>\n<p>&lt;!--\n<em>visible: True</em>\n<em>advanced: False</em>\n<em>istemplated: False</em>\n_extends: _\n--&gt;</p>\n<p>##InlineDescription</p>\n<p>##Description</p>\n<p>UDP is a network protocol that is faster and less rigid in its packet transmission requirements. Unlike TCP, UDP has no notion of connections nor does it check to see if a packet has been successfuly recieved by the client. A UDP socket can receive datagrams from any server on the network and send datagrams to any host on the network. In addition, datagrams may arrive in any order, never arrive at all, or be duplicated in transit. There are three modes of UDP servers: socket (aka unicast), broadcast, and multicast.</p>\n<p>Unicast refers to a unique host-client. This is a one-to one connection between the client and the server</p>\n<p>Multicast is the delivery of a message or information to a group of destination computers simultaneously in a single transmission. A packet sent to a unicast or broadcast address is only delivered to the host identified by that address. To the contrary, when packet is send to a multicast address, all interfaces identified by that address receive the data. However, multicast has the drawback that it is not well supported by routers and NAT.</p>\n<p>Broadcast allows you to call every host within a subnet. It's like Multicast but doesn't require that your network infrastructure support it.</p>\n<p>A very simple unicast server looks like this:</p>\n<pre><code>\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">setup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\n\t<span class=\"token comment\" spellcheck=\"true\">//create the socket and set to send to 127.0.0.1:11999</span>\n\tudpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">Create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tudpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">Connect</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token number\">127.0</span><span class=\"token punctuation\">.</span><span class=\"token number\">0.1</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">,</span><span class=\"token number\">11999</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tudpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">SetNonBlocking</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">keyPressed</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> key<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\tstring message <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>You pressed a key<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n\tudpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">Send</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">.</span><span class=\"token function\">c_str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> message<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>A very simple unicast client looks like this:</p>\n<pre><code>\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">setup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\n\t<span class=\"token comment\" spellcheck=\"true\">//create the socket and bind to port 11999</span>\n\tudpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">Create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tudpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">Bind</span><span class=\"token punctuation\">(</span><span class=\"token number\">11999</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tudpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">SetNonBlocking</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> ofApp<span class=\"token operator\">::</span><span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">char</span> udpMessage<span class=\"token punctuation\">[</span><span class=\"token number\">1000</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\tudpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">Receive</span><span class=\"token punctuation\">(</span>udpMessage<span class=\"token punctuation\">,</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tstring message<span class=\"token operator\">=</span>udpMessage<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>Notice that these are quite different than the creation of TCP servers and clients which you might be more familiar with.</p>\n<p>The basic usage of UDP for socket servers and clients looks like so:</p>\n<p>UDP Socket Server (sending):</p>\n<ol>\n<li>Create() - initialize the server</li>\n<li>Connect() - connect to an IP and a Port that you'll be sending messages on</li>\n<li>Send() - send the message</li>\n</ol>\n<p>UDP Socket Client (receiving):</p>\n<ol>\n<li>Create() - intialize the client</li>\n<li>Bind() - bind the client to a port and listen for any UDP messages on that port</li>\n<li>Receive() - receive any data broadcast over UDP on the port set up to receive on</li>\n</ol>\n<p>The basic usage of UDP for multicast looks like so:</p>\n<p>UDP Multicast (sending):</p>\n<ol>\n<li>Create() - initialize the server</li>\n<li>ConnectMcast() - connect to an IP and a Port that you'll broadcast on</li>\n<li>Send() - send a message to any listening clients</li>\n</ol>\n<p>UDP Multicast (receiving):</p>\n<ol>\n<li>Create() - initialize the client</li>\n<li>BindMcast() - bind to a port</li>\n<li>Receive() - check to see if any data has been received</li>\n</ol>\n<p>##Methods</p>\n<p>###bool Bind(usPort)</p>\n<p>&lt;!--\n<em>syntax: Bind(usPort)</em>\n<em>name: Bind</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: unsigned short usPort</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Bind a port to receive socket/unicast UDP:</p>\n<pre><code>udpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">Create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nudpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">Bind</span><span class=\"token punctuation\">(</span><span class=\"token number\">11999</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nudpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">SetNonBlocking</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool BindMcast(*pMcast, usPort)</p>\n<p>&lt;!--\n<em>syntax: BindMcast(*pMcast, usPort)</em>\n<em>name: BindMcast</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: char *pMcast, unsigned short usPort</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Bind to multicast address to receive data:</p>\n<pre><code>udpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">Create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nudpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">BindMcast</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token number\">224.0</span><span class=\"token punctuation\">.</span><span class=\"token number\">0.1</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">,</span> <span class=\"token number\">11999</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool Close()</p>\n<p>&lt;!--\n<em>syntax: Close()</em>\n<em>name: Close</em>\n<em>returns: bool</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Stop listening on a given port. Works with both socket and multicast.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool Connect(*pHost, usPort)</p>\n<p>&lt;!--\n<em>syntax: Connect(*pHost, usPort)</em>\n<em>name: Connect</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: const char *pHost, unsigned short usPort</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Connect to a socket client to send information.</p>\n<pre><code>\nudpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">Create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nudpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">Connect</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token number\">127.0</span><span class=\"token punctuation\">.</span><span class=\"token number\">0.1</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">,</span><span class=\"token number\">11999</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nudpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">SetNonBlocking</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool ConnectMcast(*pMcast, usPort)</p>\n<p>&lt;!--\n<em>syntax: ConnectMcast(*pMcast, usPort)</em>\n<em>name: ConnectMcast</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: char *pMcast, unsigned short usPort</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Connect to a multicast address.</p>\n<pre><code>\nudpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">Create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nudpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">Connect</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token number\">224.0</span><span class=\"token punctuation\">.</span><span class=\"token number\">0.1</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">,</span><span class=\"token number\">11999</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool Create()</p>\n<p>&lt;!--\n<em>syntax: Create()</em>\n<em>name: Create</em>\n<em>returns: bool</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Create the UDP manager. Must be called before binding to any IP or sockets.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool GetListenAddr(&amp;address, &amp;port)</p>\n<p>&lt;!--\n<em>syntax: GetListenAddr(&amp;address, &amp;port)</em>\n<em>name: GetListenAddr</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: string &amp;address, int &amp;port</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###int GetMaxMsgSize()</p>\n<p>&lt;!--\n<em>syntax: GetMaxMsgSize()</em>\n<em>name: GetMaxMsgSize</em>\n<em>returns: int</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###int GetReceiveBufferSize()</p>\n<p>&lt;!--\n<em>syntax: GetReceiveBufferSize()</em>\n<em>name: GetReceiveBufferSize</em>\n<em>returns: int</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Get the size of the receive buffer. The minimum (doubled) value for this option is 256. The max is determined by your OS.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool GetRemoteAddr(&amp;address, &amp;port)</p>\n<p>&lt;!--\n<em>syntax: GetRemoteAddr(&amp;address, &amp;port)</em>\n<em>name: GetRemoteAddr</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: string &amp;address, int &amp;port</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Returns the dots and numbers remote address in a string,</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###int GetSendBufferSize()</p>\n<p>&lt;!--\n<em>syntax: GetSendBufferSize()</em>\n<em>name: GetSendBufferSize</em>\n<em>returns: int</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Get the size of the send buffer. The minimum (doubled) value for this option is 256. The max is determined by your OS.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###int GetTTL()</p>\n<p>&lt;!--\n<em>syntax: GetTTL()</em>\n<em>name: GetTTL</em>\n<em>returns: int</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>returns -1 on failure</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###int GetTimeoutReceive()</p>\n<p>&lt;!--\n<em>syntax: GetTimeoutReceive()</em>\n<em>name: GetTimeoutReceive</em>\n<em>returns: int</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Return the current receive timeout.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###int GetTimeoutSend()</p>\n<p>&lt;!--\n<em>syntax: GetTimeoutSend()</em>\n<em>name: GetTimeoutSend</em>\n<em>returns: int</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Return the current send timeout.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool HasSocket()</p>\n<p>&lt;!--\n<em>syntax: HasSocket()</em>\n<em>name: HasSocket</em>\n<em>returns: bool</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###int PeekReceive()</p>\n<p>&lt;!--\n<em>syntax: PeekReceive()</em>\n<em>name: PeekReceive</em>\n<em>returns: int</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###int Receive(*pBuff, iSize)</p>\n<p>&lt;!--\n<em>syntax: Receive(*pBuff, iSize)</em>\n<em>name: Receive</em>\n<em>returns: int</em>\n_returns_description: _\n<em>parameters: char *pBuff, const int iSize</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Receives a message to a buffer of size iSize. Receive() returns the number of bytes actually received.</p>\n<pre><code><span class=\"token keyword\">char</span> udpMessage<span class=\"token punctuation\">[</span><span class=\"token number\">100000</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nudpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">Receive</span><span class=\"token punctuation\">(</span>udpMessage<span class=\"token punctuation\">,</span><span class=\"token number\">100000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nstring message<span class=\"token operator\">=</span>udpMessage<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###int Send(*pBuff, iSize)</p>\n<p>&lt;!--\n<em>syntax: Send(*pBuff, iSize)</em>\n<em>name: Send</em>\n<em>returns: int</em>\n_returns_description: _\n<em>parameters: const char *pBuff, const int iSize</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Send a char* of data with length of iSize to all listeners.</p>\n<pre><code>string message <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>A message<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\nudpConnection<span class=\"token punctuation\">.</span><span class=\"token function\">Send</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">.</span><span class=\"token function\">c_str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>message<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###int SendAll(*pBuff, iSize)</p>\n<p>&lt;!--\n<em>syntax: SendAll(*pBuff, iSize)</em>\n<em>name: SendAll</em>\n<em>returns: int</em>\n_returns_description: _\n<em>parameters: const char *pBuff, const int iSize</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>The SendAll() method is useful for extremely large data objects that may need multiple sendto() calls to actually be completely.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool SetEnableBroadcast(enableBroadcast)</p>\n<p>&lt;!--\n<em>syntax: SetEnableBroadcast(enableBroadcast)</em>\n<em>name: SetEnableBroadcast</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: bool enableBroadcast</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Broadcast allows sending of packets to a particular network layer. If you're only using a single local network without a large number of attached machines, using broadcast may make more sense than trying to use multicast.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool SetNonBlocking(useNonBlocking)</p>\n<p>&lt;!--\n<em>syntax: SetNonBlocking(useNonBlocking)</em>\n<em>name: SetNonBlocking</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: bool useNonBlocking</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Determines whether calls to send or receive are allowed to block their thread until they've completed. If your network infrastructure is time critical, then this may be a good choice. Usually though, you should leave it off.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool SetReceiveBufferSize(sizeInByte)</p>\n<p>&lt;!--\n<em>syntax: SetReceiveBufferSize(sizeInByte)</em>\n<em>name: SetReceiveBufferSize</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: int sizeInByte</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Set the size of the receive buffer. The minimum (doubled) value for this option is 256. The max is determined by your OS.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool SetReuseAddress(allowReuse)</p>\n<p>&lt;!--\n<em>syntax: SetReuseAddress(allowReuse)</em>\n<em>name: SetReuseAddress</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: bool allowReuse</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool SetSendBufferSize(sizeInByte)</p>\n<p>&lt;!--\n<em>syntax: SetSendBufferSize(sizeInByte)</em>\n<em>name: SetSendBufferSize</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: int sizeInByte</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Set the size of the send buffer. The minimum (doubled) value for this option is 256. The max is determined by your OS.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool SetTTL(nTTL)</p>\n<p>&lt;!--\n<em>syntax: SetTTL(nTTL)</em>\n<em>name: SetTTL</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: int nTTL</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>The TTL (Time To Live) field in the IP header has a double significance in multicast. As always, it controls the live time of the datagram to avoid it being looped forever due to routing errors. Routers decrement the TTL of every datagram as it traverses from one network to another and when its value reaches 0 the packet is dropped.</p>\n<p>A list of TTL thresholds and their associated scope follows:</p>\n<h2>TTL     Scope</h2>\n<p>0    Restricted to the same host. Won't be output by any interface.\n1    Restricted to the same subnet. Won't be forwarded by a router.\n&lt;32         Restricted to the same site, organization or department.\n&lt;64 Restricted to the same region.\n&lt;128 Restricted to the same continent.\n&lt;255 Unrestricted in scope. Global.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void SetTimeoutReceive(timeoutInSeconds)</p>\n<p>&lt;!--\n<em>syntax: SetTimeoutReceive(timeoutInSeconds)</em>\n<em>name: SetTimeoutReceive</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: int timeoutInSeconds</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Set a timeout for any receive operations in seconds.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void SetTimeoutSend(timeoutInSeconds)</p>\n<p>&lt;!--\n<em>syntax: SetTimeoutSend(timeoutInSeconds)</em>\n<em>name: SetTimeoutSend</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: int timeoutInSeconds</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Set a timeout for any send operations in seconds.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool Setup(&amp;settings)</p>\n<p>&lt;!--\n<em>syntax: Setup(&amp;settings)</em>\n<em>name: Setup</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: const ofxUDPSettings &amp;settings</em>\n<em>access: public</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###int WaitReceive(timeoutSeconds, timeoutMillis)</p>\n<p>&lt;!--\n<em>syntax: WaitReceive(timeoutSeconds, timeoutMillis)</em>\n<em>name: WaitReceive</em>\n<em>returns: int</em>\n_returns_description: _\n<em>parameters: time_t timeoutSeconds, time_t timeoutMillis</em>\n<em>access: protected</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###int WaitSend(timeoutSeconds, timeoutMillis)</p>\n<p>&lt;!--\n<em>syntax: WaitSend(timeoutSeconds, timeoutMillis)</em>\n<em>name: WaitSend</em>\n<em>returns: int</em>\n_returns_description: _\n<em>parameters: time_t timeoutSeconds, time_t timeoutMillis</em>\n<em>access: protected</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<h3>ofxUDPManager()</h3>\n<p>&lt;!--\n<em>syntax: ofxUDPManager()</em>\n<em>name: ofxUDPManager</em>\n_returns: _\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<h3>~ofxUDPManager()</h3>\n<p>&lt;!--\n<em>syntax: ~ofxUDPManager()</em>\n<em>name: ~ofxUDPManager</em>\n_returns: _\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>##Variables</p>\n<p>###bool canGetRemoteAddress</p>\n<p>&lt;!--\n<em>name: canGetRemoteAddress</em>\n<em>type: bool</em>\n<em>access: protected</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>visible: True</em>\n<em>constant: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool m_bWinsockInit</p>\n<p>&lt;!--\n<em>name: m_bWinsockInit</em>\n<em>type: bool</em>\n<em>access: protected</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>visible: True</em>\n<em>constant: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###unsigned long m_dwTimeoutReceive</p>\n<p>&lt;!--\n<em>name: m_dwTimeoutReceive</em>\n<em>type: unsigned long</em>\n<em>access: protected</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>visible: True</em>\n<em>constant: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###unsigned long m_dwTimeoutSend</p>\n<p>&lt;!--\n<em>name: m_dwTimeoutSend</em>\n<em>type: unsigned long</em>\n<em>access: protected</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>visible: True</em>\n<em>constant: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###int m_hSocket</p>\n<p>&lt;!--\n<em>name: m_hSocket</em>\n<em>type: int</em>\n<em>access: protected</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>visible: True</em>\n<em>constant: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool nonBlocking</p>\n<p>&lt;!--\n<em>name: nonBlocking</em>\n<em>type: bool</em>\n<em>access: protected</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>visible: True</em>\n<em>constant: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###struct sockaddr_in saClient</p>\n<p>&lt;!--\n<em>name: saClient</em>\n<em>type: struct sockaddr_in</em>\n<em>access: protected</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>visible: True</em>\n<em>constant: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###struct sockaddr_in saServer</p>\n<p>&lt;!--\n<em>name: saServer</em>\n<em>type: struct sockaddr_in</em>\n<em>access: protected</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>visible: True</em>\n<em>constant: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n","raw":"#class ofxUDPManager\n\n\n<!--\n_visible: True_\n_advanced: False_\n_istemplated: False_\n_extends: _\n-->\n\n##InlineDescription\n\n\n\n\n\n\n##Description\n\nUDP is a network protocol that is faster and less rigid in its packet transmission requirements. Unlike TCP, UDP has no notion of connections nor does it check to see if a packet has been successfuly recieved by the client. A UDP socket can receive datagrams from any server on the network and send datagrams to any host on the network. In addition, datagrams may arrive in any order, never arrive at all, or be duplicated in transit. There are three modes of UDP servers: socket (aka unicast), broadcast, and multicast. \n\nUnicast refers to a unique host-client. This is a one-to one connection between the client and the server \n\nMulticast is the delivery of a message or information to a group of destination computers simultaneously in a single transmission. A packet sent to a unicast or broadcast address is only delivered to the host identified by that address. To the contrary, when packet is send to a multicast address, all interfaces identified by that address receive the data. However, multicast has the drawback that it is not well supported by routers and NAT.\n\nBroadcast allows you to call every host within a subnet. It's like Multicast but doesn't require that your network infrastructure support it.\n\nA very simple unicast server looks like this:\n\n~~~~{.cpp}\n\nvoid ofApp::setup()\n{\n\n\t//create the socket and set to send to 127.0.0.1:11999\n\tudpConnection.Create();\n\tudpConnection.Connect(\"127.0.0.1\",11999);\n\tudpConnection.SetNonBlocking(true);\n}\n\nvoid ofApp::keyPressed(int key)\n{\n\tstring message = \"You pressed a key\";\n\tudpConnection.Send(message.c_str(), message.length());\n}\n~~~~\n\nA very simple unicast client looks like this:\n\n~~~~{.cpp}\n\nvoid ofApp::setup()\n{\n\n\t//create the socket and bind to port 11999\n\tudpConnection.Create();\n\tudpConnection.Bind(11999);\n\tudpConnection.SetNonBlocking(true);\n}\n\nvoid ofApp::update()\n{\n\tchar udpMessage[1000];\n\tudpConnection.Receive(udpMessage,1000);\n\tstring message=udpMessage;\n}\n~~~~\n\nNotice that these are quite different than the creation of TCP servers and clients which you might be more familiar with.\n\nThe basic usage of UDP for socket servers and clients looks like so:\n\nUDP Socket Server (sending):\n1) Create() - initialize the server\n2) Connect() - connect to an IP and a Port that you'll be sending messages on\n3) Send() - send the message\n\nUDP Socket Client (receiving):\n1) Create() - intialize the client\n2) Bind() - bind the client to a port and listen for any UDP messages on that port\n3) Receive() - receive any data broadcast over UDP on the port set up to receive on\n\nThe basic usage of UDP for multicast looks like so:\n\nUDP Multicast (sending):\n1) Create() - initialize the server\n2) ConnectMcast() - connect to an IP and a Port that you'll broadcast on\n3) Send() - send a message to any listening clients\n\nUDP Multicast (receiving):\n1) Create() - initialize the client\n2) BindMcast() - bind to a port\n3) Receive() - check to see if any data has been received\n\n\n\n\n\n##Methods\n\n\n\n###bool Bind(usPort)\n\n<!--\n_syntax: Bind(usPort)_\n_name: Bind_\n_returns: bool_\n_returns_description: _\n_parameters: unsigned short usPort_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nBind a port to receive socket/unicast UDP:\n\n~~~~{.cpp}\nudpConnection.Create();\nudpConnection.Bind(11999);\nudpConnection.SetNonBlocking(true);\n~~~~\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool BindMcast(*pMcast, usPort)\n\n<!--\n_syntax: BindMcast(*pMcast, usPort)_\n_name: BindMcast_\n_returns: bool_\n_returns_description: _\n_parameters: char *pMcast, unsigned short usPort_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nBind to multicast address to receive data:\n\n~~~~{.cpp}\nudpConnection.Create();\nudpConnection.BindMcast(\"224.0.0.1\", 11999);\n~~~~\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool Close()\n\n<!--\n_syntax: Close()_\n_name: Close_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nStop listening on a given port. Works with both socket and multicast.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool Connect(*pHost, usPort)\n\n<!--\n_syntax: Connect(*pHost, usPort)_\n_name: Connect_\n_returns: bool_\n_returns_description: _\n_parameters: const char *pHost, unsigned short usPort_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nConnect to a socket client to send information.\n\n~~~~{.cpp}\n\nudpConnection.Create();\nudpConnection.Connect(\"127.0.0.1\",11999);\nudpConnection.SetNonBlocking(true);\n\n~~~~\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool ConnectMcast(*pMcast, usPort)\n\n<!--\n_syntax: ConnectMcast(*pMcast, usPort)_\n_name: ConnectMcast_\n_returns: bool_\n_returns_description: _\n_parameters: char *pMcast, unsigned short usPort_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nConnect to a multicast address. \n\n~~~~{.cpp}\n\nudpConnection.Create();\nudpConnection.Connect(\"224.0.0.1\",11999);\n\n~~~~\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool Create()\n\n<!--\n_syntax: Create()_\n_name: Create_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nCreate the UDP manager. Must be called before binding to any IP or sockets.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool GetListenAddr(&address, &port)\n\n<!--\n_syntax: GetListenAddr(&address, &port)_\n_name: GetListenAddr_\n_returns: bool_\n_returns_description: _\n_parameters: string &address, int &port_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###int GetMaxMsgSize()\n\n<!--\n_syntax: GetMaxMsgSize()_\n_name: GetMaxMsgSize_\n_returns: int_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###int GetReceiveBufferSize()\n\n<!--\n_syntax: GetReceiveBufferSize()_\n_name: GetReceiveBufferSize_\n_returns: int_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nGet the size of the receive buffer. The minimum (doubled) value for this option is 256. The max is determined by your OS.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool GetRemoteAddr(&address, &port)\n\n<!--\n_syntax: GetRemoteAddr(&address, &port)_\n_name: GetRemoteAddr_\n_returns: bool_\n_returns_description: _\n_parameters: string &address, int &port_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nReturns the dots and numbers remote address in a string, \n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###int GetSendBufferSize()\n\n<!--\n_syntax: GetSendBufferSize()_\n_name: GetSendBufferSize_\n_returns: int_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nGet the size of the send buffer. The minimum (doubled) value for this option is 256. The max is determined by your OS.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###int GetTTL()\n\n<!--\n_syntax: GetTTL()_\n_name: GetTTL_\n_returns: int_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nreturns -1 on failure\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###int GetTimeoutReceive()\n\n<!--\n_syntax: GetTimeoutReceive()_\n_name: GetTimeoutReceive_\n_returns: int_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nReturn the current receive timeout.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###int GetTimeoutSend()\n\n<!--\n_syntax: GetTimeoutSend()_\n_name: GetTimeoutSend_\n_returns: int_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nReturn the current send timeout.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool HasSocket()\n\n<!--\n_syntax: HasSocket()_\n_name: HasSocket_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###int PeekReceive()\n\n<!--\n_syntax: PeekReceive()_\n_name: PeekReceive_\n_returns: int_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###int Receive(*pBuff, iSize)\n\n<!--\n_syntax: Receive(*pBuff, iSize)_\n_name: Receive_\n_returns: int_\n_returns_description: _\n_parameters: char *pBuff, const int iSize_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nReceives a message to a buffer of size iSize. Receive() returns the number of bytes actually received.\n\n~~~~{.cpp}\nchar udpMessage[100000];\nudpConnection.Receive(udpMessage,100000);\nstring message=udpMessage;\n~~~~\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###int Send(*pBuff, iSize)\n\n<!--\n_syntax: Send(*pBuff, iSize)_\n_name: Send_\n_returns: int_\n_returns_description: _\n_parameters: const char *pBuff, const int iSize_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nSend a char* of data with length of iSize to all listeners.\n\n~~~~{.cpp}\nstring message = \"A message\";\nudpConnection.Send(message.c_str(),message.length());\n\n~~~~\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###int SendAll(*pBuff, iSize)\n\n<!--\n_syntax: SendAll(*pBuff, iSize)_\n_name: SendAll_\n_returns: int_\n_returns_description: _\n_parameters: const char *pBuff, const int iSize_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThe SendAll() method is useful for extremely large data objects that may need multiple sendto() calls to actually be completely.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool SetEnableBroadcast(enableBroadcast)\n\n<!--\n_syntax: SetEnableBroadcast(enableBroadcast)_\n_name: SetEnableBroadcast_\n_returns: bool_\n_returns_description: _\n_parameters: bool enableBroadcast_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nBroadcast allows sending of packets to a particular network layer. If you're only using a single local network without a large number of attached machines, using broadcast may make more sense than trying to use multicast.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool SetNonBlocking(useNonBlocking)\n\n<!--\n_syntax: SetNonBlocking(useNonBlocking)_\n_name: SetNonBlocking_\n_returns: bool_\n_returns_description: _\n_parameters: bool useNonBlocking_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nDetermines whether calls to send or receive are allowed to block their thread until they've completed. If your network infrastructure is time critical, then this may be a good choice. Usually though, you should leave it off.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool SetReceiveBufferSize(sizeInByte)\n\n<!--\n_syntax: SetReceiveBufferSize(sizeInByte)_\n_name: SetReceiveBufferSize_\n_returns: bool_\n_returns_description: _\n_parameters: int sizeInByte_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nSet the size of the receive buffer. The minimum (doubled) value for this option is 256. The max is determined by your OS.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool SetReuseAddress(allowReuse)\n\n<!--\n_syntax: SetReuseAddress(allowReuse)_\n_name: SetReuseAddress_\n_returns: bool_\n_returns_description: _\n_parameters: bool allowReuse_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool SetSendBufferSize(sizeInByte)\n\n<!--\n_syntax: SetSendBufferSize(sizeInByte)_\n_name: SetSendBufferSize_\n_returns: bool_\n_returns_description: _\n_parameters: int sizeInByte_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nSet the size of the send buffer. The minimum (doubled) value for this option is 256. The max is determined by your OS.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool SetTTL(nTTL)\n\n<!--\n_syntax: SetTTL(nTTL)_\n_name: SetTTL_\n_returns: bool_\n_returns_description: _\n_parameters: int nTTL_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThe TTL (Time To Live) field in the IP header has a double significance in multicast. As always, it controls the live time of the datagram to avoid it being looped forever due to routing errors. Routers decrement the TTL of every datagram as it traverses from one network to another and when its value reaches 0 the packet is dropped.\n\nA list of TTL thresholds and their associated scope follows:\n\nTTL     Scope\n----------------------------------------------------------------------\n   0    Restricted to the same host. Won't be output by any interface.\n   1    Restricted to the same subnet. Won't be forwarded by a router.\n <32         Restricted to the same site, organization or department.\n <64 Restricted to the same region.\n<128 Restricted to the same continent.\n<255 Unrestricted in scope. Global.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void SetTimeoutReceive(timeoutInSeconds)\n\n<!--\n_syntax: SetTimeoutReceive(timeoutInSeconds)_\n_name: SetTimeoutReceive_\n_returns: void_\n_returns_description: _\n_parameters: int timeoutInSeconds_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nSet a timeout for any receive operations in seconds.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void SetTimeoutSend(timeoutInSeconds)\n\n<!--\n_syntax: SetTimeoutSend(timeoutInSeconds)_\n_name: SetTimeoutSend_\n_returns: void_\n_returns_description: _\n_parameters: int timeoutInSeconds_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nSet a timeout for any send operations in seconds.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool Setup(&settings)\n\n<!--\n_syntax: Setup(&settings)_\n_name: Setup_\n_returns: bool_\n_returns_description: _\n_parameters: const ofxUDPSettings &settings_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###int WaitReceive(timeoutSeconds, timeoutMillis)\n\n<!--\n_syntax: WaitReceive(timeoutSeconds, timeoutMillis)_\n_name: WaitReceive_\n_returns: int_\n_returns_description: _\n_parameters: time_t timeoutSeconds, time_t timeoutMillis_\n_access: protected_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###int WaitSend(timeoutSeconds, timeoutMillis)\n\n<!--\n_syntax: WaitSend(timeoutSeconds, timeoutMillis)_\n_name: WaitSend_\n_returns: int_\n_returns_description: _\n_parameters: time_t timeoutSeconds, time_t timeoutMillis_\n_access: protected_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n### ofxUDPManager()\n\n<!--\n_syntax: ofxUDPManager()_\n_name: ofxUDPManager_\n_returns: _\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n### ~ofxUDPManager()\n\n<!--\n_syntax: ~ofxUDPManager()_\n_name: ~ofxUDPManager_\n_returns: _\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n##Variables\n\n\n\n###bool canGetRemoteAddress\n\n<!--\n_name: canGetRemoteAddress_\n_type: bool_\n_access: protected_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool m_bWinsockInit\n\n<!--\n_name: m_bWinsockInit_\n_type: bool_\n_access: protected_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###unsigned long m_dwTimeoutReceive\n\n<!--\n_name: m_dwTimeoutReceive_\n_type: unsigned long_\n_access: protected_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###unsigned long m_dwTimeoutSend\n\n<!--\n_name: m_dwTimeoutSend_\n_type: unsigned long_\n_access: protected_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###int m_hSocket\n\n<!--\n_name: m_hSocket_\n_type: int_\n_access: protected_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool nonBlocking\n\n<!--\n_name: nonBlocking_\n_type: bool_\n_access: protected_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###struct sockaddr_in saClient\n\n<!--\n_name: saClient_\n_type: struct sockaddr_in_\n_access: protected_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###struct sockaddr_in saServer\n\n<!--\n_name: saServer_\n_type: struct sockaddr_in_\n_access: protected_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n","type":"page","static":true}}],"fetch":[]}