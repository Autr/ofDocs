{"data":[{"page":{"entry":{"name":"ofVideoGrabber","filename":"ofVideoGrabber.markdown","absolute":"/Users/Gilbert/Code/openFrameworks/ofSite/documentation/video/ofVideoGrabber.markdown","path":"/documentation/video/ofVideoGrabber","route":"/documentation/video/ofVideoGrabber.markdown","dir":"../ofSite/documentation/video","ext":"markdown","type":"page","id":2260,"parent":2237,"breadcrumbs":[2237,1718],"siblings":[],"translations":{}},"description":{"short":"","full":"<p>The ofVideoGrabber class wraps QuickTime's sequence grabbing component to provide low level access to live cameras. On Microsoft Windows it now uses the DirectShow based videoInput library which offers mainy performance advantages over QuickTime and does not require QuickTime or WinVDig to be installed. A #define in ofConstants.h allows you to choose whether to use QuickTime or DirectShow (default) for Microsoft Windows.\nIn Linux it uses by default unicap, although you can change to V4L through a #define in ofConstants in case some V4L devices don't work properly with unicap.</p>\n<h1></h1>\n"},"config":{"visible":"True","advanced":"False","istemplated":"False","extends":"ofBaseVideoGrabber, ofBaseVideoDraws"},"methods":[{"syntax":"bind()","name":"bind","returns":"void","returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"close()","name":"close","returns":"void","returns_description":null,"parameters":null,"access":"public","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Closes the sequence grabber and de-allocates any allocated resources. Call this only when you want to stop the video grabber finally. See also initGrabber()</p>\n"},{"syntax":"draw(x, y)","name":"draw","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> y","access":"public","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Draws the internal texture of the movie grabber class at the position (x,y) with the internal width and height of the movie grabber. It uses the native size of the grabber, so if you initialize the grabber at 320 x 240, it will draw a rectangle at x,y with a width and height of 320 x 240. Please note, ofSetRectMode() can have an effect on if the x,y is the top left corner or center point.</p>\n"},{"syntax":"draw(x, y, w, h)","name":"draw","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> y<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> w<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> h","access":"public","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Draws the internal texture of the movie grabber class at the position (x,y) with the given width (w) and height (h). As the video grabber operates, it grabs pixel data and uploads it to it's internal texture (ie, on the GPU), unless you call setUseTexture(false), which disables the texture uploading. This draws that internal texture on screen.</p>\n"},{"short":"","desc":"<p>getGrabber returns a pointer (ofPtr) to the internally running video grabber. Since the ofVideoGrabber object has different potential systems for grabbing (QuickTime, QTKit, DirectShow), this ptr gives you access to the underlying video grabber that's running inside of ofVideoGrabber. Note: use this only if you need low level access to an internal grabbing object, such as to call a specific function.</p>\n"},{"short":"","desc":""},{"short":"","desc":""},{"short":"","desc":""},{"syntax":"getHeight()","name":"getHeight","returns":"float","returns_description":null,"parameters":null,"access":"public","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Returns the height of the video grabber object. If you initialize the object at 320x240, it will return 240;</p>\n"},{"syntax":"getPixelFormat()","name":"getPixelFormat","returns":"ofPixelFormat","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Returns the height of the video grabber object. If you initialize the object at 320x240, it will return 240;</p>\n"},{"syntax":"getPixels()","name":"getPixels","returns":"ofPixels &","returns_description":null,"parameters":null,"access":"public","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Returns the pointer to the array of pixels that represents the current frame of live video. the data is stored interleaved as RGB, and in an array which is the size: width<em>height</em>3. This function returns a pointer to an unsigned char array -- it's up to the user to deal with this memory correctly. Functions like getWidth() and getHeight() can help.</p>\n"},{"syntax":"getPixels()","name":"getPixels","returns":"const ofPixels &","returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"getTexture()","name":"getTexture","returns":"ofTexture &","returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"getTexture()","name":"getTexture","returns":"const ofTexture &","returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"getTexturePlanes()","name":"getTexturePlanes","returns":"int &","returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"getTexturePlanes()","name":"getTexturePlanes","returns":"const int &","returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"getWidth()","name":"getWidth","returns":"float","returns_description":null,"parameters":null,"access":"public","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Returns the width of the video grabber object. If you initialize the object at 320x240, it will return 320.</p>\n"},{"syntax":"initGrabber(w, h)","name":"initGrabber","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">int</span> w<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> h","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Initializes either the default capture device or the capture device specified by setDeviceID. Attempts to setup capture at the width and height specified. If the capture dimensions are not available it will setup capture for the next closest dimensions available. It is good to check what the actual size is before you start processing the pixels.</p>\n<pre><code>\nmyGrabber<span class=\"token punctuation\">.</span><span class=\"token function\">setVerbose</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmyGrabber<span class=\"token punctuation\">.</span><span class=\"token function\">setDeviceID</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmyGrabber<span class=\"token punctuation\">.</span><span class=\"token function\">initGrabber</span><span class=\"token punctuation\">(</span><span class=\"token number\">320</span><span class=\"token punctuation\">,</span><span class=\"token number\">240</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> grabW <span class=\"token operator\">=</span> myGrabber<span class=\"token punctuation\">.</span><span class=\"token function\">getWidth</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> grabH <span class=\"token operator\">=</span> myGrabber<span class=\"token punctuation\">.</span><span class=\"token function\">getHeight</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>asked <span class=\"token keyword\">for</span> <span class=\"token number\">320</span> by <span class=\"token number\">240</span> <span class=\"token operator\">-</span> actual size is <span class=\"token operator\">%</span>i by <span class=\"token operator\">%</span>i<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">,</span> grabW<span class=\"token punctuation\">,</span> grabH<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n"},{"syntax":"isFrameNew()","name":"isFrameNew","returns":"bool","returns_description":null,"parameters":null,"access":"public","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>This function can be called after calling ofImage::update() (or alternatively, ofImage::ofIdleGrabber()) to figure out if a frame is new, ie. if there is a new pixel data.  This is typically because your main frame rate might not be in sync with the video grabber, and you can skip processing on frames where there is no new data.</p>\n<pre><code>\n<span class=\"token keyword\">void</span> testApp<span class=\"token operator\">::</span><span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\n\tgrabber<span class=\"token punctuation\">.</span><span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// call this once per update</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>grabber<span class=\"token punctuation\">.</span><span class=\"token function\">isFrameNew</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// do computer vision / process the pixels</span>\n\t<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n"},{"syntax":"isInitialized()","name":"isInitialized","returns":"bool","returns_description":null,"parameters":null,"access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Returns a boolean if the video grabber is properly initialized.</p>\n"},{"syntax":"isUsingTexture()","name":"isUsingTexture","returns":"bool","returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"listDevices()","name":"listDevices","returns":"int","returns_description":null,"parameters":null,"access":"public","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Prints to the console a list of available capture devices with the device ID of each device. The device ID can then be used with setDeviceID() to specify a specific device to capture from.  This is especially useful if you have multiple devices, or want to see what kind of cameras openframeworks sees.</p>\n"},{"syntax":"ofVideoGrabber()","name":"ofVideoGrabber","returns":null,"returns_description":null,"parameters":null,"access":"public","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"False","advanced":"False","short":"","desc":"<p>Initializes the video grabber. This function doesn't really do any real allocation, which happens in ofVideoGrabber::initGrabber(). In openframeworks we typically use empty constructors so that objects can be defined in h files, ie, you don't need to do dynamic allocation or use pointers as much in your code.</p>\n"},{"syntax":"resetAnchor()","name":"resetAnchor","returns":"void","returns_description":null,"parameters":null,"access":"public","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"True","short":"","desc":"<p>This removes any anchor positioning, meaning that the ofVideoGrabber will be draw with the upper left hand corner at the point passed into draw().</p>\n"},{"syntax":"setAnchorPercent(xPct, yPct)","name":"setAnchorPercent","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> xPct<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> yPct","access":"public","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"True","short":"","desc":"<p>Adjusts ofVideoGrabbers anchor for more drawing control. See ofImage::setAnchorPercent() for info.</p>\n"},{"syntax":"setAnchorPoint(x, y)","name":"setAnchorPoint","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> y","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Adjusts ofVideoGrabbers anchor for more drawing control. See ofImage::setAnchorPoint(x,y) for info.</p>\n"},{"syntax":"setDesiredFrameRate(framerate)","name":"setDesiredFrameRate","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">int</span> framerate","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Set's the desired frame rate of the grabber. This should be called before initGrabber(), which will try to initialize at the desired frame rate. Not all frame rates will be supported, but this at least gives you some abilitity to try grab at different rates.</p>\n"},{"syntax":"setDeviceID(_deviceID)","name":"setDeviceID","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">int</span> _deviceID","access":"public","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Choose to capture from a specific capture device specified by _deviceID. Use listDevices() to see a list of available capture devices and their device IDs. This should be called before initGrabber(), which will use this info to choose the device you want.</p>\n"},{"short":"","desc":"<p>This function, similar to getGrabber, allows for low level access to the internal grabber object. This is useful if you want to adjust the internal grabber that ofVideoGrabber is using.</p>\n"},{"syntax":"setPixelFormat(pixelFormat)","name":"setPixelFormat","returns":"bool","returns_description":null,"parameters":"ofPixelFormat pixelFormat","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Some video grabbers allow you to adjust the pixel format, which might help for optimization. At the moment, this seems to only apply to the Linux video grabber (GST). For all other grabbers, the only format accepted is OF_PIXELS_RGB.</p>\n"},{"syntax":"setUseTexture(bUse)","name":"setUseTexture","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">bool</span> bUse","access":"public","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Set the usage of texture inside this object. Typically, you will want to draw the movie grabber on screen, and so it will be necessary to use a texture, but there may be cases where it helps to not use a texture in order to save memory or for better performance. To disable the internal use of the texture, you can initialize the sequence grabber like this:</p>\n<pre><code>\nmyGrabber<span class=\"token punctuation\">.</span><span class=\"token function\">setUseTexture</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmyGrabber<span class=\"token punctuation\">.</span><span class=\"token function\">initGrabber</span><span class=\"token punctuation\">(</span><span class=\"token number\">320</span><span class=\"token punctuation\">,</span><span class=\"token number\">240</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n"},{"syntax":"setVerbose(bTalkToMe)","name":"setVerbose","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">bool</span> bTalkToMe","access":"public","version_started":"006","version_deprecated":"0.06","summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Sets the verbosity - this can be useful for debugging the video grabber interface. you can set the verbosity and then try initGrabber();</p>\n<p>From 0.06 this method has no effect. Use ofSetLogLevel(OF_LOG_VERBOSE) to enable verbose messages.</p>\n<pre><code>\nmyGrabber<span class=\"token punctuation\">.</span><span class=\"token function\">setVerbose</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmyGrabber<span class=\"token punctuation\">.</span><span class=\"token function\">initGrabber</span><span class=\"token punctuation\">(</span><span class=\"token number\">320</span><span class=\"token punctuation\">,</span><span class=\"token number\">240</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n"},{"syntax":"setup(w, h)","name":"setup","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">int</span> w<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> h","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"setup(w, h, bTexture)","name":"setup","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">int</span> w<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> h<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> bTexture","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"unbind()","name":"unbind","returns":"void","returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"update()","name":"update","returns":"void","returns_description":null,"parameters":null,"access":"public","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Calls grabframe function.</p>\n"},{"syntax":"videoSettings()","name":"videoSettings","returns":"void","returns_description":null,"parameters":null,"access":"public","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Loads the video settings on screen. If your OpenGL application is full screen, this window might appear underneath the main window the first time you call this. Note: in QTKit grabbers (10.7+), this video settings panel is not available.</p>\n"},{"syntax":"~ofVideoGrabber()","name":"~ofVideoGrabber","returns":null,"returns_description":null,"parameters":null,"access":"public","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"False","advanced":"False","short":"","desc":"<p>Destructor for the video grabber, will release any allocated memory.</p>\n"},{"name":"bUseTexture","type":"bool","access":"protected","version_started":"006","version_deprecated":null,"summary":null,"visible":"True","constant":"False","advanced":"False","short":"","desc":""},{"name":"desiredFramerate","type":"int","access":"private","version_started":"007","version_deprecated":null,"summary":null,"visible":"True","constant":"True","advanced":"False","short":"","desc":""},{"name":"grabber","type":"ofPtr","access":"private","version_started":"007","version_deprecated":null,"summary":null,"visible":"True","constant":"True","advanced":"False","short":"","desc":""},{"name":"internalPixelFormat","type":"ofPixelFormat","access":"private","version_started":"007","version_deprecated":null,"summary":null,"visible":"True","constant":"True","advanced":"False","short":"","desc":""},{"name":"requestedDeviceID","type":"int","access":"private","version_started":"0.9.0","version_deprecated":null,"summary":null,"visible":"True","constant":"False","advanced":"False","short":"","desc":""},{"name":"tex","type":"ofTexture","access":"protected","version_started":"006","version_deprecated":null,"summary":null,"visible":"True","constant":"False","advanced":"False","short":"","desc":""},{}],"document":"<p>#class ofVideoGrabber</p>\n<p>&lt;!--\n<em>visible: True</em>\n<em>advanced: False</em>\n<em>istemplated: False</em>\n<em>extends: ofBaseVideoGrabber, ofBaseVideoDraws</em>\n--&gt;</p>\n<p>##InlineDescription</p>\n<p>##Description</p>\n<p>The ofVideoGrabber class wraps QuickTime's sequence grabbing component to provide low level access to live cameras. On Microsoft Windows it now uses the DirectShow based videoInput library which offers mainy performance advantages over QuickTime and does not require QuickTime or WinVDig to be installed. A #define in ofConstants.h allows you to choose whether to use QuickTime or DirectShow (default) for Microsoft Windows.\nIn Linux it uses by default unicap, although you can change to V4L through a #define in ofConstants in case some V4L devices don't work properly with unicap.</p>\n<p>##Methods</p>\n<p>###void bind()</p>\n<p>&lt;!--\n<em>syntax: bind()</em>\n<em>name: bind</em>\n<em>returns: void</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void close()</p>\n<p>&lt;!--\n<em>syntax: close()</em>\n<em>name: close</em>\n<em>returns: void</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Closes the sequence grabber and de-allocates any allocated resources. Call this only when you want to stop the video grabber finally. See also initGrabber()</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void draw(x, y)</p>\n<p>&lt;!--\n<em>syntax: draw(x, y)</em>\n<em>name: draw</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: float x, float y</em>\n<em>access: public</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Draws the internal texture of the movie grabber class at the position (x,y) with the internal width and height of the movie grabber. It uses the native size of the grabber, so if you initialize the grabber at 320 x 240, it will draw a rectangle at x,y with a width and height of 320 x 240. Please note, ofSetRectMode() can have an effect on if the x,y is the top left corner or center point.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void draw(x, y, w, h)</p>\n<p>&lt;!--\n<em>syntax: draw(x, y, w, h)</em>\n<em>name: draw</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: float x, float y, float w, float h</em>\n<em>access: public</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Draws the internal texture of the movie grabber class at the position (x,y) with the given width (w) and height (h). As the video grabber operates, it grabs pixel data and uploads it to it's internal texture (ie, on the GPU), unless you call setUseTexture(false), which disables the texture uploading. This draws that internal texture on screen.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###shared_ptr&lt; ofBaseVideoGrabber &gt; getGrabber()</p>\n<p>&lt;!--\n<em>syntax: getGrabber()</em>\n<em>name: getGrabber</em>\n<em>returns: shared_ptr&lt; ofBaseVideoGrabber &gt;</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>getGrabber returns a pointer (ofPtr) to the internally running video grabber. Since the ofVideoGrabber object has different potential systems for grabbing (QuickTime, QTKit, DirectShow), this ptr gives you access to the underlying video grabber that's running inside of ofVideoGrabber. Note: use this only if you need low level access to an internal grabbing object, such as to call a specific function.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###const shared_ptr&lt; ofBaseVideoGrabber &gt; getGrabber()</p>\n<p>&lt;!--\n<em>syntax: getGrabber()</em>\n<em>name: getGrabber</em>\n<em>returns: const shared_ptr&lt; ofBaseVideoGrabber &gt;</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###shared_ptr&lt; GrabberType &gt; getGrabber()</p>\n<p>&lt;!--\n<em>syntax: getGrabber()</em>\n<em>name: getGrabber</em>\n<em>returns: shared_ptr&lt; GrabberType &gt;</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###const shared_ptr&lt; GrabberType &gt; getGrabber()</p>\n<p>&lt;!--\n<em>syntax: getGrabber()</em>\n<em>name: getGrabber</em>\n<em>returns: const shared_ptr&lt; GrabberType &gt;</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float getHeight()</p>\n<p>&lt;!--\n<em>syntax: getHeight()</em>\n<em>name: getHeight</em>\n<em>returns: float</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Returns the height of the video grabber object. If you initialize the object at 320x240, it will return 240;</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###ofPixelFormat getPixelFormat()</p>\n<p>&lt;!--\n<em>syntax: getPixelFormat()</em>\n<em>name: getPixelFormat</em>\n<em>returns: ofPixelFormat</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Returns the height of the video grabber object. If you initialize the object at 320x240, it will return 240;</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###ofPixels &amp; getPixels()</p>\n<p>&lt;!--\n<em>syntax: getPixels()</em>\n<em>name: getPixels</em>\n<em>returns: ofPixels &amp;</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Returns the pointer to the array of pixels that represents the current frame of live video. the data is stored interleaved as RGB, and in an array which is the size: width<em>height</em>3. This function returns a pointer to an unsigned char array -- it's up to the user to deal with this memory correctly. Functions like getWidth() and getHeight() can help.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###const ofPixels &amp; getPixels()</p>\n<p>&lt;!--\n<em>syntax: getPixels()</em>\n<em>name: getPixels</em>\n<em>returns: const ofPixels &amp;</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###ofTexture &amp; getTexture()</p>\n<p>&lt;!--\n<em>syntax: getTexture()</em>\n<em>name: getTexture</em>\n<em>returns: ofTexture &amp;</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###const ofTexture &amp; getTexture()</p>\n<p>&lt;!--\n<em>syntax: getTexture()</em>\n<em>name: getTexture</em>\n<em>returns: const ofTexture &amp;</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###int &amp; getTexturePlanes()</p>\n<p>&lt;!--\n<em>syntax: getTexturePlanes()</em>\n<em>name: getTexturePlanes</em>\n<em>returns: int &amp;</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###const int &amp; getTexturePlanes()</p>\n<p>&lt;!--\n<em>syntax: getTexturePlanes()</em>\n<em>name: getTexturePlanes</em>\n<em>returns: const int &amp;</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float getWidth()</p>\n<p>&lt;!--\n<em>syntax: getWidth()</em>\n<em>name: getWidth</em>\n<em>returns: float</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Returns the width of the video grabber object. If you initialize the object at 320x240, it will return 320.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool initGrabber(w, h)</p>\n<p>&lt;!--\n<em>syntax: initGrabber(w, h)</em>\n<em>name: initGrabber</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: int w, int h</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Initializes either the default capture device or the capture device specified by setDeviceID. Attempts to setup capture at the width and height specified. If the capture dimensions are not available it will setup capture for the next closest dimensions available. It is good to check what the actual size is before you start processing the pixels.</p>\n<pre><code>\nmyGrabber<span class=\"token punctuation\">.</span><span class=\"token function\">setVerbose</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmyGrabber<span class=\"token punctuation\">.</span><span class=\"token function\">setDeviceID</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmyGrabber<span class=\"token punctuation\">.</span><span class=\"token function\">initGrabber</span><span class=\"token punctuation\">(</span><span class=\"token number\">320</span><span class=\"token punctuation\">,</span><span class=\"token number\">240</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> grabW <span class=\"token operator\">=</span> myGrabber<span class=\"token punctuation\">.</span><span class=\"token function\">getWidth</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> grabH <span class=\"token operator\">=</span> myGrabber<span class=\"token punctuation\">.</span><span class=\"token function\">getHeight</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>asked <span class=\"token keyword\">for</span> <span class=\"token number\">320</span> by <span class=\"token number\">240</span> <span class=\"token operator\">-</span> actual size is <span class=\"token operator\">%</span>i by <span class=\"token operator\">%</span>i<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">,</span> grabW<span class=\"token punctuation\">,</span> grabH<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool isFrameNew()</p>\n<p>&lt;!--\n<em>syntax: isFrameNew()</em>\n<em>name: isFrameNew</em>\n<em>returns: bool</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This function can be called after calling ofImage::update() (or alternatively, ofImage::ofIdleGrabber()) to figure out if a frame is new, ie. if there is a new pixel data.  This is typically because your main frame rate might not be in sync with the video grabber, and you can skip processing on frames where there is no new data.</p>\n<pre><code>\n<span class=\"token keyword\">void</span> testApp<span class=\"token operator\">::</span><span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\n\tgrabber<span class=\"token punctuation\">.</span><span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// call this once per update</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>grabber<span class=\"token punctuation\">.</span><span class=\"token function\">isFrameNew</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// do computer vision / process the pixels</span>\n\t<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool isInitialized()</p>\n<p>&lt;!--\n<em>syntax: isInitialized()</em>\n<em>name: isInitialized</em>\n<em>returns: bool</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Returns a boolean if the video grabber is properly initialized.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool isUsingTexture()</p>\n<p>&lt;!--\n<em>syntax: isUsingTexture()</em>\n<em>name: isUsingTexture</em>\n<em>returns: bool</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###int listDevices()</p>\n<p>&lt;!--\n<em>syntax: listDevices()</em>\n<em>name: listDevices</em>\n<em>returns: int</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Prints to the console a list of available capture devices with the device ID of each device. The device ID can then be used with setDeviceID() to specify a specific device to capture from.  This is especially useful if you have multiple devices, or want to see what kind of cameras openframeworks sees.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<h3>ofVideoGrabber()</h3>\n<p>&lt;!--\n<em>syntax: ofVideoGrabber()</em>\n<em>name: ofVideoGrabber</em>\n_returns: _\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: False</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Initializes the video grabber. This function doesn't really do any real allocation, which happens in ofVideoGrabber::initGrabber(). In openframeworks we typically use empty constructors so that objects can be defined in h files, ie, you don't need to do dynamic allocation or use pointers as much in your code.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void resetAnchor()</p>\n<p>&lt;!--\n<em>syntax: resetAnchor()</em>\n<em>name: resetAnchor</em>\n<em>returns: void</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: True</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This removes any anchor positioning, meaning that the ofVideoGrabber will be draw with the upper left hand corner at the point passed into draw().</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setAnchorPercent(xPct, yPct)</p>\n<p>&lt;!--\n<em>syntax: setAnchorPercent(xPct, yPct)</em>\n<em>name: setAnchorPercent</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: float xPct, float yPct</em>\n<em>access: public</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: True</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Adjusts ofVideoGrabbers anchor for more drawing control. See ofImage::setAnchorPercent() for info.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setAnchorPoint(x, y)</p>\n<p>&lt;!--\n<em>syntax: setAnchorPoint(x, y)</em>\n<em>name: setAnchorPoint</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: float x, float y</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Adjusts ofVideoGrabbers anchor for more drawing control. See ofImage::setAnchorPoint(x,y) for info.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setDesiredFrameRate(framerate)</p>\n<p>&lt;!--\n<em>syntax: setDesiredFrameRate(framerate)</em>\n<em>name: setDesiredFrameRate</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: int framerate</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Set's the desired frame rate of the grabber. This should be called before initGrabber(), which will try to initialize at the desired frame rate. Not all frame rates will be supported, but this at least gives you some abilitity to try grab at different rates.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setDeviceID(_deviceID)</p>\n<p>&lt;!--\n_syntax: setDeviceID(<em>deviceID)</em>\n<em>name: setDeviceID</em>\n<em>returns: void</em>\n_returns_description: _\n_parameters: int <em>deviceID</em>\n<em>access: public</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Choose to capture from a specific capture device specified by _deviceID. Use listDevices() to see a list of available capture devices and their device IDs. This should be called before initGrabber(), which will use this info to choose the device you want.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setGrabber(newGrabber)</p>\n<p>&lt;!--\n<em>syntax: setGrabber(newGrabber)</em>\n<em>name: setGrabber</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: shared_ptr&lt; ofBaseVideoGrabber &gt; newGrabber</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>This function, similar to getGrabber, allows for low level access to the internal grabber object. This is useful if you want to adjust the internal grabber that ofVideoGrabber is using.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool setPixelFormat(pixelFormat)</p>\n<p>&lt;!--\n<em>syntax: setPixelFormat(pixelFormat)</em>\n<em>name: setPixelFormat</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: ofPixelFormat pixelFormat</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Some video grabbers allow you to adjust the pixel format, which might help for optimization. At the moment, this seems to only apply to the Linux video grabber (GST). For all other grabbers, the only format accepted is OF_PIXELS_RGB.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setUseTexture(bUse)</p>\n<p>&lt;!--\n<em>syntax: setUseTexture(bUse)</em>\n<em>name: setUseTexture</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: bool bUse</em>\n<em>access: public</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Set the usage of texture inside this object. Typically, you will want to draw the movie grabber on screen, and so it will be necessary to use a texture, but there may be cases where it helps to not use a texture in order to save memory or for better performance. To disable the internal use of the texture, you can initialize the sequence grabber like this:</p>\n<pre><code>\nmyGrabber<span class=\"token punctuation\">.</span><span class=\"token function\">setUseTexture</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmyGrabber<span class=\"token punctuation\">.</span><span class=\"token function\">initGrabber</span><span class=\"token punctuation\">(</span><span class=\"token number\">320</span><span class=\"token punctuation\">,</span><span class=\"token number\">240</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setVerbose(bTalkToMe)</p>\n<p>&lt;!--\n<em>syntax: setVerbose(bTalkToMe)</em>\n<em>name: setVerbose</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: bool bTalkToMe</em>\n<em>access: public</em>\n<em>version_started: 006</em>\n<em>version_deprecated: 0.06</em>\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Sets the verbosity - this can be useful for debugging the video grabber interface. you can set the verbosity and then try initGrabber();</p>\n<p>From 0.06 this method has no effect. Use ofSetLogLevel(OF_LOG_VERBOSE) to enable verbose messages.</p>\n<pre><code>\nmyGrabber<span class=\"token punctuation\">.</span><span class=\"token function\">setVerbose</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmyGrabber<span class=\"token punctuation\">.</span><span class=\"token function\">initGrabber</span><span class=\"token punctuation\">(</span><span class=\"token number\">320</span><span class=\"token punctuation\">,</span><span class=\"token number\">240</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool setup(w, h)</p>\n<p>&lt;!--\n<em>syntax: setup(w, h)</em>\n<em>name: setup</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: int w, int h</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool setup(w, h, bTexture)</p>\n<p>&lt;!--\n<em>syntax: setup(w, h, bTexture)</em>\n<em>name: setup</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: int w, int h, bool bTexture</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void unbind()</p>\n<p>&lt;!--\n<em>syntax: unbind()</em>\n<em>name: unbind</em>\n<em>returns: void</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void update()</p>\n<p>&lt;!--\n<em>syntax: update()</em>\n<em>name: update</em>\n<em>returns: void</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Calls grabframe function.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void videoSettings()</p>\n<p>&lt;!--\n<em>syntax: videoSettings()</em>\n<em>name: videoSettings</em>\n<em>returns: void</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Loads the video settings on screen. If your OpenGL application is full screen, this window might appear underneath the main window the first time you call this. Note: in QTKit grabbers (10.7+), this video settings panel is not available.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<h3>~ofVideoGrabber()</h3>\n<p>&lt;!--\n<em>syntax: ~ofVideoGrabber()</em>\n<em>name: ~ofVideoGrabber</em>\n_returns: _\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: False</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Destructor for the video grabber, will release any allocated memory.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>##Variables</p>\n<p>###bool bUseTexture</p>\n<p>&lt;!--\n<em>name: bUseTexture</em>\n<em>type: bool</em>\n<em>access: protected</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>visible: True</em>\n<em>constant: False</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###int desiredFramerate</p>\n<p>&lt;!--\n<em>name: desiredFramerate</em>\n<em>type: int</em>\n<em>access: private</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>visible: True</em>\n<em>constant: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###ofPtr grabber</p>\n<p>&lt;!--\n<em>name: grabber</em>\n<em>type: ofPtr</em>\n<em>access: private</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>visible: True</em>\n<em>constant: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###ofPixelFormat internalPixelFormat</p>\n<p>&lt;!--\n<em>name: internalPixelFormat</em>\n<em>type: ofPixelFormat</em>\n<em>access: private</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>visible: True</em>\n<em>constant: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###int requestedDeviceID</p>\n<p>&lt;!--\n<em>name: requestedDeviceID</em>\n<em>type: int</em>\n<em>access: private</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>visible: True</em>\n<em>constant: False</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###ofTexture tex</p>\n<p>&lt;!--\n<em>name: tex</em>\n<em>type: ofTexture</em>\n<em>access: protected</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>visible: True</em>\n<em>constant: False</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n","raw":"#class ofVideoGrabber\n\n\n<!--\n_visible: True_\n_advanced: False_\n_istemplated: False_\n_extends: ofBaseVideoGrabber, ofBaseVideoDraws_\n-->\n\n##InlineDescription\n\n\n\n\n\n\n##Description\n\nThe ofVideoGrabber class wraps QuickTime's sequence grabbing component to provide low level access to live cameras. On Microsoft Windows it now uses the DirectShow based videoInput library which offers mainy performance advantages over QuickTime and does not require QuickTime or WinVDig to be installed. A #define in ofConstants.h allows you to choose whether to use QuickTime or DirectShow (default) for Microsoft Windows.\nIn Linux it uses by default unicap, although you can change to V4L through a #define in ofConstants in case some V4L devices don't work properly with unicap.\n\n\n\n\n\n##Methods\n\n\n\n###void bind()\n\n<!--\n_syntax: bind()_\n_name: bind_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void close()\n\n<!--\n_syntax: close()_\n_name: close_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nCloses the sequence grabber and de-allocates any allocated resources. Call this only when you want to stop the video grabber finally. See also initGrabber()\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void draw(x, y)\n\n<!--\n_syntax: draw(x, y)_\n_name: draw_\n_returns: void_\n_returns_description: _\n_parameters: float x, float y_\n_access: public_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nDraws the internal texture of the movie grabber class at the position (x,y) with the internal width and height of the movie grabber. It uses the native size of the grabber, so if you initialize the grabber at 320 x 240, it will draw a rectangle at x,y with a width and height of 320 x 240. Please note, ofSetRectMode() can have an effect on if the x,y is the top left corner or center point.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void draw(x, y, w, h)\n\n<!--\n_syntax: draw(x, y, w, h)_\n_name: draw_\n_returns: void_\n_returns_description: _\n_parameters: float x, float y, float w, float h_\n_access: public_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nDraws the internal texture of the movie grabber class at the position (x,y) with the given width (w) and height (h). As the video grabber operates, it grabs pixel data and uploads it to it's internal texture (ie, on the GPU), unless you call setUseTexture(false), which disables the texture uploading. This draws that internal texture on screen.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###shared_ptr< ofBaseVideoGrabber > getGrabber()\n\n<!--\n_syntax: getGrabber()_\n_name: getGrabber_\n_returns: shared_ptr< ofBaseVideoGrabber >_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\ngetGrabber returns a pointer (ofPtr) to the internally running video grabber. Since the ofVideoGrabber object has different potential systems for grabbing (QuickTime, QTKit, DirectShow), this ptr gives you access to the underlying video grabber that's running inside of ofVideoGrabber. Note: use this only if you need low level access to an internal grabbing object, such as to call a specific function.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###const shared_ptr< ofBaseVideoGrabber > getGrabber()\n\n<!--\n_syntax: getGrabber()_\n_name: getGrabber_\n_returns: const shared_ptr< ofBaseVideoGrabber >_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###shared_ptr< GrabberType > getGrabber()\n\n<!--\n_syntax: getGrabber()_\n_name: getGrabber_\n_returns: shared_ptr< GrabberType >_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###const shared_ptr< GrabberType > getGrabber()\n\n<!--\n_syntax: getGrabber()_\n_name: getGrabber_\n_returns: const shared_ptr< GrabberType >_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float getHeight()\n\n<!--\n_syntax: getHeight()_\n_name: getHeight_\n_returns: float_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nReturns the height of the video grabber object. If you initialize the object at 320x240, it will return 240;\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###ofPixelFormat getPixelFormat()\n\n<!--\n_syntax: getPixelFormat()_\n_name: getPixelFormat_\n_returns: ofPixelFormat_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nReturns the height of the video grabber object. If you initialize the object at 320x240, it will return 240;\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###ofPixels & getPixels()\n\n<!--\n_syntax: getPixels()_\n_name: getPixels_\n_returns: ofPixels &_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nReturns the pointer to the array of pixels that represents the current frame of live video. the data is stored interleaved as RGB, and in an array which is the size: width*height*3. This function returns a pointer to an unsigned char array -- it's up to the user to deal with this memory correctly. Functions like getWidth() and getHeight() can help.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###const ofPixels & getPixels()\n\n<!--\n_syntax: getPixels()_\n_name: getPixels_\n_returns: const ofPixels &_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###ofTexture & getTexture()\n\n<!--\n_syntax: getTexture()_\n_name: getTexture_\n_returns: ofTexture &_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###const ofTexture & getTexture()\n\n<!--\n_syntax: getTexture()_\n_name: getTexture_\n_returns: const ofTexture &_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###int & getTexturePlanes()\n\n<!--\n_syntax: getTexturePlanes()_\n_name: getTexturePlanes_\n_returns: int &_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###const int & getTexturePlanes()\n\n<!--\n_syntax: getTexturePlanes()_\n_name: getTexturePlanes_\n_returns: const int &_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float getWidth()\n\n<!--\n_syntax: getWidth()_\n_name: getWidth_\n_returns: float_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nReturns the width of the video grabber object. If you initialize the object at 320x240, it will return 320.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool initGrabber(w, h)\n\n<!--\n_syntax: initGrabber(w, h)_\n_name: initGrabber_\n_returns: bool_\n_returns_description: _\n_parameters: int w, int h_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nInitializes either the default capture device or the capture device specified by setDeviceID. Attempts to setup capture at the width and height specified. If the capture dimensions are not available it will setup capture for the next closest dimensions available. It is good to check what the actual size is before you start processing the pixels.\n~~~~{.cpp}\n\nmyGrabber.setVerbose(true);\nmyGrabber.setDeviceID(1);\nmyGrabber.initGrabber(320,240);\nint grabW = myGrabber.getWidth();\nint grabH = myGrabber.getHeight();\nprintf(\"asked for 320 by 240 - actual size is %i by %i\", grabW, grabH);\n~~~~\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool isFrameNew()\n\n<!--\n_syntax: isFrameNew()_\n_name: isFrameNew_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis function can be called after calling ofImage::update() (or alternatively, ofImage::ofIdleGrabber()) to figure out if a frame is new, ie. if there is a new pixel data.  This is typically because your main frame rate might not be in sync with the video grabber, and you can skip processing on frames where there is no new data.    \n\n~~~~{.cpp}\n\nvoid testApp::update(){\n\n\tgrabber.update();  // call this once per update\n\tif (grabber.isFrameNew()){\n\t\t; // do computer vision / process the pixels\n\t}\n\n}\n\n~~~~\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool isInitialized()\n\n<!--\n_syntax: isInitialized()_\n_name: isInitialized_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nReturns a boolean if the video grabber is properly initialized.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool isUsingTexture()\n\n<!--\n_syntax: isUsingTexture()_\n_name: isUsingTexture_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###int listDevices()\n\n<!--\n_syntax: listDevices()_\n_name: listDevices_\n_returns: int_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nPrints to the console a list of available capture devices with the device ID of each device. The device ID can then be used with setDeviceID() to specify a specific device to capture from.  This is especially useful if you have multiple devices, or want to see what kind of cameras openframeworks sees.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n### ofVideoGrabber()\n\n<!--\n_syntax: ofVideoGrabber()_\n_name: ofVideoGrabber_\n_returns: _\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: False_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nInitializes the video grabber. This function doesn't really do any real allocation, which happens in ofVideoGrabber::initGrabber(). In openframeworks we typically use empty constructors so that objects can be defined in h files, ie, you don't need to do dynamic allocation or use pointers as much in your code.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void resetAnchor()\n\n<!--\n_syntax: resetAnchor()_\n_name: resetAnchor_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: True_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis removes any anchor positioning, meaning that the ofVideoGrabber will be draw with the upper left hand corner at the point passed into draw().\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setAnchorPercent(xPct, yPct)\n\n<!--\n_syntax: setAnchorPercent(xPct, yPct)_\n_name: setAnchorPercent_\n_returns: void_\n_returns_description: _\n_parameters: float xPct, float yPct_\n_access: public_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: True_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nAdjusts ofVideoGrabbers anchor for more drawing control. See ofImage::setAnchorPercent() for info.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setAnchorPoint(x, y)\n\n<!--\n_syntax: setAnchorPoint(x, y)_\n_name: setAnchorPoint_\n_returns: void_\n_returns_description: _\n_parameters: float x, float y_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nAdjusts ofVideoGrabbers anchor for more drawing control. See ofImage::setAnchorPoint(x,y) for info.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setDesiredFrameRate(framerate)\n\n<!--\n_syntax: setDesiredFrameRate(framerate)_\n_name: setDesiredFrameRate_\n_returns: void_\n_returns_description: _\n_parameters: int framerate_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nSet's the desired frame rate of the grabber. This should be called before initGrabber(), which will try to initialize at the desired frame rate. Not all frame rates will be supported, but this at least gives you some abilitity to try grab at different rates.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setDeviceID(_deviceID)\n\n<!--\n_syntax: setDeviceID(_deviceID)_\n_name: setDeviceID_\n_returns: void_\n_returns_description: _\n_parameters: int _deviceID_\n_access: public_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nChoose to capture from a specific capture device specified by _deviceID. Use listDevices() to see a list of available capture devices and their device IDs. This should be called before initGrabber(), which will use this info to choose the device you want.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setGrabber(newGrabber)\n\n<!--\n_syntax: setGrabber(newGrabber)_\n_name: setGrabber_\n_returns: void_\n_returns_description: _\n_parameters: shared_ptr< ofBaseVideoGrabber > newGrabber_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nThis function, similar to getGrabber, allows for low level access to the internal grabber object. This is useful if you want to adjust the internal grabber that ofVideoGrabber is using.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool setPixelFormat(pixelFormat)\n\n<!--\n_syntax: setPixelFormat(pixelFormat)_\n_name: setPixelFormat_\n_returns: bool_\n_returns_description: _\n_parameters: ofPixelFormat pixelFormat_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nSome video grabbers allow you to adjust the pixel format, which might help for optimization. At the moment, this seems to only apply to the Linux video grabber (GST). For all other grabbers, the only format accepted is OF_PIXELS_RGB.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setUseTexture(bUse)\n\n<!--\n_syntax: setUseTexture(bUse)_\n_name: setUseTexture_\n_returns: void_\n_returns_description: _\n_parameters: bool bUse_\n_access: public_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nSet the usage of texture inside this object. Typically, you will want to draw the movie grabber on screen, and so it will be necessary to use a texture, but there may be cases where it helps to not use a texture in order to save memory or for better performance. To disable the internal use of the texture, you can initialize the sequence grabber like this:\n~~~~{.cpp}\n\nmyGrabber.setUseTexture(false);\nmyGrabber.initGrabber(320,240);\n~~~~\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setVerbose(bTalkToMe)\n\n<!--\n_syntax: setVerbose(bTalkToMe)_\n_name: setVerbose_\n_returns: void_\n_returns_description: _\n_parameters: bool bTalkToMe_\n_access: public_\n_version_started: 006_\n_version_deprecated: 0.06_\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nSets the verbosity - this can be useful for debugging the video grabber interface. you can set the verbosity and then try initGrabber();\n\nFrom 0.06 this method has no effect. Use ofSetLogLevel(OF_LOG_VERBOSE) to enable verbose messages.\n~~~~{.cpp}\n\nmyGrabber.setVerbose(true);\nmyGrabber.initGrabber(320,240);\n~~~~\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool setup(w, h)\n\n<!--\n_syntax: setup(w, h)_\n_name: setup_\n_returns: bool_\n_returns_description: _\n_parameters: int w, int h_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool setup(w, h, bTexture)\n\n<!--\n_syntax: setup(w, h, bTexture)_\n_name: setup_\n_returns: bool_\n_returns_description: _\n_parameters: int w, int h, bool bTexture_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void unbind()\n\n<!--\n_syntax: unbind()_\n_name: unbind_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void update()\n\n<!--\n_syntax: update()_\n_name: update_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nCalls grabframe function.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void videoSettings()\n\n<!--\n_syntax: videoSettings()_\n_name: videoSettings_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nLoads the video settings on screen. If your OpenGL application is full screen, this window might appear underneath the main window the first time you call this. Note: in QTKit grabbers (10.7+), this video settings panel is not available.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n### ~ofVideoGrabber()\n\n<!--\n_syntax: ~ofVideoGrabber()_\n_name: ~ofVideoGrabber_\n_returns: _\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: False_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nDestructor for the video grabber, will release any allocated memory. \n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n##Variables\n\n\n\n###bool bUseTexture\n\n<!--\n_name: bUseTexture_\n_type: bool_\n_access: protected_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: False_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###int desiredFramerate\n\n<!--\n_name: desiredFramerate_\n_type: int_\n_access: private_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###ofPtr grabber\n\n<!--\n_name: grabber_\n_type: ofPtr_\n_access: private_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###ofPixelFormat internalPixelFormat\n\n<!--\n_name: internalPixelFormat_\n_type: ofPixelFormat_\n_access: private_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###int requestedDeviceID\n\n<!--\n_name: requestedDeviceID_\n_type: int_\n_access: private_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: False_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###ofTexture tex\n\n<!--\n_name: tex_\n_type: ofTexture_\n_access: protected_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: False_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n","type":"page"}}],"fetch":[]}