{"data":[{"page":{"entry":{"name":"ofTexture","filename":"ofTexture.markdown","absolute":"/Users/Gilbert/Code/openFrameworks/ofSite/documentation/gl/ofTexture.markdown","path":"/documentation/gl/ofTexture","route":"/documentation/gl/ofTexture.markdown","dir":"../ofSite/documentation/gl","ext":"markdown","type":"page","id":1971,"parent":1942,"breadcrumbs":[1942,1718],"siblings":[],"translations":{}},"description":{"short":"<p>A wrapper class for an OpenGL texture.</p>\n","full":"<p>ofTexture is used to create textures that live on your graphics card from bitmap data that can then be used to fill other drawn objects, like a bitmap fill on a rectangle. When you draw an ofImage, you're actually just drawing a rectangle of points and then using an ofTexture to fill the space between those points. At it's core, ofTexture is a wrapper for OpenGL textures. It allows use of non-power of 2 textures in opengl, and to upload and draw graphical data.</p>\n<h1></h1>\n"},"config":{"visible":"True","advanced":"False","istemplated":"False","extends":"ofBaseDraws"},"methods":[{"syntax":"allocate(&pix)","name":"allocate","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofPixels <span class=\"token operator\">&amp;</span>pix","access":"public","version_started":"0071","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Allocate texture using an ofPixels instance.</p>\n<p>Pixel type and OpenGL format are determined from pixel settings.</p>\n<p><strong>Parameters:</strong></p>\n<p>pix Reference to ofPixels instance.</p>\n","desc":""},{"syntax":"allocate(&pix)","name":"allocate","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofShortPixels <span class=\"token operator\">&amp;</span>pix","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Allocate texture using an ofShortPixels instance.</p>\n<p>Same as void allocate(const ofPixels&amp; pix), except using ofShortPixels.</p>\n<p><strong>See also</strong>: allocate(const ofPixels&amp; pix)</p>\n<p><strong>Parameters:</strong></p>\n<p>pix Reference to ofShortPixels instance.</p>\n","desc":""},{"syntax":"allocate(&pix)","name":"allocate","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofFloatPixels <span class=\"token operator\">&amp;</span>pix","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Allocate texture using an ofFloatPixels instance.</p>\n<p>Same as void allocate(const ofPixels&amp; pix), except using ofFloatPixels.</p>\n<p><strong>See also</strong>: allocate(const ofPixels&amp; pix)</p>\n<p><strong>Parameters:</strong></p>\n<p>pix Reference to ofFloatPixels instance.</p>\n","desc":""},{"syntax":"allocate(&pix, bUseARBExtension)","name":"allocate","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofPixels <span class=\"token operator\">&amp;</span>pix<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> bUseARBExtension","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Allocate texture using an ofPixels instance and type.</p>\n<p>This lets you overide the default OF texture type in case you need a\nsquare GL_TEXTURE_2D texture.</p>\n<p><strong>Warning</strong>: ARB textures are not available in OpenGL ES.</p>\n<p><strong>See also</strong>: ofEnableArbTex()</p>\n<p><strong>See also</strong>: allocate(const ofPixels&amp; pix)</p>\n<p><strong>Parameters:</strong></p>\n<p>pix Reference to ofPixels instance.</p>\n<p>bUseARBExtension Set to true to use rectangular textures.</p>\n","desc":""},{"syntax":"allocate(&pix, bUseARBExtension)","name":"allocate","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofShortPixels <span class=\"token operator\">&amp;</span>pix<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> bUseARBExtension","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Allocate texture using an ofShortPixels instance and type.</p>\n<p>Same as void void allocate(const ofPixels&amp; pix), except using ofShortPixels.</p>\n<p><strong>See also</strong>: allocate(const ofShortPixels&amp; pix)</p>\n<p><strong>Parameters:</strong></p>\n<p>pix Reference to ofShortPixels instance.</p>\n<p>bUseARBExtension Set to true to use rectangular textures.</p>\n","desc":""},{"syntax":"allocate(&pix, bUseARBExtension)","name":"allocate","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofFloatPixels <span class=\"token operator\">&amp;</span>pix<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> bUseARBExtension","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Allocate texture using an ofShortPixels instance and type.</p>\n<p>Same as void void allocate(const ofPixels&amp; pix), except using ofShortPixels.</p>\n<p><strong>See also</strong>: allocate(const ofFloatPixels&amp; pix)</p>\n<p><strong>Parameters:</strong></p>\n<p>pix Reference to ofFloatPixels instance.</p>\n<p>bUseARBExtension Set to true to use rectangular textures.</p>\n","desc":""},{"syntax":"allocate(&textureData)","name":"allocate","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofTextureData <span class=\"token operator\">&amp;</span>textureData","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Allocate the texture using the given settings.</p>\n<p>This is useful if you need manual control over loading a number of\ntextures with the same settings. Make sure to set the texture data\nparameters first.</p>\n<p><strong>Parameters:</strong></p>\n<p>textureData The settings to use when allocating the ofTexture.</p>\n","desc":""},{"syntax":"allocate(&textureData, glFormat, pixelType)","name":"allocate","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofTextureData <span class=\"token operator\">&amp;</span>textureData<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> glFormat<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> pixelType","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Allocate the texture using the given settings and custom format.</p>\n<p><strong>Parameters:</strong></p>\n<p>textureData The settings to use when allocating the ofTexture.</p>\n<p>glFormat GL texture format: GL_RGBA, GL_LUMINANCE, etc.</p>\n<p>pixelType GL pixel type: GL_UNSIGNED_BYTE, GL_FLOAT, etc.</p>\n","desc":""},{"syntax":"allocate(w, h, glInternalFormat)","name":"allocate","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">int</span> w<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> h<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> glInternalFormat","access":"public","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Allocate texture of a given size and format.</p>\n<p>The width (w) and height (h) do not necessarily need to be powers of 2,\nbut they do need to be large enough to contain the data you will upload\nto the texture.</p>\n<p>The internal data type <code>glFormat</code> describes how OpenGL will store this\ntexture internally. For example, if you want a grayscale texture, you\ncan use <code>GL_LUMINANCE</code>. You can upload what ever type of data you want\n(using <code><span class=\"token function\">loadData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code>) but internally, opengl will store the information\nas grayscale. Other types include: <code>GL_RGB</code>, <code>GL_RGBA</code>.</p>\n<p>This method applies the currently set OF texture type and defaults to\nARB rectangular textures if they are supported. (They are not supported\non OpenGL ES).</p>\n<p><strong>Parameters:</strong></p>\n<p>w Desired width in pixels.</p>\n<p>h Desired height in pixels.</p>\n<p>glInternalFormat OpenGL internal data format: <code>GL_RGBA</code>, <code>GL_LUMINANCE</code>, etc.</p>\n","desc":"<p>This is the call to allocate opengl texture. The width (w) and height (h) do not necessarily need to be powers of 2, but they do need to be large enough to contain the data you will upload to the texture.  The internal data type describes how opengl will store this texture internally. For example, if you want a grayscale texture, you can use &quot;GL_LUMINANCE&quot;. You can uplaod what ever type of data you want (using loadData()) but internally, opengl will store the information as grayscale. Other types include: GL_RGB, GL_RGBA.\nYou need to allocate the texture before drawing it or loading data into it.\nuses the currently set OF texture type - default ARB texture</p>\n"},{"syntax":"allocate(w, h, glInternalFormat, bUseARBExtension)","name":"allocate","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">int</span> w<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> h<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> glInternalFormat<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> bUseARBExtension","access":"public","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Allocate texture of a given size and format. Specify texture type.</p>\n<p>This allows to enable the ARBE extension for this texture.\nThis will overide the default OF texture type, in case you need a\nsquare texture (<code>GL_TEXTURE_2D</code>).</p>\n<p><strong>Warning</strong>: ARB textures are not available in OpenGL ES.</p>\n<p><strong>See also</strong>: ofEnableArbTex()</p>\n<p><strong>See also</strong>: allocate(int w, int h, int glInternalFormat)</p>\n<p><strong>Parameters:</strong></p>\n<p>w Desired width in pixels.</p>\n<p>h Desired height in pixels.</p>\n<p>glInternalFormat The internal openGL format.</p>\n<p>bUseARBExtension Set to true to use rectangular textures.</p>\n","desc":"<p>See previous allocate for knowing the behaviour of this function. The parameter bUseARBEExtension allow the user to enable the ARBE extension for this texture.\nYou need to allocate the texture before drawing it or loading data into it, lets you overide the default OF texture type</p>\n"},{"syntax":"allocate(w, h, glInternalFormat, bUseARBExtension, glFormat, pixelType)","name":"allocate","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">int</span> w<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> h<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> glInternalFormat<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> bUseARBExtension<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> glFormat<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> pixelType","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Allocate texture of a given size, format, &amp; type.</p>\n<p><strong>See also</strong>: allocate(int w, int h, int glInternalFormat)</p>\n<p><strong>Parameters:</strong></p>\n<p>w Desired width in pixels.</p>\n<p>h Desired height in pixels.</p>\n<p>glInternalFormat OpenGL data format: <code>GL_RGBA</code>, <code>GL_LUMINANCE</code>, etc.</p>\n<p>bUseARBExtension Set to true to use rectangular textures.</p>\n<p>glFormat The OpenGL format.</p>\n<p>pixelType OpenGL pixel type: <code>GL_UNSIGNED_BYTE</code>, <code>GL_FLOAT</code>, etc.</p>\n","desc":""},{"syntax":"allocate(w, h, glInternalFormat, glFormat, pixelType)","name":"allocate","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">int</span> w<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> h<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> glInternalFormat<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> glFormat<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> pixelType","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Allocate texture of a given size and format.</p>\n<p><strong>See also</strong>: allocate(int w, int h, int glInternalFormat)</p>\n<p><strong>Parameters:</strong></p>\n<p>w Desired width in pixels.</p>\n<p>h Desired height in pixels.</p>\n<p>glInternalFormat The internal openGL format.</p>\n<p>glFormat The openGL format.</p>\n<p>pixelType GL pixel type: GL_UNSIGNED_BYTE, GL_FLOAT, etc.</p>\n","desc":""},{"syntax":"allocateAsBufferTexture(&buffer, glInternalFormat)","name":"allocateAsBufferTexture","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofBufferObject <span class=\"token operator\">&amp;</span>buffer<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> glInternalFormat","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Allocate texture as a Buffer Texture.</p>\n<p>Uses a GPU buffer as data for the texture instead of pixels in RAM\nAllows to use texture buffer objects (TBO) which make it easier to send big\namounts of data to a shader as a uniform.</p>\n<p>Buffer textures are 1D textures, and may only be sampled using texelFetch\nin GLSL.</p>\n<p>See textureBufferInstanceExample and https://www.opengl.org/wiki/Buffer_Texture</p>\n<p><strong>See also</strong>: allocate(const ofBufferObject &amp; buffer, int glInternalFormat)</p>\n<p><strong>Parameters:</strong></p>\n<p>buffer Reference to ofBufferObject instance.</p>\n<p>glInternalFormat Internal pixel format of the data.</p>\n","desc":""},{"syntax":"bind(textureLocation = 0)","name":"bind","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">int</span> textureLocation<span class=\"token operator\">=</span><span class=\"token number\">0</span>","access":"public","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Bind the texture.</p>\n<p>For advanced users who need to manually manage texture drawing without\ncalling ofTexture::draw.</p>\n<p><strong>See also</strong>: http://www.opengl.org/sdk/docs/man4/html/glBindTexture.xhtml</p>\n","desc":"<p>This is for the advanced user who wants to draw textures in their own way. Each set of vertices that you draw after calling bind() will be textured using this texture.</p>\n"},{"syntax":"bindAsImage(unit, access, level = 0, layered, layer = 0)","name":"bindAsImage","returns":"void","returns_description":null,"parameters":"GLuint unit<span class=\"token punctuation\">,</span> GLenum access<span class=\"token punctuation\">,</span> GLint level<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> GLboolean layered<span class=\"token punctuation\">,</span> GLint layer<span class=\"token operator\">=</span><span class=\"token number\">0</span>","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Calls glBindImageTexture on the texture</p>\n<p>Binds the texture as an read or write image, only available since OpenGL 4.2</p>\n<p><strong>Warning</strong>: This is not available in OpenGLES</p>\n<p><strong>See also</strong>: http://www.opengl.org/wiki/GLAPI/glBindImageTexture</p>\n","desc":""},{"syntax":"clear()","name":"clear","returns":"void","returns_description":null,"parameters":null,"access":"public","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Clears the texture.</p>\n<p>Clears / frees the texture memory, if something was already allocated.\nUseful if you need to control the memory on the graphics card.</p>\n<p>The internal GL texture ID is only released if this is the last texture\nusing it.</p>\n","desc":"<p>clears / frees the texture memory, if something was already allocated. useful if you need to control the memory on the graphics card.\nClears all the data from the texture</p>\n"},{"syntax":"copyTo(&buffer)","name":"copyTo","returns":"void","returns_description":null,"parameters":"ofBufferObject <span class=\"token operator\">&amp;</span>buffer","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Copy the texture to an ofBufferObject.</p>\n<p><strong>Parameters:</strong></p>\n<p>buffer the target buffer to copy to.</p>\n","desc":""},{"syntax":"disableAlphaMask()","name":"disableAlphaMask","returns":"void","returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Disable the alpha mask.</p>\n","desc":""},{"syntax":"disableMipmap()","name":"disableMipmap","returns":"void","returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Sets flag disallowing texture to auto-generate mipmap.</p>\n<p>By default, this will set your minFilter to GL_LINEAR_MIPMAP_LINEAR.\nIf you want to change your minFilter later use setTextureMinMagFilter()</p>\n<pre><code>If you want to generate a mipmap later<span class=\"token punctuation\">,</span> <span class=\"token operator\">or</span> at a specific\n</code></pre>\n<p>point in your code, use ofTexture::generateMipmap() instead.</p>\n<p><strong>See also</strong>: generateMipmap()</p>\n<p><strong>See also</strong>: enableMipmap()</p>\n<p><strong>See also</strong>: setTextureMinMagFilter()</p>\n","desc":""},{"syntax":"disableTextureMatrix()","name":"disableTextureMatrix","returns":"void","returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Disable the texture matrix.\nDisable the texture matrix.</p>\n","desc":""},{"syntax":"disableTextureTarget(textureLocation)","name":"disableTextureTarget","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">int</span> textureLocation","access":"protected","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Disable a texture target.</p>\n<p><strong>Parameters:</strong></p>\n<p>textureLocation the OpenGL texture ID to enable as a target.</p>\n","desc":""},{"syntax":"draw(&p1, &p2, &p3, &p4)","name":"draw","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> glm<span class=\"token operator\">::</span>vec3 <span class=\"token operator\">&amp;</span>p1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> glm<span class=\"token operator\">::</span>vec3 <span class=\"token operator\">&amp;</span>p2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> glm<span class=\"token operator\">::</span>vec3 <span class=\"token operator\">&amp;</span>p3<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> glm<span class=\"token operator\">::</span>vec3 <span class=\"token operator\">&amp;</span>p4","access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Draws the texture at 4 points passed in as if you created 4 glVertices.</p>\n<p><strong>Parameters:</strong></p>\n<p>p1 Upper left position on the x axis.</p>\n<p>p2 Upper left position on the y axis.</p>\n<p>p3 Lower right position on the x axis.</p>\n<p>p4 Lower right position on the y axis.</p>\n","desc":""},{"syntax":"draw(&pos)","name":"draw","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> glm<span class=\"token operator\">::</span>vec3 <span class=\"token operator\">&amp;</span>pos","access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"draw(&pos, w, h)","name":"draw","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> glm<span class=\"token operator\">::</span>vec3 <span class=\"token operator\">&amp;</span>pos<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> w<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> h","access":"public","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Draws the texture at 4 points passed in as if you created 4 glVertices.</p>\n"},{"syntax":"draw(x, y)","name":"draw","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> y","access":"public","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>\\section Drawing</p>\n","desc":"<p>Draws the texture at a given point (x,y), using the textures true width and height.\nDraws the texture at the point passed in.</p>\n"},{"syntax":"draw(x, y, w, h)","name":"draw","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> y<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> w<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> h","access":"public","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>draws the texture at a given point (x,y), with a given width (w) and height (h).\nDraws the texture at the x, y and w, h.</p>\n"},{"syntax":"draw(x, y, z)","name":"draw","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> y<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> z","access":"public","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":"<p>Draws the texture at the point passed in in 3D space.</p>\n"},{"syntax":"draw(x, y, z, w, h)","name":"draw","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> y<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> z<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> w<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> h","access":"public","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Draw the texture at a given size witdh and depth.</p>\n<p><strong>Parameters:</strong></p>\n<p>x Draw position on the x axis.</p>\n<p>y Draw position on the y axis.</p>\n<p>z Draw position on the z axis.</p>\n<p>w Draw width.</p>\n<p>h Draw height.</p>\n","desc":"<p>Draws the texture at the x, y, z in 3D space with the width and height at w,h.</p>\n"},{"syntax":"drawSubsection(&drawBounds, &subsectionBounds)","name":"drawSubsection","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofRectangle <span class=\"token operator\">&amp;</span>drawBounds<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> ofRectangle <span class=\"token operator\">&amp;</span>subsectionBounds","access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Draw a subsection of the texture with an offset.</p>\n<p><strong>See also</strong>: drawSubsection(ofRectangle&amp; drawBounds, ofRectangle&amp; subsectionBounds)</p>\n<p><strong>Parameters:</strong></p>\n<p>drawBounds Draw position and dimensions.</p>\n<p>subsectionBounds Subsection position and dimensions within the texture.</p>\n","desc":""},{"syntax":"drawSubsection(x, y, w, h, sx, sy)","name":"drawSubsection","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> y<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> w<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> h<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> sx<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> sy","access":"public","version_started":"0071","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Draw a subsection of the texture.</p>\n<p>Like ofRect() depend on the current <code>OF_RECT_MODE</code>:</p>\n<ul>\n<li><code>OF_RECT_MODE_CORNER</code>: drawn with the upper left corner = (x,y)</li>\n<li><code>OF_RECT_MODE_CENTER</code>: drawn centered on (x,y)</li>\n</ul>\n<p><strong>See also</strong>: ofSetRectMode()</p>\n<p><strong>Parameters:</strong></p>\n<p>x Draw position on the x axis.</p>\n<p>y Draw position on the y axis.</p>\n<p>w Draw width.</p>\n<p>h Draw height.</p>\n<p>sx Subsection x axis offset within the texture.</p>\n<p>sy Subsection y axis offset within the texture.</p>\n","desc":""},{"syntax":"drawSubsection(x, y, w, h, sx, sy, sw, sh)","name":"drawSubsection","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> y<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> w<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> h<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> sx<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> sy<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> sw<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> sh","access":"public","version_started":"0071","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Draw a subsection of the texture with an offset.</p>\n<p><strong>See also</strong>: drawSubsection(float x, float y, float w, float h, float sx, float sy)</p>\n<p><strong>Parameters:</strong></p>\n<p>x Draw position on the x axis.</p>\n<p>y Draw position on the y axis.</p>\n<p>w Draw width.</p>\n<p>h Draw height.</p>\n<p>sx Subsection x axis offset within the texture.</p>\n<p>sy Subsection y axis offset within the texture.</p>\n<p>sw Subsection width within the texture.</p>\n<p>sh Subsection height within the texture.</p>\n","desc":""},{"syntax":"drawSubsection(x, y, z, w, h, sx, sy)","name":"drawSubsection","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> y<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> z<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> w<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> h<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> sx<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> sy","access":"public","version_started":"0071","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Draw a subsection of the texture with depth.</p>\n<p><strong>See also</strong>: drawSubsection(float x, float y, float w, float h, float sx, float sy)</p>\n<p><strong>Parameters:</strong></p>\n<p>x Draw position on the x axis.</p>\n<p>y Draw position on the y axis.</p>\n<p>z Draw position on the z axis.</p>\n<p>w Draw width.</p>\n<p>h Draw height.</p>\n<p>sx Subsection x axis offset within the texture.</p>\n<p>sy Subsection y axis offset within the texture.</p>\n","desc":""},{"syntax":"drawSubsection(x, y, z, w, h, sx, sy, sw, sh)","name":"drawSubsection","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> y<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> z<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> w<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> h<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> sx<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> sy<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> sw<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> sh","access":"public","version_started":"0071","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Draw a subsection of the texture with an offset and depth.</p>\n<p><strong>See also</strong>: drawSubsection(float x, float y, float w, float h, float sx, float sy)</p>\n<p><strong>Parameters:</strong></p>\n<p>x Draw position on the x axis.</p>\n<p>y Draw position on the y axis.</p>\n<p>z Draw position on the z axis.</p>\n<p>w Draw width.</p>\n<p>h Draw height.</p>\n<p>sx Subsection x axis offset within the texture.</p>\n<p>sy Subsection y axis offset within the texture.</p>\n<p>sw Subsection width within the texture.</p>\n<p>sh Subsection height within the texture.</p>\n","desc":""},{"syntax":"enableMipmap()","name":"enableMipmap","returns":"void","returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>\\section Mipmapping\nSets flag allowing texture to auto-generate a mipmap.</p>\n<p>By default, this will set your minFilter to GL_LINEAR_MIPMAP_LINEAR.\nIf you want to change your minFilter later use setTextureMinMagFilter()</p>\n<pre><code>If you want to generate a mipmap later<span class=\"token punctuation\">,</span> <span class=\"token operator\">or</span> at a specific\n</code></pre>\n<p>point in your code, use generateMipmap() instead.</p>\n<p><strong>See also</strong>: generateMipmap()</p>\n<p><strong>See also</strong>: disableMipmap()</p>\n<p><strong>See also</strong>: setTextureMinMagFilter()</p>\n","desc":""},{"syntax":"enableTextureTarget(textureLocation)","name":"enableTextureTarget","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">int</span> textureLocation","access":"protected","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Enable a texture target.</p>\n<p><strong>Parameters:</strong></p>\n<p>textureLocation the OpenGL texture ID to enable as a target.</p>\n","desc":""},{"syntax":"generateMipmap()","name":"generateMipmap","returns":"void","returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Generate mipmap for the current texture.</p>\n<p><strong>Warning</strong>: Only GL_TEXTURE_RECTANGLE - which is the default openFrameworks\ntexture target - does <em>not</em> support mipmaps, so make sure to call\nofDisableArbTex() before loading texture\ndata for a texture you want to generate mipmaps for.</p>\n<p><strong>See also</strong>: ofEnableArbTex()</p>\n<p><strong>See also</strong>: ofDisableArbTex()</p>\n","desc":""},{"syntax":"getAlphaMask()","name":"getAlphaMask","returns":"const ofTexture *","returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"getCoordFromPercent(xPts, yPts)","name":"getCoordFromPercent","returns":"glm::vec2","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> xPts<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> yPts","access":"public","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Helper to convert display coordinate to texture coordinate.</p>\n<p><strong>Parameters:</strong></p>\n<p>xPts Horizontal position in a normalized percentage (0 - 1).</p>\n<p>yPts Vertical position in a normalized percentage (0 - 1).</p>\n<p><strong>Returns</strong>: Texture coordinate or zero if texture is not allocated.</p>\n","desc":""},{"syntax":"getCoordFromPoint(xPos, yPos)","name":"getCoordFromPoint","returns":"glm::vec2","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> xPos<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> yPos","access":"public","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Helper to convert display coordinate to texture coordinate.</p>\n<p><strong>Parameters:</strong></p>\n<p>xPos Horizontal position in pixels.</p>\n<p>yPos Vertical position in pixels.</p>\n<p><strong>Returns</strong>: Texture coordinate or zero if texture is not allocated.</p>\n","desc":"<p>these are helpers to allow you to get points for the texture ala &quot;glTexCoordf&quot; but are texture type independent. use them for immediate or non immediate mode</p>\n"},{"syntax":"getHeight()","name":"getHeight","returns":"float","returns_description":null,"parameters":null,"access":"public","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>\\section Size and Coordinates\nDisplay height of texture.</p>\n<p>Return value is pixel size (default) or normalized (0 - 1) if ofEnableNormalizedTextures() is set to true.</p>\n<p><strong>See also</strong>: ofEnabledNormalizedTextures()</p>\n<p><strong>Returns</strong>: Display height of texture in pixels.</p>\n","desc":"<p>Returns the height of the texture. This will be in pixels unless you've set your application to use normalized coordinates.</p>\n"},{"syntax":"getMeshForSubsection(x, y, z, w, h, sx, sy, sw, sh, vflipped, rectMode)","name":"getMeshForSubsection","returns":"ofMesh","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> y<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> z<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> w<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> h<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> sx<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> sy<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> sw<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> sh<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> vflipped<span class=\"token punctuation\">,</span> ofRectMode rectMode","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Get a mesh that has the texture coordinates set.</p>\n<p><strong>See also</strong>: drawSubsection(float x, float y, float w, float h, float sx, float sy)</p>\n<p><strong>Parameters:</strong></p>\n<p>x Draw position on the x axis.</p>\n<p>y Draw position on the y axis.</p>\n<p>z Draw position on the z axis.</p>\n<p>w Draw width.</p>\n<p>h Draw height.</p>\n<p>sx Subsection x axis offset within the texture.</p>\n<p>sy Subsection y axis offset within the texture.</p>\n<p>sw Subsection width within the texture.</p>\n<p>sh Subsection height within the texture.</p>\n<p>vflipped Takes into account the flipped state in OF.</p>\n<p>rectMode rectMode Taking x,y as the center or the top left corner.</p>\n","desc":""},{"syntax":"getQuad(&p1, &p2, &p3, &p4)","name":"getQuad","returns":"ofMesh","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> glm<span class=\"token operator\">::</span>vec3 <span class=\"token operator\">&amp;</span>p1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> glm<span class=\"token operator\">::</span>vec3 <span class=\"token operator\">&amp;</span>p2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> glm<span class=\"token operator\">::</span>vec3 <span class=\"token operator\">&amp;</span>p3<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> glm<span class=\"token operator\">::</span>vec3 <span class=\"token operator\">&amp;</span>p4","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"getTextureData()","name":"getTextureData","returns":"ofTextureData &","returns_description":null,"parameters":null,"access":"public","version_started":"0.8.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>\\section Texture Data\nInternal texture data access.</p>\n<p>This returns the internal texture data for this texture, for instance,\nits textureID, type of texture, whether it's been allocated and other\ndata about the state of the texture.</p>\n<p><strong>Returns</strong>: a reference to the internal texture data struct.</p>\n","desc":""},{"syntax":"getTextureData()","name":"getTextureData","returns":"const ofTextureData &","returns_description":null,"parameters":null,"access":"public","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Const version of getTextureData().</p>\n<p><strong>See also</strong>: ofTextureData::getTextureData()</p>\n","desc":"<p>This returns the internal texture data for this texture, for instance, its textureID, type of texture, whether it's been allocated, and other data about the state of the texture.</p>\n"},{"syntax":"getTextureMatrix()","name":"getTextureMatrix","returns":"const glm::mat4 &","returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"getWidth()","name":"getWidth","returns":"float","returns_description":null,"parameters":null,"access":"public","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Display width of texture.</p>\n<p>Return value is pixel size (default) or normalized (0 - 1) if ofEnableNormalizedTextures() is set to true.</p>\n<p><strong>See also</strong>: ofEnabledNormalizedTextures()</p>\n<p><strong>Returns</strong>: Display width of texture in pixels.</p>\n","desc":"<p>Returns the width of the texture. This will be in pixels unless you've set your application to use normalized coordinates.</p>\n"},{"syntax":"hasMipmap()","name":"hasMipmap","returns":"bool","returns_description":null,"parameters":null,"access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Find out if a mipmap has been generated for the current texture.</p>\n<p><strong>See also</strong>: generateMipmap()</p>\n<p><strong>See also</strong>: enableMipmap()</p>\n","desc":""},{"syntax":"isAllocated()","name":"isAllocated","returns":"bool","returns_description":null,"parameters":null,"access":"public","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Determine whether the texture has been allocated.</p>\n<p>This lets you check if a texture is safe to draw.  The texture can both\nbe allocated by using <code><span class=\"token function\">allocate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code> or loading it with data <code><span class=\"token function\">loadData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code>.</p>\n<p><strong>Returns</strong>: true if the texture has been allocated.</p>\n","desc":"<p>Get whether the texture has been allocated.\nofTextureData getTextureData() ###\n// reference to the actual textureData inside the smart pointer\n// for backwards compatibility\nofTextureData texData ###\nfloat getHeight() ###\nfloat getWidth() ###</p>\n"},{"syntax":"isUsingTextureMatrix()","name":"isUsingTextureMatrix","returns":"bool","returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"loadData(&buffer, glFormat, glType)","name":"loadData","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofBufferObject <span class=\"token operator\">&amp;</span>buffer<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> glFormat<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> glType","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Load pixels from an ofBufferObject</p>\n<p>This is different to allocate(ofBufferObject,internal). That\ncreates a texture which data lives in GL buffer while this\ncopies the data from the buffer to the texture.</p>\n<p>This is usually used to upload data to be shown asynchronously\nby using a buffer object binded as a PBO</p>\n<p><strong>Parameters:</strong></p>\n<p>buffer The buffer to load.</p>\n<p>glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.</p>\n<p>glType the GL type to load.</p>\n","desc":""},{"syntax":"loadData(&pix)","name":"loadData","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofPixels <span class=\"token operator\">&amp;</span>pix","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Load pixels from an ofPixels instance.</p>\n<p><strong>Parameters:</strong></p>\n<p>pix Reference to ofPixels instance.</p>\n","desc":""},{"syntax":"loadData(&pix)","name":"loadData","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofShortPixels <span class=\"token operator\">&amp;</span>pix","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Load pixels from an ofShortPixels instance.</p>\n<p>Same as loadData(ofPixels &amp;) but for ofShortPixels.</p>\n<p><strong>See also</strong>: loadData(const ofPixels &amp; pix)</p>\n<p><strong>Parameters:</strong></p>\n<p>pix Reference to ofShortPixels instance.</p>\n","desc":""},{"syntax":"loadData(&pix)","name":"loadData","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofFloatPixels <span class=\"token operator\">&amp;</span>pix","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Load pixels from an ofFloatPixels instance.</p>\n<p>Same as loadData(ofPixels &amp;) but for ofFloatPixels.</p>\n<p><strong>See also</strong>: loadData(const ofPixels &amp; pix)</p>\n<p><strong>Parameters:</strong></p>\n<p>pix Reference to ofFloatPixels instance.</p>\n","desc":""},{"syntax":"loadData(&pix, glFormat)","name":"loadData","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofPixels <span class=\"token operator\">&amp;</span>pix<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> glFormat","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Load pixels from an ofPixels instance and specify the format.</p>\n<p>glFormat can be different to the internal format of the texture on each\nload, ie. we can upload GL_BGRA pixels into a GL_RGBA texture, but the\nnumber of channels need to match according to the OpenGL standard.</p>\n<p><strong>Parameters:</strong></p>\n<p>pix Reference to ofPixels instance.</p>\n<p>glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.</p>\n","desc":""},{"syntax":"loadData(&pix, glFormat)","name":"loadData","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofShortPixels <span class=\"token operator\">&amp;</span>pix<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> glFormat","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Load pixels from an ofShortPixels instance &amp; specify the format.</p>\n<p><strong>See also</strong>: loadData(const ofPixels &amp; pix, int glFormat)</p>\n<p><strong>Parameters:</strong></p>\n<p>pix Reference to ofShortPixels instance.</p>\n<p>glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.</p>\n","desc":""},{"syntax":"loadData(&pix, glFormat)","name":"loadData","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofFloatPixels <span class=\"token operator\">&amp;</span>pix<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> glFormat","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Load pixels from an ofFloatPixels instance and specify the format.</p>\n<p><strong>See also</strong>: loadData(const ofPixels &amp; pix, int glFormat)</p>\n<p><strong>Parameters:</strong></p>\n<p>pix Reference to ofFloatPixels instance.</p>\n<p>glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.</p>\n","desc":""},{"syntax":"loadData(*data, w, h, glFormat)","name":"loadData","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> uint16_t <span class=\"token operator\">*</span>data<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> w<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> h<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> glFormat","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Load short (2 byte) pixel data.</p>\n<p><strong>See also</strong>: loadData(const unsigned char* const data, int w, int h, int glFormat)</p>\n<p><strong>Parameters:</strong></p>\n<p>data Pointer to byte pixel data. Must not be nullptr.</p>\n<p>w Pixel data width.</p>\n<p>h Pixel data height.</p>\n<p>glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.</p>\n","desc":""},{"syntax":"loadData(*data, w, h, glFormat)","name":"loadData","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> uint32_t <span class=\"token operator\">*</span>data<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> w<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> h<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> glFormat","access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"loadData(*data, w, h, glFormat)","name":"loadData","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> int8_t <span class=\"token operator\">*</span>data<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> w<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> h<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> glFormat","access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"loadData(*data, w, h, glFormat)","name":"loadData","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> int16_t <span class=\"token operator\">*</span>data<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> w<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> h<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> glFormat","access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"loadData(*data, w, h, glFormat)","name":"loadData","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> int32_t <span class=\"token operator\">*</span>data<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> w<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> h<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> glFormat","access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"loadData(*data, w, h, glFormat)","name":"loadData","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> <span class=\"token keyword\">float</span> <span class=\"token operator\">*</span>data<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> w<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> h<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> glFormat","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Load float pixel data.</p>\n<p><strong>See also</strong>: loadData(const unsigned char* const data, int w, int h, int glFormat)</p>\n<p><strong>Parameters:</strong></p>\n<p>data Pointer to byte pixel data. Must not be nullptr.</p>\n<p>w Pixel data width.</p>\n<p>h Pixel data height.</p>\n<p>glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.</p>\n","desc":""},{"syntax":"loadData(*data, w, h, glFormat, glType)","name":"loadData","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>data<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> w<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> h<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> glFormat<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> glType","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Load byte pixel data.</p>\n<p>glFormat can be different to the internal format of the texture on each\nload, i.e. we can upload GL_BGRA pixels into a GL_RGBA texture but the\nnumber of channels need to match according to the OpenGL standard.</p>\n<p><strong>Parameters:</strong></p>\n<p>data Pointer to byte pixel data. Must not be nullptr.</p>\n<p>w Pixel data width.</p>\n<p>h Pixel data height.</p>\n<p>glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.</p>\n<p>glType the OpenGL type of the data.</p>\n","desc":""},{"syntax":"loadData(data, w, h, glFormat)","name":"loadData","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> uint8_t <span class=\"token operator\">*</span><span class=\"token keyword\">const</span> data<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> w<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> h<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> glFormat","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Load byte pixel data.</p>\n<p>glFormat can be different to the internal format of the texture on each\nload, i.e. we can upload GL_BGRA pixels into a GL_RGBA texture but the\nnumber of channels need to match according to the OpenGL standard.</p>\n<p><strong>Parameters:</strong></p>\n<p>data Pointer to byte pixel data. Must not be nullptr.</p>\n<p>w Pixel data width.</p>\n<p>h Pixel data height.</p>\n<p>glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.</p>\n","desc":""},{"syntax":"loadScreenData(x, y, w, h)","name":"loadScreenData","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> y<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> w<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> h","access":"public","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Copy an area of the screen into this texture.</p>\n<p>Specifiy the position (x,y) you wish to grab from, with the width (w)\nand height (h) of the region.</p>\n<p>Make sure that you have allocated your texture (using <code><span class=\"token function\">allocate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code>)\nto be large enough to hold the region of the screen you wish to load.</p>\n<p><strong>See also</strong>: http://www.opengl.org/sdk/docs/man4/html/glCopyTexSubImage2D.xhtml</p>\n<p><strong>Parameters:</strong></p>\n<p>x Upper left corner horizontal screen position.</p>\n<p>y Upper left corner vertical screen position.</p>\n<p>w Width of the area to copy in pixels.</p>\n<p>h Height of the area to copy in pixels.</p>\n","desc":"<p>Grabs a region of the screen and loads it into the texture. Specifiy the position (x,y) you wish to grab from, with the width (w) and height (h) of the region. Make sure that you have allocated your texture (using allocate()) to be large enough to hold the region of the screen you wish to load.\nLoad data from the current screen into this texture. Grabs a region of the screen and loads it into the texture. Specifiy the position (x,y) you wish to grab from, with the width (w) and height (h) of the region. Make sure that you have allocated your texture (using allocate()) to be large enough to hold the region of the screen you wish to load.</p>\n"},{"syntax":"ofTexture(&&mom)","name":"ofTexture","returns":null,"returns_description":null,"parameters":"ofTexture <span class=\"token operator\">&amp;&amp;</span>mom","access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"ofTexture(&mom)","name":"ofTexture","returns":null,"returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofTexture <span class=\"token operator\">&amp;</span>mom","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Construct an ofTexture from an existing ofTexture.</p>\n<p><strong>Parameters:</strong></p>\n<p>mom The ofTexture to copy. Reuses internal GL texture ID.</p>\n","desc":""},{"syntax":"ofTexture()","name":"ofTexture","returns":null,"returns_description":null,"parameters":null,"access":"public","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"False","advanced":"False","short":"<p>\\section Construction and Allocation\nConstruct an ofTexture instance.</p>\n","desc":"<p>Creates an empty ofTexture instance. You can't draw a texture right after it's been created as it has actually uploaded any data to the graphics card that can be drawn yet.</p>\n"},{"syntax":"operator=(&&mom)","name":"operator=","returns":"ofTexture &","returns_description":null,"parameters":"ofTexture <span class=\"token operator\">&amp;&amp;</span>mom","access":"public","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"operator=(&mom)","name":"operator=","returns":"ofTexture &","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofTexture <span class=\"token operator\">&amp;</span>mom","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>\\section Update Texture\nCopy a given ofTexture into this texture.</p>\n<p><strong>Parameters:</strong></p>\n<p>mom The ofTexture to copy from. Reuses internal GL texture ID.</p>\n","desc":""},{"syntax":"readToPixels(&pixels)","name":"readToPixels","returns":"void","returns_description":null,"parameters":"ofPixels <span class=\"token operator\">&amp;</span>pixels","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>\\section Read Pixel Data\nRead current texture data from the GPU into pixels.</p>\n<p><strong>Warning</strong>: This is not supported in OpenGL ES and does nothing.</p>\n<p><strong>Parameters:</strong></p>\n<p>pixels Target ofPixels reference.</p>\n","desc":""},{"syntax":"readToPixels(&pixels)","name":"readToPixels","returns":"void","returns_description":null,"parameters":"ofShortPixels <span class=\"token operator\">&amp;</span>pixels","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Read current texture data from the GPU into pixels.</p>\n<p><strong>Warning</strong>: This is not supported in OpenGL ES and does nothing.</p>\n<p><strong>Parameters:</strong></p>\n<p>pixels Target pixels reference.</p>\n","desc":""},{"syntax":"readToPixels(&pixels)","name":"readToPixels","returns":"void","returns_description":null,"parameters":"ofFloatPixels <span class=\"token operator\">&amp;</span>pixels","access":"public","version_started":"007","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Read current texture data from the GPU into pixels.</p>\n<p><strong>Warning</strong>: This is not supported in OpenGL ES and does nothing.</p>\n<p><strong>Parameters:</strong></p>\n<p>pixels Target pixels reference.</p>\n","desc":""},{"syntax":"resetAnchor()","name":"resetAnchor","returns":"void","returns_description":null,"parameters":null,"access":"public","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Reset the anchor point to (0, 0).</p>\n","desc":""},{"syntax":"setAlphaMask(&mask)","name":"setAlphaMask","returns":"void","returns_description":null,"parameters":"ofTexture <span class=\"token operator\">&amp;</span>mask","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>\\section Texture Settings\nSet another ofTexture to use as an alpha mask.</p>\n<p><strong>Parameters:</strong></p>\n<p>mask The texture to use as alpha mask.</p>\n","desc":""},{"syntax":"setAnchorPercent(xPct, yPct)","name":"setAnchorPercent","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> xPct<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> yPct","access":"public","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Set the anchor point the texture is drawn around as a percentage.</p>\n<p>This can be useful if you want to rotate an image around a particular\npoint.</p>\n<p><strong>Parameters:</strong></p>\n<p>xPct Horizontal texture position as a percentage (0 - 1).</p>\n<p>yPct Vertical texture position as a percentage (0 - 1).</p>\n","desc":"<p>The anchor is the point the image is drawn around. This can be useful if you want to rotate an image around a particular point, allowing you to set the anchor as a percentage of the image width/height ( 0.0-1.0 range )</p>\n"},{"syntax":"setAnchorPoint(x, y)","name":"setAnchorPoint","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> y","access":"public","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Set the anchor point the texture is drawn around in pixels.</p>\n<p>This can be useful if you want to rotate an image around a particular\npoint.</p>\n<p><strong>Parameters:</strong></p>\n<p>x Horizontal texture position in pixels.</p>\n<p>y Vertical texture position in pixels.</p>\n","desc":"<p>set the anchor point in pixels</p>\n"},{"syntax":"setCompression(compression)","name":"setCompression","returns":"void","returns_description":null,"parameters":"ofTexCompression compression","access":"public","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Set the texture compression.</p>\n<p>\\warning: not yet implemented.</p>\n<p><strong>See also</strong>: ofTexCompression</p>\n","desc":""},{"syntax":"setRGToRGBASwizzles(rToRGBSwizzles)","name":"setRGToRGBASwizzles","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">bool</span> rToRGBSwizzles","access":"public","version_started":"0073","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>\\todo Define Swizzle in the documentation.\nSwizzle RGBA to grayscale with alpha in the red channel.</p>\n<p>Use 1 channel GL_R as luminance instead of red channel in OpenGL 3+.</p>\n<p><strong>Warning</strong>: This is not supported in OpenGL ES and does nothing.</p>\n<p><strong>See also</strong>: https://en.wikipedia.org/wiki/Swizzling_(computer_graphics)</p>\n","desc":""},{"syntax":"setSwizzle(srcSwizzle, dstChannel)","name":"setSwizzle","returns":"void","returns_description":null,"parameters":"GLenum srcSwizzle<span class=\"token punctuation\">,</span> GLenum dstChannel","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Swizzle a channel to another</p>\n<p>Example:</p>\n<pre><code>ofTexture tex<span class=\"token punctuation\">;</span>\ntex<span class=\"token punctuation\">.</span><span class=\"token function\">setSwizzle</span><span class=\"token punctuation\">(</span>GL_TEXTURE_SWIZZLE_R<span class=\"token punctuation\">,</span>GL_ALPHA<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>will make channel 0 appear as alpha in the shader.</p>\n<p><strong>Warning</strong>: This is not supported in OpenGL ES and does nothing.</p>\n<p><strong>See also</strong>: https://en.wikipedia.org/wiki/Swizzling_(computer_graphics)</p>\n","desc":""},{"syntax":"setTextureMatrix(&m)","name":"setTextureMatrix","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> glm<span class=\"token operator\">::</span>mat4 <span class=\"token operator\">&amp;</span>m","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Sets a texture matrix to be uploaded whenever the texture is bound.</p>\n<p><strong>Parameters:</strong></p>\n<p>m The 4x4 texture matrix.</p>\n","desc":""},{"syntax":"setTextureMinMagFilter(minFilter, magFilter)","name":"setTextureMinMagFilter","returns":"void","returns_description":null,"parameters":"GLint minFilter<span class=\"token punctuation\">,</span> GLint magFilter","access":"public","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Set texture minification/magnification scaling filters.</p>\n<p>Controls how OpenGL will scale this texture.</p>\n<p><strong>See also</strong>: http://www.opengl.org/sdk/docs/man4/html/glTexParameter.xhtml</p>\n<p><strong>See also</strong>: ofTextureSetMinMagFilters()</p>\n<p><strong>Warning</strong>: May be overridden.</p>\n<p><strong>Parameters:</strong></p>\n<p>minFilter minifying filter for scaling a pixel to a smaller area.</p>\n<p>magFilter magnifying filter for scaling a pixel to a larger area.</p>\n","desc":"<p>Set how the texture is scaled up and down, when it's being drawn larger or smaller than it's actual size.</p>\n"},{"syntax":"setTextureWrap(wrapModeHorizontal, wrapModeVertical)","name":"setTextureWrap","returns":"void","returns_description":null,"parameters":"GLint wrapModeHorizontal<span class=\"token punctuation\">,</span> GLint wrapModeVertical","access":"public","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Set texture wrapping.</p>\n<p>By default, textures are clamped to their edges with <code>GL_CLAMP_TO_EDGE</code>.\nSetting a repeat mode like <code>GL_REPEAT</code> allows you to create tiled\nbackgrounds with small textures.</p>\n<p><strong>See also</strong>: ofTextureSetWrap()</p>\n<p><strong>See also</strong>: http://www.opengl.org/sdk/docs/man4/html/glTexParameter.xhtml</p>\n<p><strong>Warning</strong>: May be overridden.</p>\n<p><strong>Parameters:</strong></p>\n<p>wrapModeHorizontal wrap parameter for texture coordinate s.</p>\n<p>wrapModeVertical wrap parameter for texture coordinate t.</p>\n","desc":"<p>Sets how the texture wraps around the edges of the vertices that the texture is being drawn to.</p>\n"},{"syntax":"setUseExternalTextureID(externTexID)","name":"setUseExternalTextureID","returns":"void","returns_description":null,"parameters":"GLuint externTexID","access":"public","version_started":"0072","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Set the texture ID.</p>\n<p>Allows you to point the texture id to an externally allocated id\n(perhaps from another texture). It's up to you to set the rest of the\ntextData parameters manually.</p>\n<p><strong>Warning</strong>: When setting an external texture ID, the user must set the\nremaining ofTextureData parameters manually.</p>\n<p><strong>Parameters:</strong></p>\n<p>externTexID New texture ID.</p>\n","desc":""},{"syntax":"unbind(textureLocation = 0)","name":"unbind","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">int</span> textureLocation<span class=\"token operator\">=</span><span class=\"token number\">0</span>","access":"public","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Unbind the texture.</p>\n<p>For advanced users who need to manually manage texture drawing without\ncalling ofTexture::draw.</p>\n<p><strong>See also</strong>: http://www.opengl.org/sdk/docs/man4/html/glBindTexture.xhtml</p>\n","desc":"<p>This for the advanced user who wants to draw textures in their own way. This stops vertices from being textured using this texture.</p>\n"},{"syntax":"~ofTexture()","name":"~ofTexture","returns":null,"returns_description":null,"parameters":null,"access":"public","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"False","advanced":"False","short":"<p>Destroy an ofTexture instance.</p>\n<p>ofTexture keeps a reference count for the internal OpenGL texture ID.\nThus, the texture ID is only released if there are no additional\nreferences to the internal texture ID.</p>\n","desc":""},{"name":"anchor","type":"ofPoint","access":"protected","version_started":"006","version_deprecated":null,"summary":null,"visible":"True","constant":"False","advanced":"False","short":"<p>&lt; The texture's anchor point.</p>\n","desc":""},{"name":"bAnchorIsPct","type":"bool","access":"protected","version_started":"006","version_deprecated":null,"summary":null,"visible":"True","constant":"False","advanced":"False","short":"<p>&lt; Is the anchor point represented as a normalized\n&lt; (0 - 1) coordinate?</p>\n","desc":""},{"name":"bWantsMipmap","type":"bool","access":"private","version_started":"0.9.0","version_deprecated":null,"summary":null,"visible":"True","constant":"False","advanced":"False","short":"<p>&lt; Should mipmaps be created?</p>\n","desc":""},{"name":"texData","type":"ofTextureData","access":"public","version_started":"006","version_deprecated":null,"summary":null,"visible":"True","constant":"False","advanced":"True","short":"<p>&lt; Internal texture data access.\n&lt; For backwards compatibility.</p>\n","desc":"<p>texData is a variable type ofTextureData. ofTextureData is a structure containing information about the texture such as size.</p>\n"},{}],"document":"<p>#class ofTexture</p>\n<p>&lt;!--\n<em>visible: True</em>\n<em>advanced: False</em>\n<em>istemplated: False</em>\n<em>extends: ofBaseDraws</em>\n--&gt;</p>\n<p>##InlineDescription</p>\n<p>A wrapper class for an OpenGL texture.</p>\n<p>##Description</p>\n<p>ofTexture is used to create textures that live on your graphics card from bitmap data that can then be used to fill other drawn objects, like a bitmap fill on a rectangle. When you draw an ofImage, you're actually just drawing a rectangle of points and then using an ofTexture to fill the space between those points. At it's core, ofTexture is a wrapper for OpenGL textures. It allows use of non-power of 2 textures in opengl, and to upload and draw graphical data.</p>\n<p>##Methods</p>\n<p>###void allocate(&amp;pix)</p>\n<p>&lt;!--\n<em>syntax: allocate(&amp;pix)</em>\n<em>name: allocate</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const ofPixels &amp;pix</em>\n<em>access: public</em>\n<em>version_started: 0071</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Allocate texture using an ofPixels instance.</p>\n<p>Pixel type and OpenGL format are determined from pixel settings.</p>\n<p><strong>Parameters:</strong></p>\n<p>pix Reference to ofPixels instance.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void allocate(&amp;pix)</p>\n<p>&lt;!--\n<em>syntax: allocate(&amp;pix)</em>\n<em>name: allocate</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const ofShortPixels &amp;pix</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Allocate texture using an ofShortPixels instance.</p>\n<p>Same as void allocate(const ofPixels&amp; pix), except using ofShortPixels.</p>\n<p><strong>See also</strong>: allocate(const ofPixels&amp; pix)</p>\n<p><strong>Parameters:</strong></p>\n<p>pix Reference to ofShortPixels instance.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void allocate(&amp;pix)</p>\n<p>&lt;!--\n<em>syntax: allocate(&amp;pix)</em>\n<em>name: allocate</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const ofFloatPixels &amp;pix</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Allocate texture using an ofFloatPixels instance.</p>\n<p>Same as void allocate(const ofPixels&amp; pix), except using ofFloatPixels.</p>\n<p><strong>See also</strong>: allocate(const ofPixels&amp; pix)</p>\n<p><strong>Parameters:</strong></p>\n<p>pix Reference to ofFloatPixels instance.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void allocate(&amp;pix, bUseARBExtension)</p>\n<p>&lt;!--\n<em>syntax: allocate(&amp;pix, bUseARBExtension)</em>\n<em>name: allocate</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const ofPixels &amp;pix, bool bUseARBExtension</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Allocate texture using an ofPixels instance and type.</p>\n<p>This lets you overide the default OF texture type in case you need a\nsquare GL_TEXTURE_2D texture.</p>\n<p><strong>Warning</strong>: ARB textures are not available in OpenGL ES.</p>\n<p><strong>See also</strong>: ofEnableArbTex()</p>\n<p><strong>See also</strong>: allocate(const ofPixels&amp; pix)</p>\n<p><strong>Parameters:</strong></p>\n<p>pix Reference to ofPixels instance.</p>\n<p>bUseARBExtension Set to true to use rectangular textures.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void allocate(&amp;pix, bUseARBExtension)</p>\n<p>&lt;!--\n<em>syntax: allocate(&amp;pix, bUseARBExtension)</em>\n<em>name: allocate</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const ofShortPixels &amp;pix, bool bUseARBExtension</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Allocate texture using an ofShortPixels instance and type.</p>\n<p>Same as void void allocate(const ofPixels&amp; pix), except using ofShortPixels.</p>\n<p><strong>See also</strong>: allocate(const ofShortPixels&amp; pix)</p>\n<p><strong>Parameters:</strong></p>\n<p>pix Reference to ofShortPixels instance.</p>\n<p>bUseARBExtension Set to true to use rectangular textures.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void allocate(&amp;pix, bUseARBExtension)</p>\n<p>&lt;!--\n<em>syntax: allocate(&amp;pix, bUseARBExtension)</em>\n<em>name: allocate</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const ofFloatPixels &amp;pix, bool bUseARBExtension</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Allocate texture using an ofShortPixels instance and type.</p>\n<p>Same as void void allocate(const ofPixels&amp; pix), except using ofShortPixels.</p>\n<p><strong>See also</strong>: allocate(const ofFloatPixels&amp; pix)</p>\n<p><strong>Parameters:</strong></p>\n<p>pix Reference to ofFloatPixels instance.</p>\n<p>bUseARBExtension Set to true to use rectangular textures.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void allocate(&amp;textureData)</p>\n<p>&lt;!--\n<em>syntax: allocate(&amp;textureData)</em>\n<em>name: allocate</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const ofTextureData &amp;textureData</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Allocate the texture using the given settings.</p>\n<p>This is useful if you need manual control over loading a number of\ntextures with the same settings. Make sure to set the texture data\nparameters first.</p>\n<p><strong>Parameters:</strong></p>\n<p>textureData The settings to use when allocating the ofTexture.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void allocate(&amp;textureData, glFormat, pixelType)</p>\n<p>&lt;!--\n<em>syntax: allocate(&amp;textureData, glFormat, pixelType)</em>\n<em>name: allocate</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const ofTextureData &amp;textureData, int glFormat, int pixelType</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Allocate the texture using the given settings and custom format.</p>\n<p><strong>Parameters:</strong></p>\n<p>textureData The settings to use when allocating the ofTexture.</p>\n<p>glFormat GL texture format: GL_RGBA, GL_LUMINANCE, etc.</p>\n<p>pixelType GL pixel type: GL_UNSIGNED_BYTE, GL_FLOAT, etc.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void allocate(w, h, glInternalFormat)</p>\n<p>&lt;!--\n<em>syntax: allocate(w, h, glInternalFormat)</em>\n<em>name: allocate</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: int w, int h, int glInternalFormat</em>\n<em>access: public</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Allocate texture of a given size and format.</p>\n<p>The width (w) and height (h) do not necessarily need to be powers of 2,\nbut they do need to be large enough to contain the data you will upload\nto the texture.</p>\n<p>The internal data type <code>glFormat</code> describes how OpenGL will store this\ntexture internally. For example, if you want a grayscale texture, you\ncan use <code>GL_LUMINANCE</code>. You can upload what ever type of data you want\n(using <code><span class=\"token function\">loadData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code>) but internally, opengl will store the information\nas grayscale. Other types include: <code>GL_RGB</code>, <code>GL_RGBA</code>.</p>\n<p>This method applies the currently set OF texture type and defaults to\nARB rectangular textures if they are supported. (They are not supported\non OpenGL ES).</p>\n<p><strong>Parameters:</strong></p>\n<p>w Desired width in pixels.</p>\n<p>h Desired height in pixels.</p>\n<p>glInternalFormat OpenGL internal data format: <code>GL_RGBA</code>, <code>GL_LUMINANCE</code>, etc.</p>\n<p>_description: _</p>\n<p>This is the call to allocate opengl texture. The width (w) and height (h) do not necessarily need to be powers of 2, but they do need to be large enough to contain the data you will upload to the texture.  The internal data type describes how opengl will store this texture internally. For example, if you want a grayscale texture, you can use &quot;GL_LUMINANCE&quot;. You can uplaod what ever type of data you want (using loadData()) but internally, opengl will store the information as grayscale. Other types include: GL_RGB, GL_RGBA.\nYou need to allocate the texture before drawing it or loading data into it.\nuses the currently set OF texture type - default ARB texture</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void allocate(w, h, glInternalFormat, bUseARBExtension)</p>\n<p>&lt;!--\n<em>syntax: allocate(w, h, glInternalFormat, bUseARBExtension)</em>\n<em>name: allocate</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: int w, int h, int glInternalFormat, bool bUseARBExtension</em>\n<em>access: public</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Allocate texture of a given size and format. Specify texture type.</p>\n<p>This allows to enable the ARBE extension for this texture.\nThis will overide the default OF texture type, in case you need a\nsquare texture (<code>GL_TEXTURE_2D</code>).</p>\n<p><strong>Warning</strong>: ARB textures are not available in OpenGL ES.</p>\n<p><strong>See also</strong>: ofEnableArbTex()</p>\n<p><strong>See also</strong>: allocate(int w, int h, int glInternalFormat)</p>\n<p><strong>Parameters:</strong></p>\n<p>w Desired width in pixels.</p>\n<p>h Desired height in pixels.</p>\n<p>glInternalFormat The internal openGL format.</p>\n<p>bUseARBExtension Set to true to use rectangular textures.</p>\n<p>_description: _</p>\n<p>See previous allocate for knowing the behaviour of this function. The parameter bUseARBEExtension allow the user to enable the ARBE extension for this texture.\nYou need to allocate the texture before drawing it or loading data into it, lets you overide the default OF texture type</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void allocate(w, h, glInternalFormat, bUseARBExtension, glFormat, pixelType)</p>\n<p>&lt;!--\n<em>syntax: allocate(w, h, glInternalFormat, bUseARBExtension, glFormat, pixelType)</em>\n<em>name: allocate</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: int w, int h, int glInternalFormat, bool bUseARBExtension, int glFormat, int pixelType</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Allocate texture of a given size, format, &amp; type.</p>\n<p><strong>See also</strong>: allocate(int w, int h, int glInternalFormat)</p>\n<p><strong>Parameters:</strong></p>\n<p>w Desired width in pixels.</p>\n<p>h Desired height in pixels.</p>\n<p>glInternalFormat OpenGL data format: <code>GL_RGBA</code>, <code>GL_LUMINANCE</code>, etc.</p>\n<p>bUseARBExtension Set to true to use rectangular textures.</p>\n<p>glFormat The OpenGL format.</p>\n<p>pixelType OpenGL pixel type: <code>GL_UNSIGNED_BYTE</code>, <code>GL_FLOAT</code>, etc.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void allocate(w, h, glInternalFormat, glFormat, pixelType)</p>\n<p>&lt;!--\n<em>syntax: allocate(w, h, glInternalFormat, glFormat, pixelType)</em>\n<em>name: allocate</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: int w, int h, int glInternalFormat, int glFormat, int pixelType</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Allocate texture of a given size and format.</p>\n<p><strong>See also</strong>: allocate(int w, int h, int glInternalFormat)</p>\n<p><strong>Parameters:</strong></p>\n<p>w Desired width in pixels.</p>\n<p>h Desired height in pixels.</p>\n<p>glInternalFormat The internal openGL format.</p>\n<p>glFormat The openGL format.</p>\n<p>pixelType GL pixel type: GL_UNSIGNED_BYTE, GL_FLOAT, etc.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void allocateAsBufferTexture(&amp;buffer, glInternalFormat)</p>\n<p>&lt;!--\n<em>syntax: allocateAsBufferTexture(&amp;buffer, glInternalFormat)</em>\n<em>name: allocateAsBufferTexture</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const ofBufferObject &amp;buffer, int glInternalFormat</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Allocate texture as a Buffer Texture.</p>\n<p>Uses a GPU buffer as data for the texture instead of pixels in RAM\nAllows to use texture buffer objects (TBO) which make it easier to send big\namounts of data to a shader as a uniform.</p>\n<p>Buffer textures are 1D textures, and may only be sampled using texelFetch\nin GLSL.</p>\n<p>See textureBufferInstanceExample and https://www.opengl.org/wiki/Buffer_Texture</p>\n<p><strong>See also</strong>: allocate(const ofBufferObject &amp; buffer, int glInternalFormat)</p>\n<p><strong>Parameters:</strong></p>\n<p>buffer Reference to ofBufferObject instance.</p>\n<p>glInternalFormat Internal pixel format of the data.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void bind(textureLocation = 0)</p>\n<p>&lt;!--\n<em>syntax: bind(textureLocation = 0)</em>\n<em>name: bind</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: int textureLocation=0</em>\n<em>access: public</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Bind the texture.</p>\n<p>For advanced users who need to manually manage texture drawing without\ncalling ofTexture::draw.</p>\n<p><strong>See also</strong>: http://www.opengl.org/sdk/docs/man4/html/glBindTexture.xhtml</p>\n<p>_description: _</p>\n<p>This is for the advanced user who wants to draw textures in their own way. Each set of vertices that you draw after calling bind() will be textured using this texture.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void bindAsImage(unit, access, level = 0, layered, layer = 0)</p>\n<p>&lt;!--\n<em>syntax: bindAsImage(unit, access, level = 0, layered, layer = 0)</em>\n<em>name: bindAsImage</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: GLuint unit, GLenum access, GLint level=0, GLboolean layered, GLint layer=0</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Calls glBindImageTexture on the texture</p>\n<p>Binds the texture as an read or write image, only available since OpenGL 4.2</p>\n<p><strong>Warning</strong>: This is not available in OpenGLES</p>\n<p><strong>See also</strong>: http://www.opengl.org/wiki/GLAPI/glBindImageTexture</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void clear()</p>\n<p>&lt;!--\n<em>syntax: clear()</em>\n<em>name: clear</em>\n<em>returns: void</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Clears the texture.</p>\n<p>Clears / frees the texture memory, if something was already allocated.\nUseful if you need to control the memory on the graphics card.</p>\n<p>The internal GL texture ID is only released if this is the last texture\nusing it.</p>\n<p>_description: _</p>\n<p>clears / frees the texture memory, if something was already allocated. useful if you need to control the memory on the graphics card.\nClears all the data from the texture</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void copyTo(&amp;buffer)</p>\n<p>&lt;!--\n<em>syntax: copyTo(&amp;buffer)</em>\n<em>name: copyTo</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: ofBufferObject &amp;buffer</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Copy the texture to an ofBufferObject.</p>\n<p><strong>Parameters:</strong></p>\n<p>buffer the target buffer to copy to.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void disableAlphaMask()</p>\n<p>&lt;!--\n<em>syntax: disableAlphaMask()</em>\n<em>name: disableAlphaMask</em>\n<em>returns: void</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Disable the alpha mask.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void disableMipmap()</p>\n<p>&lt;!--\n<em>syntax: disableMipmap()</em>\n<em>name: disableMipmap</em>\n<em>returns: void</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Sets flag disallowing texture to auto-generate mipmap.</p>\n<p>By default, this will set your minFilter to GL_LINEAR_MIPMAP_LINEAR.\nIf you want to change your minFilter later use setTextureMinMagFilter()</p>\n<pre><code>If you want to generate a mipmap later<span class=\"token punctuation\">,</span> <span class=\"token operator\">or</span> at a specific\n</code></pre>\n<p>point in your code, use ofTexture::generateMipmap() instead.</p>\n<p><strong>See also</strong>: generateMipmap()</p>\n<p><strong>See also</strong>: enableMipmap()</p>\n<p><strong>See also</strong>: setTextureMinMagFilter()</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void disableTextureMatrix()</p>\n<p>&lt;!--\n<em>syntax: disableTextureMatrix()</em>\n<em>name: disableTextureMatrix</em>\n<em>returns: void</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Disable the texture matrix.\nDisable the texture matrix.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void disableTextureTarget(textureLocation)</p>\n<p>&lt;!--\n<em>syntax: disableTextureTarget(textureLocation)</em>\n<em>name: disableTextureTarget</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: int textureLocation</em>\n<em>access: protected</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Disable a texture target.</p>\n<p><strong>Parameters:</strong></p>\n<p>textureLocation the OpenGL texture ID to enable as a target.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void draw(&amp;p1, &amp;p2, &amp;p3, &amp;p4)</p>\n<p>&lt;!--\n<em>syntax: draw(&amp;p1, &amp;p2, &amp;p3, &amp;p4)</em>\n<em>name: draw</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const glm::vec3 &amp;p1, const glm::vec3 &amp;p2, const glm::vec3 &amp;p3, const glm::vec3 &amp;p4</em>\n<em>access: public</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Draws the texture at 4 points passed in as if you created 4 glVertices.</p>\n<p><strong>Parameters:</strong></p>\n<p>p1 Upper left position on the x axis.</p>\n<p>p2 Upper left position on the y axis.</p>\n<p>p3 Lower right position on the x axis.</p>\n<p>p4 Lower right position on the y axis.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void draw(&amp;pos)</p>\n<p>&lt;!--\n<em>syntax: draw(&amp;pos)</em>\n<em>name: draw</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const glm::vec3 &amp;pos</em>\n<em>access: public</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void draw(&amp;pos, w, h)</p>\n<p>&lt;!--\n<em>syntax: draw(&amp;pos, w, h)</em>\n<em>name: draw</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const glm::vec3 &amp;pos, float w, float h</em>\n<em>access: public</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Draws the texture at 4 points passed in as if you created 4 glVertices.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void draw(x, y)</p>\n<p>&lt;!--\n<em>syntax: draw(x, y)</em>\n<em>name: draw</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: float x, float y</em>\n<em>access: public</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>\\section Drawing</p>\n<p>_description: _</p>\n<p>Draws the texture at a given point (x,y), using the textures true width and height.\nDraws the texture at the point passed in.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void draw(x, y, w, h)</p>\n<p>&lt;!--\n<em>syntax: draw(x, y, w, h)</em>\n<em>name: draw</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: float x, float y, float w, float h</em>\n<em>access: public</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>draws the texture at a given point (x,y), with a given width (w) and height (h).\nDraws the texture at the x, y and w, h.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void draw(x, y, z)</p>\n<p>&lt;!--\n<em>syntax: draw(x, y, z)</em>\n<em>name: draw</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: float x, float y, float z</em>\n<em>access: public</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>Draws the texture at the point passed in in 3D space.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void draw(x, y, z, w, h)</p>\n<p>&lt;!--\n<em>syntax: draw(x, y, z, w, h)</em>\n<em>name: draw</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: float x, float y, float z, float w, float h</em>\n<em>access: public</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Draw the texture at a given size witdh and depth.</p>\n<p><strong>Parameters:</strong></p>\n<p>x Draw position on the x axis.</p>\n<p>y Draw position on the y axis.</p>\n<p>z Draw position on the z axis.</p>\n<p>w Draw width.</p>\n<p>h Draw height.</p>\n<p>_description: _</p>\n<p>Draws the texture at the x, y, z in 3D space with the width and height at w,h.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void drawSubsection(&amp;drawBounds, &amp;subsectionBounds)</p>\n<p>&lt;!--\n<em>syntax: drawSubsection(&amp;drawBounds, &amp;subsectionBounds)</em>\n<em>name: drawSubsection</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const ofRectangle &amp;drawBounds, const ofRectangle &amp;subsectionBounds</em>\n<em>access: public</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Draw a subsection of the texture with an offset.</p>\n<p><strong>See also</strong>: drawSubsection(ofRectangle&amp; drawBounds, ofRectangle&amp; subsectionBounds)</p>\n<p><strong>Parameters:</strong></p>\n<p>drawBounds Draw position and dimensions.</p>\n<p>subsectionBounds Subsection position and dimensions within the texture.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void drawSubsection(x, y, w, h, sx, sy)</p>\n<p>&lt;!--\n<em>syntax: drawSubsection(x, y, w, h, sx, sy)</em>\n<em>name: drawSubsection</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: float x, float y, float w, float h, float sx, float sy</em>\n<em>access: public</em>\n<em>version_started: 0071</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Draw a subsection of the texture.</p>\n<p>Like ofRect() depend on the current <code>OF_RECT_MODE</code>:</p>\n<ul>\n<li><code>OF_RECT_MODE_CORNER</code>: drawn with the upper left corner = (x,y)</li>\n<li><code>OF_RECT_MODE_CENTER</code>: drawn centered on (x,y)</li>\n</ul>\n<p><strong>See also</strong>: ofSetRectMode()</p>\n<p><strong>Parameters:</strong></p>\n<p>x Draw position on the x axis.</p>\n<p>y Draw position on the y axis.</p>\n<p>w Draw width.</p>\n<p>h Draw height.</p>\n<p>sx Subsection x axis offset within the texture.</p>\n<p>sy Subsection y axis offset within the texture.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void drawSubsection(x, y, w, h, sx, sy, sw, sh)</p>\n<p>&lt;!--\n<em>syntax: drawSubsection(x, y, w, h, sx, sy, sw, sh)</em>\n<em>name: drawSubsection</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: float x, float y, float w, float h, float sx, float sy, float sw, float sh</em>\n<em>access: public</em>\n<em>version_started: 0071</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Draw a subsection of the texture with an offset.</p>\n<p><strong>See also</strong>: drawSubsection(float x, float y, float w, float h, float sx, float sy)</p>\n<p><strong>Parameters:</strong></p>\n<p>x Draw position on the x axis.</p>\n<p>y Draw position on the y axis.</p>\n<p>w Draw width.</p>\n<p>h Draw height.</p>\n<p>sx Subsection x axis offset within the texture.</p>\n<p>sy Subsection y axis offset within the texture.</p>\n<p>sw Subsection width within the texture.</p>\n<p>sh Subsection height within the texture.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void drawSubsection(x, y, z, w, h, sx, sy)</p>\n<p>&lt;!--\n<em>syntax: drawSubsection(x, y, z, w, h, sx, sy)</em>\n<em>name: drawSubsection</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: float x, float y, float z, float w, float h, float sx, float sy</em>\n<em>access: public</em>\n<em>version_started: 0071</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Draw a subsection of the texture with depth.</p>\n<p><strong>See also</strong>: drawSubsection(float x, float y, float w, float h, float sx, float sy)</p>\n<p><strong>Parameters:</strong></p>\n<p>x Draw position on the x axis.</p>\n<p>y Draw position on the y axis.</p>\n<p>z Draw position on the z axis.</p>\n<p>w Draw width.</p>\n<p>h Draw height.</p>\n<p>sx Subsection x axis offset within the texture.</p>\n<p>sy Subsection y axis offset within the texture.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void drawSubsection(x, y, z, w, h, sx, sy, sw, sh)</p>\n<p>&lt;!--\n<em>syntax: drawSubsection(x, y, z, w, h, sx, sy, sw, sh)</em>\n<em>name: drawSubsection</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: float x, float y, float z, float w, float h, float sx, float sy, float sw, float sh</em>\n<em>access: public</em>\n<em>version_started: 0071</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Draw a subsection of the texture with an offset and depth.</p>\n<p><strong>See also</strong>: drawSubsection(float x, float y, float w, float h, float sx, float sy)</p>\n<p><strong>Parameters:</strong></p>\n<p>x Draw position on the x axis.</p>\n<p>y Draw position on the y axis.</p>\n<p>z Draw position on the z axis.</p>\n<p>w Draw width.</p>\n<p>h Draw height.</p>\n<p>sx Subsection x axis offset within the texture.</p>\n<p>sy Subsection y axis offset within the texture.</p>\n<p>sw Subsection width within the texture.</p>\n<p>sh Subsection height within the texture.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void enableMipmap()</p>\n<p>&lt;!--\n<em>syntax: enableMipmap()</em>\n<em>name: enableMipmap</em>\n<em>returns: void</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>\\section Mipmapping\nSets flag allowing texture to auto-generate a mipmap.</p>\n<p>By default, this will set your minFilter to GL_LINEAR_MIPMAP_LINEAR.\nIf you want to change your minFilter later use setTextureMinMagFilter()</p>\n<pre><code>If you want to generate a mipmap later<span class=\"token punctuation\">,</span> <span class=\"token operator\">or</span> at a specific\n</code></pre>\n<p>point in your code, use generateMipmap() instead.</p>\n<p><strong>See also</strong>: generateMipmap()</p>\n<p><strong>See also</strong>: disableMipmap()</p>\n<p><strong>See also</strong>: setTextureMinMagFilter()</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void enableTextureTarget(textureLocation)</p>\n<p>&lt;!--\n<em>syntax: enableTextureTarget(textureLocation)</em>\n<em>name: enableTextureTarget</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: int textureLocation</em>\n<em>access: protected</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Enable a texture target.</p>\n<p><strong>Parameters:</strong></p>\n<p>textureLocation the OpenGL texture ID to enable as a target.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void generateMipmap()</p>\n<p>&lt;!--\n<em>syntax: generateMipmap()</em>\n<em>name: generateMipmap</em>\n<em>returns: void</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Generate mipmap for the current texture.</p>\n<p><strong>Warning</strong>: Only GL_TEXTURE_RECTANGLE - which is the default openFrameworks\ntexture target - does <em>not</em> support mipmaps, so make sure to call\nofDisableArbTex() before loading texture\ndata for a texture you want to generate mipmaps for.</p>\n<p><strong>See also</strong>: ofEnableArbTex()</p>\n<p><strong>See also</strong>: ofDisableArbTex()</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###const ofTexture * getAlphaMask()</p>\n<p>&lt;!--\n<em>syntax: getAlphaMask()</em>\n<em>name: getAlphaMask</em>\n<em>returns: const ofTexture *</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###glm::vec2 getCoordFromPercent(xPts, yPts)</p>\n<p>&lt;!--\n<em>syntax: getCoordFromPercent(xPts, yPts)</em>\n<em>name: getCoordFromPercent</em>\n<em>returns: glm::vec2</em>\n_returns_description: _\n<em>parameters: float xPts, float yPts</em>\n<em>access: public</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Helper to convert display coordinate to texture coordinate.</p>\n<p><strong>Parameters:</strong></p>\n<p>xPts Horizontal position in a normalized percentage (0 - 1).</p>\n<p>yPts Vertical position in a normalized percentage (0 - 1).</p>\n<p><strong>Returns</strong>: Texture coordinate or zero if texture is not allocated.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###glm::vec2 getCoordFromPoint(xPos, yPos)</p>\n<p>&lt;!--\n<em>syntax: getCoordFromPoint(xPos, yPos)</em>\n<em>name: getCoordFromPoint</em>\n<em>returns: glm::vec2</em>\n_returns_description: _\n<em>parameters: float xPos, float yPos</em>\n<em>access: public</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Helper to convert display coordinate to texture coordinate.</p>\n<p><strong>Parameters:</strong></p>\n<p>xPos Horizontal position in pixels.</p>\n<p>yPos Vertical position in pixels.</p>\n<p><strong>Returns</strong>: Texture coordinate or zero if texture is not allocated.</p>\n<p>_description: _</p>\n<p>these are helpers to allow you to get points for the texture ala &quot;glTexCoordf&quot; but are texture type independent. use them for immediate or non immediate mode</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float getHeight()</p>\n<p>&lt;!--\n<em>syntax: getHeight()</em>\n<em>name: getHeight</em>\n<em>returns: float</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>\\section Size and Coordinates\nDisplay height of texture.</p>\n<p>Return value is pixel size (default) or normalized (0 - 1) if ofEnableNormalizedTextures() is set to true.</p>\n<p><strong>See also</strong>: ofEnabledNormalizedTextures()</p>\n<p><strong>Returns</strong>: Display height of texture in pixels.</p>\n<p>_description: _</p>\n<p>Returns the height of the texture. This will be in pixels unless you've set your application to use normalized coordinates.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###ofMesh getMeshForSubsection(x, y, z, w, h, sx, sy, sw, sh, vflipped, rectMode)</p>\n<p>&lt;!--\n<em>syntax: getMeshForSubsection(x, y, z, w, h, sx, sy, sw, sh, vflipped, rectMode)</em>\n<em>name: getMeshForSubsection</em>\n<em>returns: ofMesh</em>\n_returns_description: _\n<em>parameters: float x, float y, float z, float w, float h, float sx, float sy, float sw, float sh, bool vflipped, ofRectMode rectMode</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Get a mesh that has the texture coordinates set.</p>\n<p><strong>See also</strong>: drawSubsection(float x, float y, float w, float h, float sx, float sy)</p>\n<p><strong>Parameters:</strong></p>\n<p>x Draw position on the x axis.</p>\n<p>y Draw position on the y axis.</p>\n<p>z Draw position on the z axis.</p>\n<p>w Draw width.</p>\n<p>h Draw height.</p>\n<p>sx Subsection x axis offset within the texture.</p>\n<p>sy Subsection y axis offset within the texture.</p>\n<p>sw Subsection width within the texture.</p>\n<p>sh Subsection height within the texture.</p>\n<p>vflipped Takes into account the flipped state in OF.</p>\n<p>rectMode rectMode Taking x,y as the center or the top left corner.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###ofMesh getQuad(&amp;p1, &amp;p2, &amp;p3, &amp;p4)</p>\n<p>&lt;!--\n<em>syntax: getQuad(&amp;p1, &amp;p2, &amp;p3, &amp;p4)</em>\n<em>name: getQuad</em>\n<em>returns: ofMesh</em>\n_returns_description: _\n<em>parameters: const glm::vec3 &amp;p1, const glm::vec3 &amp;p2, const glm::vec3 &amp;p3, const glm::vec3 &amp;p4</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###ofTextureData &amp; getTextureData()</p>\n<p>&lt;!--\n<em>syntax: getTextureData()</em>\n<em>name: getTextureData</em>\n<em>returns: ofTextureData &amp;</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.8.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>\\section Texture Data\nInternal texture data access.</p>\n<p>This returns the internal texture data for this texture, for instance,\nits textureID, type of texture, whether it's been allocated and other\ndata about the state of the texture.</p>\n<p><strong>Returns</strong>: a reference to the internal texture data struct.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###const ofTextureData &amp; getTextureData()</p>\n<p>&lt;!--\n<em>syntax: getTextureData()</em>\n<em>name: getTextureData</em>\n<em>returns: const ofTextureData &amp;</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Const version of getTextureData().</p>\n<p><strong>See also</strong>: ofTextureData::getTextureData()</p>\n<p>_description: _</p>\n<p>This returns the internal texture data for this texture, for instance, its textureID, type of texture, whether it's been allocated, and other data about the state of the texture.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###const glm::mat4 &amp; getTextureMatrix()</p>\n<p>&lt;!--\n<em>syntax: getTextureMatrix()</em>\n<em>name: getTextureMatrix</em>\n<em>returns: const glm::mat4 &amp;</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float getWidth()</p>\n<p>&lt;!--\n<em>syntax: getWidth()</em>\n<em>name: getWidth</em>\n<em>returns: float</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Display width of texture.</p>\n<p>Return value is pixel size (default) or normalized (0 - 1) if ofEnableNormalizedTextures() is set to true.</p>\n<p><strong>See also</strong>: ofEnabledNormalizedTextures()</p>\n<p><strong>Returns</strong>: Display width of texture in pixels.</p>\n<p>_description: _</p>\n<p>Returns the width of the texture. This will be in pixels unless you've set your application to use normalized coordinates.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool hasMipmap()</p>\n<p>&lt;!--\n<em>syntax: hasMipmap()</em>\n<em>name: hasMipmap</em>\n<em>returns: bool</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Find out if a mipmap has been generated for the current texture.</p>\n<p><strong>See also</strong>: generateMipmap()</p>\n<p><strong>See also</strong>: enableMipmap()</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool isAllocated()</p>\n<p>&lt;!--\n<em>syntax: isAllocated()</em>\n<em>name: isAllocated</em>\n<em>returns: bool</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Determine whether the texture has been allocated.</p>\n<p>This lets you check if a texture is safe to draw.  The texture can both\nbe allocated by using <code><span class=\"token function\">allocate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code> or loading it with data <code><span class=\"token function\">loadData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code>.</p>\n<p><strong>Returns</strong>: true if the texture has been allocated.</p>\n<p>_description: _</p>\n<p>Get whether the texture has been allocated.\nofTextureData getTextureData() ###\n// reference to the actual textureData inside the smart pointer\n// for backwards compatibility\nofTextureData texData ###\nfloat getHeight() ###\nfloat getWidth() ###</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool isUsingTextureMatrix()</p>\n<p>&lt;!--\n<em>syntax: isUsingTextureMatrix()</em>\n<em>name: isUsingTextureMatrix</em>\n<em>returns: bool</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void loadData(&amp;buffer, glFormat, glType)</p>\n<p>&lt;!--\n<em>syntax: loadData(&amp;buffer, glFormat, glType)</em>\n<em>name: loadData</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const ofBufferObject &amp;buffer, int glFormat, int glType</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Load pixels from an ofBufferObject</p>\n<p>This is different to allocate(ofBufferObject,internal). That\ncreates a texture which data lives in GL buffer while this\ncopies the data from the buffer to the texture.</p>\n<p>This is usually used to upload data to be shown asynchronously\nby using a buffer object binded as a PBO</p>\n<p><strong>Parameters:</strong></p>\n<p>buffer The buffer to load.</p>\n<p>glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.</p>\n<p>glType the GL type to load.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void loadData(&amp;pix)</p>\n<p>&lt;!--\n<em>syntax: loadData(&amp;pix)</em>\n<em>name: loadData</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const ofPixels &amp;pix</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Load pixels from an ofPixels instance.</p>\n<p><strong>Parameters:</strong></p>\n<p>pix Reference to ofPixels instance.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void loadData(&amp;pix)</p>\n<p>&lt;!--\n<em>syntax: loadData(&amp;pix)</em>\n<em>name: loadData</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const ofShortPixels &amp;pix</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Load pixels from an ofShortPixels instance.</p>\n<p>Same as loadData(ofPixels &amp;) but for ofShortPixels.</p>\n<p><strong>See also</strong>: loadData(const ofPixels &amp; pix)</p>\n<p><strong>Parameters:</strong></p>\n<p>pix Reference to ofShortPixels instance.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void loadData(&amp;pix)</p>\n<p>&lt;!--\n<em>syntax: loadData(&amp;pix)</em>\n<em>name: loadData</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const ofFloatPixels &amp;pix</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Load pixels from an ofFloatPixels instance.</p>\n<p>Same as loadData(ofPixels &amp;) but for ofFloatPixels.</p>\n<p><strong>See also</strong>: loadData(const ofPixels &amp; pix)</p>\n<p><strong>Parameters:</strong></p>\n<p>pix Reference to ofFloatPixels instance.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void loadData(&amp;pix, glFormat)</p>\n<p>&lt;!--\n<em>syntax: loadData(&amp;pix, glFormat)</em>\n<em>name: loadData</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const ofPixels &amp;pix, int glFormat</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Load pixels from an ofPixels instance and specify the format.</p>\n<p>glFormat can be different to the internal format of the texture on each\nload, ie. we can upload GL_BGRA pixels into a GL_RGBA texture, but the\nnumber of channels need to match according to the OpenGL standard.</p>\n<p><strong>Parameters:</strong></p>\n<p>pix Reference to ofPixels instance.</p>\n<p>glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void loadData(&amp;pix, glFormat)</p>\n<p>&lt;!--\n<em>syntax: loadData(&amp;pix, glFormat)</em>\n<em>name: loadData</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const ofShortPixels &amp;pix, int glFormat</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Load pixels from an ofShortPixels instance &amp; specify the format.</p>\n<p><strong>See also</strong>: loadData(const ofPixels &amp; pix, int glFormat)</p>\n<p><strong>Parameters:</strong></p>\n<p>pix Reference to ofShortPixels instance.</p>\n<p>glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void loadData(&amp;pix, glFormat)</p>\n<p>&lt;!--\n<em>syntax: loadData(&amp;pix, glFormat)</em>\n<em>name: loadData</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const ofFloatPixels &amp;pix, int glFormat</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Load pixels from an ofFloatPixels instance and specify the format.</p>\n<p><strong>See also</strong>: loadData(const ofPixels &amp; pix, int glFormat)</p>\n<p><strong>Parameters:</strong></p>\n<p>pix Reference to ofFloatPixels instance.</p>\n<p>glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void loadData(*data, w, h, glFormat)</p>\n<p>&lt;!--\n<em>syntax: loadData(*data, w, h, glFormat)</em>\n<em>name: loadData</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const uint16_t *data, int w, int h, int glFormat</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Load short (2 byte) pixel data.</p>\n<p><strong>See also</strong>: loadData(const unsigned char* const data, int w, int h, int glFormat)</p>\n<p><strong>Parameters:</strong></p>\n<p>data Pointer to byte pixel data. Must not be nullptr.</p>\n<p>w Pixel data width.</p>\n<p>h Pixel data height.</p>\n<p>glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void loadData(*data, w, h, glFormat)</p>\n<p>&lt;!--\n<em>syntax: loadData(*data, w, h, glFormat)</em>\n<em>name: loadData</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const uint32_t *data, int w, int h, int glFormat</em>\n<em>access: public</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void loadData(*data, w, h, glFormat)</p>\n<p>&lt;!--\n<em>syntax: loadData(*data, w, h, glFormat)</em>\n<em>name: loadData</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const int8_t *data, int w, int h, int glFormat</em>\n<em>access: public</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void loadData(*data, w, h, glFormat)</p>\n<p>&lt;!--\n<em>syntax: loadData(*data, w, h, glFormat)</em>\n<em>name: loadData</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const int16_t *data, int w, int h, int glFormat</em>\n<em>access: public</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void loadData(*data, w, h, glFormat)</p>\n<p>&lt;!--\n<em>syntax: loadData(*data, w, h, glFormat)</em>\n<em>name: loadData</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const int32_t *data, int w, int h, int glFormat</em>\n<em>access: public</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void loadData(*data, w, h, glFormat)</p>\n<p>&lt;!--\n<em>syntax: loadData(*data, w, h, glFormat)</em>\n<em>name: loadData</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const float *data, int w, int h, int glFormat</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Load float pixel data.</p>\n<p><strong>See also</strong>: loadData(const unsigned char* const data, int w, int h, int glFormat)</p>\n<p><strong>Parameters:</strong></p>\n<p>data Pointer to byte pixel data. Must not be nullptr.</p>\n<p>w Pixel data width.</p>\n<p>h Pixel data height.</p>\n<p>glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void loadData(*data, w, h, glFormat, glType)</p>\n<p>&lt;!--\n<em>syntax: loadData(*data, w, h, glFormat, glType)</em>\n<em>name: loadData</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const void *data, int w, int h, int glFormat, int glType</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Load byte pixel data.</p>\n<p>glFormat can be different to the internal format of the texture on each\nload, i.e. we can upload GL_BGRA pixels into a GL_RGBA texture but the\nnumber of channels need to match according to the OpenGL standard.</p>\n<p><strong>Parameters:</strong></p>\n<p>data Pointer to byte pixel data. Must not be nullptr.</p>\n<p>w Pixel data width.</p>\n<p>h Pixel data height.</p>\n<p>glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.</p>\n<p>glType the OpenGL type of the data.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void loadData(data, w, h, glFormat)</p>\n<p>&lt;!--\n<em>syntax: loadData(data, w, h, glFormat)</em>\n<em>name: loadData</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const uint8_t *const data, int w, int h, int glFormat</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Load byte pixel data.</p>\n<p>glFormat can be different to the internal format of the texture on each\nload, i.e. we can upload GL_BGRA pixels into a GL_RGBA texture but the\nnumber of channels need to match according to the OpenGL standard.</p>\n<p><strong>Parameters:</strong></p>\n<p>data Pointer to byte pixel data. Must not be nullptr.</p>\n<p>w Pixel data width.</p>\n<p>h Pixel data height.</p>\n<p>glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void loadScreenData(x, y, w, h)</p>\n<p>&lt;!--\n<em>syntax: loadScreenData(x, y, w, h)</em>\n<em>name: loadScreenData</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: int x, int y, int w, int h</em>\n<em>access: public</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Copy an area of the screen into this texture.</p>\n<p>Specifiy the position (x,y) you wish to grab from, with the width (w)\nand height (h) of the region.</p>\n<p>Make sure that you have allocated your texture (using <code><span class=\"token function\">allocate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code>)\nto be large enough to hold the region of the screen you wish to load.</p>\n<p><strong>See also</strong>: http://www.opengl.org/sdk/docs/man4/html/glCopyTexSubImage2D.xhtml</p>\n<p><strong>Parameters:</strong></p>\n<p>x Upper left corner horizontal screen position.</p>\n<p>y Upper left corner vertical screen position.</p>\n<p>w Width of the area to copy in pixels.</p>\n<p>h Height of the area to copy in pixels.</p>\n<p>_description: _</p>\n<p>Grabs a region of the screen and loads it into the texture. Specifiy the position (x,y) you wish to grab from, with the width (w) and height (h) of the region. Make sure that you have allocated your texture (using allocate()) to be large enough to hold the region of the screen you wish to load.\nLoad data from the current screen into this texture. Grabs a region of the screen and loads it into the texture. Specifiy the position (x,y) you wish to grab from, with the width (w) and height (h) of the region. Make sure that you have allocated your texture (using allocate()) to be large enough to hold the region of the screen you wish to load.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<h3>ofTexture(&amp;&amp;mom)</h3>\n<p>&lt;!--\n<em>syntax: ofTexture(&amp;&amp;mom)</em>\n<em>name: ofTexture</em>\n_returns: _\n_returns_description: _\n<em>parameters: ofTexture &amp;&amp;mom</em>\n<em>access: public</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<h3>ofTexture(&amp;mom)</h3>\n<p>&lt;!--\n<em>syntax: ofTexture(&amp;mom)</em>\n<em>name: ofTexture</em>\n_returns: _\n_returns_description: _\n<em>parameters: const ofTexture &amp;mom</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Construct an ofTexture from an existing ofTexture.</p>\n<p><strong>Parameters:</strong></p>\n<p>mom The ofTexture to copy. Reuses internal GL texture ID.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<h3>ofTexture()</h3>\n<p>&lt;!--\n<em>syntax: ofTexture()</em>\n<em>name: ofTexture</em>\n_returns: _\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: False</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>\\section Construction and Allocation\nConstruct an ofTexture instance.</p>\n<p>_description: _</p>\n<p>Creates an empty ofTexture instance. You can't draw a texture right after it's been created as it has actually uploaded any data to the graphics card that can be drawn yet.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###ofTexture &amp; operator=(&amp;&amp;mom)</p>\n<p>&lt;!--\n<em>syntax: operator=(&amp;&amp;mom)</em>\n<em>name: operator=</em>\n<em>returns: ofTexture &amp;</em>\n_returns_description: _\n<em>parameters: ofTexture &amp;&amp;mom</em>\n<em>access: public</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###ofTexture &amp; operator=(&amp;mom)</p>\n<p>&lt;!--\n<em>syntax: operator=(&amp;mom)</em>\n<em>name: operator=</em>\n<em>returns: ofTexture &amp;</em>\n_returns_description: _\n<em>parameters: const ofTexture &amp;mom</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>\\section Update Texture\nCopy a given ofTexture into this texture.</p>\n<p><strong>Parameters:</strong></p>\n<p>mom The ofTexture to copy from. Reuses internal GL texture ID.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void readToPixels(&amp;pixels)</p>\n<p>&lt;!--\n<em>syntax: readToPixels(&amp;pixels)</em>\n<em>name: readToPixels</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: ofPixels &amp;pixels</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>\\section Read Pixel Data\nRead current texture data from the GPU into pixels.</p>\n<p><strong>Warning</strong>: This is not supported in OpenGL ES and does nothing.</p>\n<p><strong>Parameters:</strong></p>\n<p>pixels Target ofPixels reference.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void readToPixels(&amp;pixels)</p>\n<p>&lt;!--\n<em>syntax: readToPixels(&amp;pixels)</em>\n<em>name: readToPixels</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: ofShortPixels &amp;pixels</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Read current texture data from the GPU into pixels.</p>\n<p><strong>Warning</strong>: This is not supported in OpenGL ES and does nothing.</p>\n<p><strong>Parameters:</strong></p>\n<p>pixels Target pixels reference.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void readToPixels(&amp;pixels)</p>\n<p>&lt;!--\n<em>syntax: readToPixels(&amp;pixels)</em>\n<em>name: readToPixels</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: ofFloatPixels &amp;pixels</em>\n<em>access: public</em>\n<em>version_started: 007</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Read current texture data from the GPU into pixels.</p>\n<p><strong>Warning</strong>: This is not supported in OpenGL ES and does nothing.</p>\n<p><strong>Parameters:</strong></p>\n<p>pixels Target pixels reference.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void resetAnchor()</p>\n<p>&lt;!--\n<em>syntax: resetAnchor()</em>\n<em>name: resetAnchor</em>\n<em>returns: void</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Reset the anchor point to (0, 0).</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setAlphaMask(&amp;mask)</p>\n<p>&lt;!--\n<em>syntax: setAlphaMask(&amp;mask)</em>\n<em>name: setAlphaMask</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: ofTexture &amp;mask</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>\\section Texture Settings\nSet another ofTexture to use as an alpha mask.</p>\n<p><strong>Parameters:</strong></p>\n<p>mask The texture to use as alpha mask.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setAnchorPercent(xPct, yPct)</p>\n<p>&lt;!--\n<em>syntax: setAnchorPercent(xPct, yPct)</em>\n<em>name: setAnchorPercent</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: float xPct, float yPct</em>\n<em>access: public</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Set the anchor point the texture is drawn around as a percentage.</p>\n<p>This can be useful if you want to rotate an image around a particular\npoint.</p>\n<p><strong>Parameters:</strong></p>\n<p>xPct Horizontal texture position as a percentage (0 - 1).</p>\n<p>yPct Vertical texture position as a percentage (0 - 1).</p>\n<p>_description: _</p>\n<p>The anchor is the point the image is drawn around. This can be useful if you want to rotate an image around a particular point, allowing you to set the anchor as a percentage of the image width/height ( 0.0-1.0 range )</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setAnchorPoint(x, y)</p>\n<p>&lt;!--\n<em>syntax: setAnchorPoint(x, y)</em>\n<em>name: setAnchorPoint</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: float x, float y</em>\n<em>access: public</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Set the anchor point the texture is drawn around in pixels.</p>\n<p>This can be useful if you want to rotate an image around a particular\npoint.</p>\n<p><strong>Parameters:</strong></p>\n<p>x Horizontal texture position in pixels.</p>\n<p>y Vertical texture position in pixels.</p>\n<p>_description: _</p>\n<p>set the anchor point in pixels</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setCompression(compression)</p>\n<p>&lt;!--\n<em>syntax: setCompression(compression)</em>\n<em>name: setCompression</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: ofTexCompression compression</em>\n<em>access: public</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Set the texture compression.</p>\n<p>\\warning: not yet implemented.</p>\n<p><strong>See also</strong>: ofTexCompression</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setRGToRGBASwizzles(rToRGBSwizzles)</p>\n<p>&lt;!--\n<em>syntax: setRGToRGBASwizzles(rToRGBSwizzles)</em>\n<em>name: setRGToRGBASwizzles</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: bool rToRGBSwizzles</em>\n<em>access: public</em>\n<em>version_started: 0073</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>\\todo Define Swizzle in the documentation.\nSwizzle RGBA to grayscale with alpha in the red channel.</p>\n<p>Use 1 channel GL_R as luminance instead of red channel in OpenGL 3+.</p>\n<p><strong>Warning</strong>: This is not supported in OpenGL ES and does nothing.</p>\n<p><strong>See also</strong>: https://en.wikipedia.org/wiki/Swizzling_(computer_graphics)</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setSwizzle(srcSwizzle, dstChannel)</p>\n<p>&lt;!--\n<em>syntax: setSwizzle(srcSwizzle, dstChannel)</em>\n<em>name: setSwizzle</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: GLenum srcSwizzle, GLenum dstChannel</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Swizzle a channel to another</p>\n<p>Example:</p>\n<pre><code>ofTexture tex<span class=\"token punctuation\">;</span>\ntex<span class=\"token punctuation\">.</span><span class=\"token function\">setSwizzle</span><span class=\"token punctuation\">(</span>GL_TEXTURE_SWIZZLE_R<span class=\"token punctuation\">,</span>GL_ALPHA<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>will make channel 0 appear as alpha in the shader.</p>\n<p><strong>Warning</strong>: This is not supported in OpenGL ES and does nothing.</p>\n<p><strong>See also</strong>: https://en.wikipedia.org/wiki/Swizzling_(computer_graphics)</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setTextureMatrix(&amp;m)</p>\n<p>&lt;!--\n<em>syntax: setTextureMatrix(&amp;m)</em>\n<em>name: setTextureMatrix</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const glm::mat4 &amp;m</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Sets a texture matrix to be uploaded whenever the texture is bound.</p>\n<p><strong>Parameters:</strong></p>\n<p>m The 4x4 texture matrix.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setTextureMinMagFilter(minFilter, magFilter)</p>\n<p>&lt;!--\n<em>syntax: setTextureMinMagFilter(minFilter, magFilter)</em>\n<em>name: setTextureMinMagFilter</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: GLint minFilter, GLint magFilter</em>\n<em>access: public</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Set texture minification/magnification scaling filters.</p>\n<p>Controls how OpenGL will scale this texture.</p>\n<p><strong>See also</strong>: http://www.opengl.org/sdk/docs/man4/html/glTexParameter.xhtml</p>\n<p><strong>See also</strong>: ofTextureSetMinMagFilters()</p>\n<p><strong>Warning</strong>: May be overridden.</p>\n<p><strong>Parameters:</strong></p>\n<p>minFilter minifying filter for scaling a pixel to a smaller area.</p>\n<p>magFilter magnifying filter for scaling a pixel to a larger area.</p>\n<p>_description: _</p>\n<p>Set how the texture is scaled up and down, when it's being drawn larger or smaller than it's actual size.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setTextureWrap(wrapModeHorizontal, wrapModeVertical)</p>\n<p>&lt;!--\n<em>syntax: setTextureWrap(wrapModeHorizontal, wrapModeVertical)</em>\n<em>name: setTextureWrap</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: GLint wrapModeHorizontal, GLint wrapModeVertical</em>\n<em>access: public</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Set texture wrapping.</p>\n<p>By default, textures are clamped to their edges with <code>GL_CLAMP_TO_EDGE</code>.\nSetting a repeat mode like <code>GL_REPEAT</code> allows you to create tiled\nbackgrounds with small textures.</p>\n<p><strong>See also</strong>: ofTextureSetWrap()</p>\n<p><strong>See also</strong>: http://www.opengl.org/sdk/docs/man4/html/glTexParameter.xhtml</p>\n<p><strong>Warning</strong>: May be overridden.</p>\n<p><strong>Parameters:</strong></p>\n<p>wrapModeHorizontal wrap parameter for texture coordinate s.</p>\n<p>wrapModeVertical wrap parameter for texture coordinate t.</p>\n<p>_description: _</p>\n<p>Sets how the texture wraps around the edges of the vertices that the texture is being drawn to.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setUseExternalTextureID(externTexID)</p>\n<p>&lt;!--\n<em>syntax: setUseExternalTextureID(externTexID)</em>\n<em>name: setUseExternalTextureID</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: GLuint externTexID</em>\n<em>access: public</em>\n<em>version_started: 0072</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Set the texture ID.</p>\n<p>Allows you to point the texture id to an externally allocated id\n(perhaps from another texture). It's up to you to set the rest of the\ntextData parameters manually.</p>\n<p><strong>Warning</strong>: When setting an external texture ID, the user must set the\nremaining ofTextureData parameters manually.</p>\n<p><strong>Parameters:</strong></p>\n<p>externTexID New texture ID.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void unbind(textureLocation = 0)</p>\n<p>&lt;!--\n<em>syntax: unbind(textureLocation = 0)</em>\n<em>name: unbind</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: int textureLocation=0</em>\n<em>access: public</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Unbind the texture.</p>\n<p>For advanced users who need to manually manage texture drawing without\ncalling ofTexture::draw.</p>\n<p><strong>See also</strong>: http://www.opengl.org/sdk/docs/man4/html/glBindTexture.xhtml</p>\n<p>_description: _</p>\n<p>This for the advanced user who wants to draw textures in their own way. This stops vertices from being textured using this texture.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<h3>~ofTexture()</h3>\n<p>&lt;!--\n<em>syntax: ~ofTexture()</em>\n<em>name: ~ofTexture</em>\n_returns: _\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: False</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Destroy an ofTexture instance.</p>\n<p>ofTexture keeps a reference count for the internal OpenGL texture ID.\nThus, the texture ID is only released if there are no additional\nreferences to the internal texture ID.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>##Variables</p>\n<p>###ofPoint anchor</p>\n<p>&lt;!--\n<em>name: anchor</em>\n<em>type: ofPoint</em>\n<em>access: protected</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>visible: True</em>\n<em>constant: False</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>&lt; The texture's anchor point.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool bAnchorIsPct</p>\n<p>&lt;!--\n<em>name: bAnchorIsPct</em>\n<em>type: bool</em>\n<em>access: protected</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>visible: True</em>\n<em>constant: False</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>&lt; Is the anchor point represented as a normalized\n&lt; (0 - 1) coordinate?</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool bWantsMipmap</p>\n<p>&lt;!--\n<em>name: bWantsMipmap</em>\n<em>type: bool</em>\n<em>access: private</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>visible: True</em>\n<em>constant: False</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>&lt; Should mipmaps be created?</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###ofTextureData texData</p>\n<p>&lt;!--\n<em>name: texData</em>\n<em>type: ofTextureData</em>\n<em>access: public</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>visible: True</em>\n<em>constant: False</em>\n<em>advanced: True</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>&lt; Internal texture data access.\n&lt; For backwards compatibility.</p>\n<p>_description: _</p>\n<p>texData is a variable type ofTextureData. ofTextureData is a structure containing information about the texture such as size.</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n","raw":"#class ofTexture\n\n\n<!--\n_visible: True_\n_advanced: False_\n_istemplated: False_\n_extends: ofBaseDraws_\n-->\n\n##InlineDescription\n\n\nA wrapper class for an OpenGL texture.\n\n\n\n\n\n##Description\n\nofTexture is used to create textures that live on your graphics card from bitmap data that can then be used to fill other drawn objects, like a bitmap fill on a rectangle. When you draw an ofImage, you're actually just drawing a rectangle of points and then using an ofTexture to fill the space between those points. At it's core, ofTexture is a wrapper for OpenGL textures. It allows use of non-power of 2 textures in opengl, and to upload and draw graphical data.\n\n\n\n\n\n##Methods\n\n\n\n###void allocate(&pix)\n\n<!--\n_syntax: allocate(&pix)_\n_name: allocate_\n_returns: void_\n_returns_description: _\n_parameters: const ofPixels &pix_\n_access: public_\n_version_started: 0071_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nAllocate texture using an ofPixels instance.\n\nPixel type and OpenGL format are determined from pixel settings.\n\n\n**Parameters:**\n\npix Reference to ofPixels instance.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void allocate(&pix)\n\n<!--\n_syntax: allocate(&pix)_\n_name: allocate_\n_returns: void_\n_returns_description: _\n_parameters: const ofShortPixels &pix_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nAllocate texture using an ofShortPixels instance.\n\nSame as void allocate(const ofPixels& pix), except using ofShortPixels.\n\n\n**See also**: allocate(const ofPixels& pix)\n\n**Parameters:**\n\npix Reference to ofShortPixels instance.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void allocate(&pix)\n\n<!--\n_syntax: allocate(&pix)_\n_name: allocate_\n_returns: void_\n_returns_description: _\n_parameters: const ofFloatPixels &pix_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nAllocate texture using an ofFloatPixels instance.\n\nSame as void allocate(const ofPixels& pix), except using ofFloatPixels.\n\n\n**See also**: allocate(const ofPixels& pix)\n\n**Parameters:**\n\npix Reference to ofFloatPixels instance.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void allocate(&pix, bUseARBExtension)\n\n<!--\n_syntax: allocate(&pix, bUseARBExtension)_\n_name: allocate_\n_returns: void_\n_returns_description: _\n_parameters: const ofPixels &pix, bool bUseARBExtension_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nAllocate texture using an ofPixels instance and type.\n\nThis lets you overide the default OF texture type in case you need a\nsquare GL_TEXTURE_2D texture.\n\n\n**Warning**: ARB textures are not available in OpenGL ES.\n\n**See also**: ofEnableArbTex()\n\n**See also**: allocate(const ofPixels& pix)\n\n**Parameters:**\n\npix Reference to ofPixels instance.\n\nbUseARBExtension Set to true to use rectangular textures.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void allocate(&pix, bUseARBExtension)\n\n<!--\n_syntax: allocate(&pix, bUseARBExtension)_\n_name: allocate_\n_returns: void_\n_returns_description: _\n_parameters: const ofShortPixels &pix, bool bUseARBExtension_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nAllocate texture using an ofShortPixels instance and type.\n\nSame as void void allocate(const ofPixels& pix), except using ofShortPixels.\n\n\n**See also**: allocate(const ofShortPixels& pix)\n\n**Parameters:**\n\npix Reference to ofShortPixels instance.\n\nbUseARBExtension Set to true to use rectangular textures.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void allocate(&pix, bUseARBExtension)\n\n<!--\n_syntax: allocate(&pix, bUseARBExtension)_\n_name: allocate_\n_returns: void_\n_returns_description: _\n_parameters: const ofFloatPixels &pix, bool bUseARBExtension_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nAllocate texture using an ofShortPixels instance and type.\n\nSame as void void allocate(const ofPixels& pix), except using ofShortPixels.\n\n\n**See also**: allocate(const ofFloatPixels& pix)\n\n**Parameters:**\n\npix Reference to ofFloatPixels instance.\n\nbUseARBExtension Set to true to use rectangular textures.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void allocate(&textureData)\n\n<!--\n_syntax: allocate(&textureData)_\n_name: allocate_\n_returns: void_\n_returns_description: _\n_parameters: const ofTextureData &textureData_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nAllocate the texture using the given settings.\n\nThis is useful if you need manual control over loading a number of\ntextures with the same settings. Make sure to set the texture data\nparameters first.\n\n\n**Parameters:**\n\ntextureData The settings to use when allocating the ofTexture.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void allocate(&textureData, glFormat, pixelType)\n\n<!--\n_syntax: allocate(&textureData, glFormat, pixelType)_\n_name: allocate_\n_returns: void_\n_returns_description: _\n_parameters: const ofTextureData &textureData, int glFormat, int pixelType_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nAllocate the texture using the given settings and custom format.\n\n**Parameters:**\n\ntextureData The settings to use when allocating the ofTexture.\n\nglFormat GL texture format: GL_RGBA, GL_LUMINANCE, etc.\n\npixelType GL pixel type: GL_UNSIGNED_BYTE, GL_FLOAT, etc.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void allocate(w, h, glInternalFormat)\n\n<!--\n_syntax: allocate(w, h, glInternalFormat)_\n_name: allocate_\n_returns: void_\n_returns_description: _\n_parameters: int w, int h, int glInternalFormat_\n_access: public_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nAllocate texture of a given size and format.\n\nThe width (w) and height (h) do not necessarily need to be powers of 2,\nbut they do need to be large enough to contain the data you will upload\nto the texture.\n\nThe internal data type `glFormat` describes how OpenGL will store this\ntexture internally. For example, if you want a grayscale texture, you\ncan use `GL_LUMINANCE`. You can upload what ever type of data you want\n(using `loadData()`) but internally, opengl will store the information\nas grayscale. Other types include: `GL_RGB`, `GL_RGBA`.\n\nThis method applies the currently set OF texture type and defaults to\nARB rectangular textures if they are supported. (They are not supported\non OpenGL ES).\n\n\n**Parameters:**\n\nw Desired width in pixels.\n\nh Desired height in pixels.\n\nglInternalFormat OpenGL internal data format: `GL_RGBA`, `GL_LUMINANCE`, etc.\n\n\n\n\n\n_description: _\n\nThis is the call to allocate opengl texture. The width (w) and height (h) do not necessarily need to be powers of 2, but they do need to be large enough to contain the data you will upload to the texture.  The internal data type describes how opengl will store this texture internally. For example, if you want a grayscale texture, you can use \"GL_LUMINANCE\". You can uplaod what ever type of data you want (using loadData()) but internally, opengl will store the information as grayscale. Other types include: GL_RGB, GL_RGBA.\nYou need to allocate the texture before drawing it or loading data into it.\nuses the currently set OF texture type - default ARB texture\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void allocate(w, h, glInternalFormat, bUseARBExtension)\n\n<!--\n_syntax: allocate(w, h, glInternalFormat, bUseARBExtension)_\n_name: allocate_\n_returns: void_\n_returns_description: _\n_parameters: int w, int h, int glInternalFormat, bool bUseARBExtension_\n_access: public_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nAllocate texture of a given size and format. Specify texture type.\n\nThis allows to enable the ARBE extension for this texture.\nThis will overide the default OF texture type, in case you need a\nsquare texture (`GL_TEXTURE_2D`).\n\n\n**Warning**: ARB textures are not available in OpenGL ES.\n\n**See also**: ofEnableArbTex()\n\n**See also**: allocate(int w, int h, int glInternalFormat)\n\n**Parameters:**\n\nw Desired width in pixels.\n\nh Desired height in pixels.\n\nglInternalFormat The internal openGL format.\n\nbUseARBExtension Set to true to use rectangular textures.\n\n\n\n\n\n_description: _\n\nSee previous allocate for knowing the behaviour of this function. The parameter bUseARBEExtension allow the user to enable the ARBE extension for this texture.\nYou need to allocate the texture before drawing it or loading data into it, lets you overide the default OF texture type\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void allocate(w, h, glInternalFormat, bUseARBExtension, glFormat, pixelType)\n\n<!--\n_syntax: allocate(w, h, glInternalFormat, bUseARBExtension, glFormat, pixelType)_\n_name: allocate_\n_returns: void_\n_returns_description: _\n_parameters: int w, int h, int glInternalFormat, bool bUseARBExtension, int glFormat, int pixelType_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nAllocate texture of a given size, format, & type.\n\n\n**See also**: allocate(int w, int h, int glInternalFormat)\n\n**Parameters:**\n\nw Desired width in pixels.\n\nh Desired height in pixels.\n\nglInternalFormat OpenGL data format: `GL_RGBA`, `GL_LUMINANCE`, etc.\n\nbUseARBExtension Set to true to use rectangular textures.\n\nglFormat The OpenGL format.\n\npixelType OpenGL pixel type: `GL_UNSIGNED_BYTE`, `GL_FLOAT`, etc.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void allocate(w, h, glInternalFormat, glFormat, pixelType)\n\n<!--\n_syntax: allocate(w, h, glInternalFormat, glFormat, pixelType)_\n_name: allocate_\n_returns: void_\n_returns_description: _\n_parameters: int w, int h, int glInternalFormat, int glFormat, int pixelType_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nAllocate texture of a given size and format.\n\n\n**See also**: allocate(int w, int h, int glInternalFormat)\n\n**Parameters:**\n\nw Desired width in pixels.\n\nh Desired height in pixels.\n\nglInternalFormat The internal openGL format.\n\nglFormat The openGL format.\n\npixelType GL pixel type: GL_UNSIGNED_BYTE, GL_FLOAT, etc.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void allocateAsBufferTexture(&buffer, glInternalFormat)\n\n<!--\n_syntax: allocateAsBufferTexture(&buffer, glInternalFormat)_\n_name: allocateAsBufferTexture_\n_returns: void_\n_returns_description: _\n_parameters: const ofBufferObject &buffer, int glInternalFormat_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nAllocate texture as a Buffer Texture.\n\nUses a GPU buffer as data for the texture instead of pixels in RAM\nAllows to use texture buffer objects (TBO) which make it easier to send big\namounts of data to a shader as a uniform.\n\nBuffer textures are 1D textures, and may only be sampled using texelFetch\nin GLSL.\n\nSee textureBufferInstanceExample and https://www.opengl.org/wiki/Buffer_Texture\n\n\n**See also**: allocate(const ofBufferObject & buffer, int glInternalFormat)\n\n**Parameters:**\n\nbuffer Reference to ofBufferObject instance.\n\nglInternalFormat Internal pixel format of the data.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void bind(textureLocation = 0)\n\n<!--\n_syntax: bind(textureLocation = 0)_\n_name: bind_\n_returns: void_\n_returns_description: _\n_parameters: int textureLocation=0_\n_access: public_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nBind the texture.\n\nFor advanced users who need to manually manage texture drawing without\ncalling ofTexture::draw.\n\n\n**See also**: http://www.opengl.org/sdk/docs/man4/html/glBindTexture.xhtml\n\n\n\n\n\n_description: _\n\nThis is for the advanced user who wants to draw textures in their own way. Each set of vertices that you draw after calling bind() will be textured using this texture.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void bindAsImage(unit, access, level = 0, layered, layer = 0)\n\n<!--\n_syntax: bindAsImage(unit, access, level = 0, layered, layer = 0)_\n_name: bindAsImage_\n_returns: void_\n_returns_description: _\n_parameters: GLuint unit, GLenum access, GLint level=0, GLboolean layered, GLint layer=0_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCalls glBindImageTexture on the texture\n\nBinds the texture as an read or write image, only available since OpenGL 4.2\n\n**Warning**: This is not available in OpenGLES\n\n**See also**: http://www.opengl.org/wiki/GLAPI/glBindImageTexture\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void clear()\n\n<!--\n_syntax: clear()_\n_name: clear_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nClears the texture.\n\nClears / frees the texture memory, if something was already allocated.\nUseful if you need to control the memory on the graphics card.\n\nThe internal GL texture ID is only released if this is the last texture\nusing it.\n\n\n\n\n\n_description: _\n\nclears / frees the texture memory, if something was already allocated. useful if you need to control the memory on the graphics card.\nClears all the data from the texture\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void copyTo(&buffer)\n\n<!--\n_syntax: copyTo(&buffer)_\n_name: copyTo_\n_returns: void_\n_returns_description: _\n_parameters: ofBufferObject &buffer_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCopy the texture to an ofBufferObject.\n\n**Parameters:**\n\nbuffer the target buffer to copy to.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void disableAlphaMask()\n\n<!--\n_syntax: disableAlphaMask()_\n_name: disableAlphaMask_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nDisable the alpha mask.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void disableMipmap()\n\n<!--\n_syntax: disableMipmap()_\n_name: disableMipmap_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nSets flag disallowing texture to auto-generate mipmap.\n\nBy default, this will set your minFilter to GL_LINEAR_MIPMAP_LINEAR.\nIf you want to change your minFilter later use setTextureMinMagFilter()\n\n\tIf you want to generate a mipmap later, or at a specific\npoint in your code, use ofTexture::generateMipmap() instead.\n\n\n**See also**: generateMipmap()\n\n**See also**: enableMipmap()\n\n**See also**: setTextureMinMagFilter()\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void disableTextureMatrix()\n\n<!--\n_syntax: disableTextureMatrix()_\n_name: disableTextureMatrix_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nDisable the texture matrix.\nDisable the texture matrix.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void disableTextureTarget(textureLocation)\n\n<!--\n_syntax: disableTextureTarget(textureLocation)_\n_name: disableTextureTarget_\n_returns: void_\n_returns_description: _\n_parameters: int textureLocation_\n_access: protected_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nDisable a texture target.\n\n**Parameters:**\n\ntextureLocation the OpenGL texture ID to enable as a target.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void draw(&p1, &p2, &p3, &p4)\n\n<!--\n_syntax: draw(&p1, &p2, &p3, &p4)_\n_name: draw_\n_returns: void_\n_returns_description: _\n_parameters: const glm::vec3 &p1, const glm::vec3 &p2, const glm::vec3 &p3, const glm::vec3 &p4_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nDraws the texture at 4 points passed in as if you created 4 glVertices.\n\n\n**Parameters:**\n\np1 Upper left position on the x axis.\n\np2 Upper left position on the y axis.\n\np3 Lower right position on the x axis.\n\np4 Lower right position on the y axis.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void draw(&pos)\n\n<!--\n_syntax: draw(&pos)_\n_name: draw_\n_returns: void_\n_returns_description: _\n_parameters: const glm::vec3 &pos_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void draw(&pos, w, h)\n\n<!--\n_syntax: draw(&pos, w, h)_\n_name: draw_\n_returns: void_\n_returns_description: _\n_parameters: const glm::vec3 &pos, float w, float h_\n_access: public_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nDraws the texture at 4 points passed in as if you created 4 glVertices.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void draw(x, y)\n\n<!--\n_syntax: draw(x, y)_\n_name: draw_\n_returns: void_\n_returns_description: _\n_parameters: float x, float y_\n_access: public_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\\section Drawing\n\n\n\n\n\n_description: _\n\nDraws the texture at a given point (x,y), using the textures true width and height.\nDraws the texture at the point passed in.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void draw(x, y, w, h)\n\n<!--\n_syntax: draw(x, y, w, h)_\n_name: draw_\n_returns: void_\n_returns_description: _\n_parameters: float x, float y, float w, float h_\n_access: public_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\ndraws the texture at a given point (x,y), with a given width (w) and height (h).\nDraws the texture at the x, y and w, h.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void draw(x, y, z)\n\n<!--\n_syntax: draw(x, y, z)_\n_name: draw_\n_returns: void_\n_returns_description: _\n_parameters: float x, float y, float z_\n_access: public_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\nDraws the texture at the point passed in in 3D space.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void draw(x, y, z, w, h)\n\n<!--\n_syntax: draw(x, y, z, w, h)_\n_name: draw_\n_returns: void_\n_returns_description: _\n_parameters: float x, float y, float z, float w, float h_\n_access: public_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nDraw the texture at a given size witdh and depth.\n\n\n**Parameters:**\n\nx Draw position on the x axis.\n\ny Draw position on the y axis.\n\nz Draw position on the z axis.\n\nw Draw width.\n\nh Draw height.\n\n\n\n\n\n_description: _\n\nDraws the texture at the x, y, z in 3D space with the width and height at w,h.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void drawSubsection(&drawBounds, &subsectionBounds)\n\n<!--\n_syntax: drawSubsection(&drawBounds, &subsectionBounds)_\n_name: drawSubsection_\n_returns: void_\n_returns_description: _\n_parameters: const ofRectangle &drawBounds, const ofRectangle &subsectionBounds_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nDraw a subsection of the texture with an offset.\n\n\n**See also**: drawSubsection(ofRectangle& drawBounds, ofRectangle& subsectionBounds)\n\n**Parameters:**\n\ndrawBounds Draw position and dimensions.\n\nsubsectionBounds Subsection position and dimensions within the texture.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void drawSubsection(x, y, w, h, sx, sy)\n\n<!--\n_syntax: drawSubsection(x, y, w, h, sx, sy)_\n_name: drawSubsection_\n_returns: void_\n_returns_description: _\n_parameters: float x, float y, float w, float h, float sx, float sy_\n_access: public_\n_version_started: 0071_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nDraw a subsection of the texture.\n\nLike ofRect() depend on the current `OF_RECT_MODE`:\n\n* `OF_RECT_MODE_CORNER`: drawn with the upper left corner = (x,y)\n* `OF_RECT_MODE_CENTER`: drawn centered on (x,y)\n\n\n**See also**: ofSetRectMode()\n\n\n**Parameters:**\n\nx Draw position on the x axis.\n\ny Draw position on the y axis.\n\nw Draw width.\n\nh Draw height.\n\nsx Subsection x axis offset within the texture.\n\nsy Subsection y axis offset within the texture.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void drawSubsection(x, y, w, h, sx, sy, sw, sh)\n\n<!--\n_syntax: drawSubsection(x, y, w, h, sx, sy, sw, sh)_\n_name: drawSubsection_\n_returns: void_\n_returns_description: _\n_parameters: float x, float y, float w, float h, float sx, float sy, float sw, float sh_\n_access: public_\n_version_started: 0071_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nDraw a subsection of the texture with an offset.\n\n\n**See also**: drawSubsection(float x, float y, float w, float h, float sx, float sy)\n\n**Parameters:**\n\nx Draw position on the x axis.\n\ny Draw position on the y axis.\n\nw Draw width.\n\nh Draw height.\n\nsx Subsection x axis offset within the texture.\n\nsy Subsection y axis offset within the texture.\n\nsw Subsection width within the texture.\n\nsh Subsection height within the texture.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void drawSubsection(x, y, z, w, h, sx, sy)\n\n<!--\n_syntax: drawSubsection(x, y, z, w, h, sx, sy)_\n_name: drawSubsection_\n_returns: void_\n_returns_description: _\n_parameters: float x, float y, float z, float w, float h, float sx, float sy_\n_access: public_\n_version_started: 0071_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nDraw a subsection of the texture with depth.\n\n\n**See also**: drawSubsection(float x, float y, float w, float h, float sx, float sy)\n\n**Parameters:**\n\nx Draw position on the x axis.\n\ny Draw position on the y axis.\n\nz Draw position on the z axis.\n\nw Draw width.\n\nh Draw height.\n\nsx Subsection x axis offset within the texture.\n\nsy Subsection y axis offset within the texture.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void drawSubsection(x, y, z, w, h, sx, sy, sw, sh)\n\n<!--\n_syntax: drawSubsection(x, y, z, w, h, sx, sy, sw, sh)_\n_name: drawSubsection_\n_returns: void_\n_returns_description: _\n_parameters: float x, float y, float z, float w, float h, float sx, float sy, float sw, float sh_\n_access: public_\n_version_started: 0071_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nDraw a subsection of the texture with an offset and depth.\n\n\n**See also**: drawSubsection(float x, float y, float w, float h, float sx, float sy)\n\n**Parameters:**\n\nx Draw position on the x axis.\n\ny Draw position on the y axis.\n\nz Draw position on the z axis.\n\nw Draw width.\n\nh Draw height.\n\nsx Subsection x axis offset within the texture.\n\nsy Subsection y axis offset within the texture.\n\nsw Subsection width within the texture.\n\nsh Subsection height within the texture.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void enableMipmap()\n\n<!--\n_syntax: enableMipmap()_\n_name: enableMipmap_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\\section Mipmapping\nSets flag allowing texture to auto-generate a mipmap.\n\nBy default, this will set your minFilter to GL_LINEAR_MIPMAP_LINEAR.\nIf you want to change your minFilter later use setTextureMinMagFilter()\n\n\tIf you want to generate a mipmap later, or at a specific\npoint in your code, use generateMipmap() instead.\n\n\n**See also**: generateMipmap()\n\n**See also**: disableMipmap()\n\n**See also**: setTextureMinMagFilter()\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void enableTextureTarget(textureLocation)\n\n<!--\n_syntax: enableTextureTarget(textureLocation)_\n_name: enableTextureTarget_\n_returns: void_\n_returns_description: _\n_parameters: int textureLocation_\n_access: protected_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nEnable a texture target.\n\n**Parameters:**\n\ntextureLocation the OpenGL texture ID to enable as a target.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void generateMipmap()\n\n<!--\n_syntax: generateMipmap()_\n_name: generateMipmap_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nGenerate mipmap for the current texture.\n\n\n**Warning**: Only GL_TEXTURE_RECTANGLE - which is the default openFrameworks\ntexture target - does *not* support mipmaps, so make sure to call\nofDisableArbTex() before loading texture\ndata for a texture you want to generate mipmaps for.\n\n\n**See also**: ofEnableArbTex()\n\n**See also**: ofDisableArbTex()\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###const ofTexture * getAlphaMask()\n\n<!--\n_syntax: getAlphaMask()_\n_name: getAlphaMask_\n_returns: const ofTexture *_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###glm::vec2 getCoordFromPercent(xPts, yPts)\n\n<!--\n_syntax: getCoordFromPercent(xPts, yPts)_\n_name: getCoordFromPercent_\n_returns: glm::vec2_\n_returns_description: _\n_parameters: float xPts, float yPts_\n_access: public_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nHelper to convert display coordinate to texture coordinate.\n\n**Parameters:**\n\nxPts Horizontal position in a normalized percentage (0 - 1).\n\nyPts Vertical position in a normalized percentage (0 - 1).\n\n**Returns**: Texture coordinate or zero if texture is not allocated.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###glm::vec2 getCoordFromPoint(xPos, yPos)\n\n<!--\n_syntax: getCoordFromPoint(xPos, yPos)_\n_name: getCoordFromPoint_\n_returns: glm::vec2_\n_returns_description: _\n_parameters: float xPos, float yPos_\n_access: public_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nHelper to convert display coordinate to texture coordinate.\n\n**Parameters:**\n\nxPos Horizontal position in pixels.\n\nyPos Vertical position in pixels.\n\n**Returns**: Texture coordinate or zero if texture is not allocated.\n\n\n\n\n\n_description: _\n\nthese are helpers to allow you to get points for the texture ala \"glTexCoordf\" but are texture type independent. use them for immediate or non immediate mode\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float getHeight()\n\n<!--\n_syntax: getHeight()_\n_name: getHeight_\n_returns: float_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\\section Size and Coordinates\nDisplay height of texture.\n\nReturn value is pixel size (default) or normalized (0 - 1) if ofEnableNormalizedTextures() is set to true.\n\n\n**See also**: ofEnabledNormalizedTextures()\n\n\n**Returns**: Display height of texture in pixels.\n\n\n\n\n\n_description: _\n\nReturns the height of the texture. This will be in pixels unless you've set your application to use normalized coordinates.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###ofMesh getMeshForSubsection(x, y, z, w, h, sx, sy, sw, sh, vflipped, rectMode)\n\n<!--\n_syntax: getMeshForSubsection(x, y, z, w, h, sx, sy, sw, sh, vflipped, rectMode)_\n_name: getMeshForSubsection_\n_returns: ofMesh_\n_returns_description: _\n_parameters: float x, float y, float z, float w, float h, float sx, float sy, float sw, float sh, bool vflipped, ofRectMode rectMode_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nGet a mesh that has the texture coordinates set.\n\n\n**See also**: drawSubsection(float x, float y, float w, float h, float sx, float sy)\n\n**Parameters:**\n\nx Draw position on the x axis.\n\ny Draw position on the y axis.\n\nz Draw position on the z axis.\n\nw Draw width.\n\nh Draw height.\n\nsx Subsection x axis offset within the texture.\n\nsy Subsection y axis offset within the texture.\n\nsw Subsection width within the texture.\n\nsh Subsection height within the texture.\n\nvflipped Takes into account the flipped state in OF.\n\nrectMode rectMode Taking x,y as the center or the top left corner.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###ofMesh getQuad(&p1, &p2, &p3, &p4)\n\n<!--\n_syntax: getQuad(&p1, &p2, &p3, &p4)_\n_name: getQuad_\n_returns: ofMesh_\n_returns_description: _\n_parameters: const glm::vec3 &p1, const glm::vec3 &p2, const glm::vec3 &p3, const glm::vec3 &p4_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###ofTextureData & getTextureData()\n\n<!--\n_syntax: getTextureData()_\n_name: getTextureData_\n_returns: ofTextureData &_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.8.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\\section Texture Data\nInternal texture data access.\n\nThis returns the internal texture data for this texture, for instance,\nits textureID, type of texture, whether it's been allocated and other\ndata about the state of the texture.\n\n\n**Returns**: a reference to the internal texture data struct.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###const ofTextureData & getTextureData()\n\n<!--\n_syntax: getTextureData()_\n_name: getTextureData_\n_returns: const ofTextureData &_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nConst version of getTextureData().\n\n**See also**: ofTextureData::getTextureData()\n\n\n\n\n\n_description: _\n\nThis returns the internal texture data for this texture, for instance, its textureID, type of texture, whether it's been allocated, and other data about the state of the texture.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###const glm::mat4 & getTextureMatrix()\n\n<!--\n_syntax: getTextureMatrix()_\n_name: getTextureMatrix_\n_returns: const glm::mat4 &_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float getWidth()\n\n<!--\n_syntax: getWidth()_\n_name: getWidth_\n_returns: float_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nDisplay width of texture.\n\nReturn value is pixel size (default) or normalized (0 - 1) if ofEnableNormalizedTextures() is set to true.\n\n\n**See also**: ofEnabledNormalizedTextures()\n\n\n**Returns**: Display width of texture in pixels.\n\n\n\n\n\n_description: _\n\nReturns the width of the texture. This will be in pixels unless you've set your application to use normalized coordinates.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool hasMipmap()\n\n<!--\n_syntax: hasMipmap()_\n_name: hasMipmap_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nFind out if a mipmap has been generated for the current texture.\n\n\n**See also**: generateMipmap()\n\n**See also**: enableMipmap()\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool isAllocated()\n\n<!--\n_syntax: isAllocated()_\n_name: isAllocated_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nDetermine whether the texture has been allocated.\n\nThis lets you check if a texture is safe to draw.  The texture can both\nbe allocated by using `allocate()` or loading it with data `loadData()`.\n\n\n**Returns**: true if the texture has been allocated.\n\n\n\n\n\n_description: _\n\nGet whether the texture has been allocated.\nofTextureData getTextureData() ###\n// reference to the actual textureData inside the smart pointer\n// for backwards compatibility\nofTextureData texData ###\nfloat getHeight() ###\nfloat getWidth() ###\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool isUsingTextureMatrix()\n\n<!--\n_syntax: isUsingTextureMatrix()_\n_name: isUsingTextureMatrix_\n_returns: bool_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void loadData(&buffer, glFormat, glType)\n\n<!--\n_syntax: loadData(&buffer, glFormat, glType)_\n_name: loadData_\n_returns: void_\n_returns_description: _\n_parameters: const ofBufferObject &buffer, int glFormat, int glType_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nLoad pixels from an ofBufferObject\n\nThis is different to allocate(ofBufferObject,internal). That\ncreates a texture which data lives in GL buffer while this\ncopies the data from the buffer to the texture.\n\nThis is usually used to upload data to be shown asynchronously\nby using a buffer object binded as a PBO\n\n\n**Parameters:**\n\nbuffer The buffer to load.\n\nglFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.\n\nglType the GL type to load.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void loadData(&pix)\n\n<!--\n_syntax: loadData(&pix)_\n_name: loadData_\n_returns: void_\n_returns_description: _\n_parameters: const ofPixels &pix_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nLoad pixels from an ofPixels instance.\n\n**Parameters:**\n\npix Reference to ofPixels instance.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void loadData(&pix)\n\n<!--\n_syntax: loadData(&pix)_\n_name: loadData_\n_returns: void_\n_returns_description: _\n_parameters: const ofShortPixels &pix_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nLoad pixels from an ofShortPixels instance.\n\nSame as loadData(ofPixels &) but for ofShortPixels.\n\n\n**See also**: loadData(const ofPixels & pix)\n\n**Parameters:**\n\npix Reference to ofShortPixels instance.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void loadData(&pix)\n\n<!--\n_syntax: loadData(&pix)_\n_name: loadData_\n_returns: void_\n_returns_description: _\n_parameters: const ofFloatPixels &pix_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nLoad pixels from an ofFloatPixels instance.\n\nSame as loadData(ofPixels &) but for ofFloatPixels.\n\n\n**See also**: loadData(const ofPixels & pix)\n\n**Parameters:**\n\npix Reference to ofFloatPixels instance.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void loadData(&pix, glFormat)\n\n<!--\n_syntax: loadData(&pix, glFormat)_\n_name: loadData_\n_returns: void_\n_returns_description: _\n_parameters: const ofPixels &pix, int glFormat_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nLoad pixels from an ofPixels instance and specify the format.\n\nglFormat can be different to the internal format of the texture on each\nload, ie. we can upload GL_BGRA pixels into a GL_RGBA texture, but the\nnumber of channels need to match according to the OpenGL standard.\n\n\n**Parameters:**\n\npix Reference to ofPixels instance.\n\nglFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void loadData(&pix, glFormat)\n\n<!--\n_syntax: loadData(&pix, glFormat)_\n_name: loadData_\n_returns: void_\n_returns_description: _\n_parameters: const ofShortPixels &pix, int glFormat_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nLoad pixels from an ofShortPixels instance & specify the format.\n\n\n**See also**: loadData(const ofPixels & pix, int glFormat)\n\n**Parameters:**\n\npix Reference to ofShortPixels instance.\n\nglFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void loadData(&pix, glFormat)\n\n<!--\n_syntax: loadData(&pix, glFormat)_\n_name: loadData_\n_returns: void_\n_returns_description: _\n_parameters: const ofFloatPixels &pix, int glFormat_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nLoad pixels from an ofFloatPixels instance and specify the format.\n\n\n**See also**: loadData(const ofPixels & pix, int glFormat)\n\n**Parameters:**\n\npix Reference to ofFloatPixels instance.\n\nglFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void loadData(*data, w, h, glFormat)\n\n<!--\n_syntax: loadData(*data, w, h, glFormat)_\n_name: loadData_\n_returns: void_\n_returns_description: _\n_parameters: const uint16_t *data, int w, int h, int glFormat_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nLoad short (2 byte) pixel data.\n\n**See also**: loadData(const unsigned char* const data, int w, int h, int glFormat)\n\n**Parameters:**\n\ndata Pointer to byte pixel data. Must not be nullptr.\n\nw Pixel data width.\n\nh Pixel data height.\n\nglFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void loadData(*data, w, h, glFormat)\n\n<!--\n_syntax: loadData(*data, w, h, glFormat)_\n_name: loadData_\n_returns: void_\n_returns_description: _\n_parameters: const uint32_t *data, int w, int h, int glFormat_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void loadData(*data, w, h, glFormat)\n\n<!--\n_syntax: loadData(*data, w, h, glFormat)_\n_name: loadData_\n_returns: void_\n_returns_description: _\n_parameters: const int8_t *data, int w, int h, int glFormat_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void loadData(*data, w, h, glFormat)\n\n<!--\n_syntax: loadData(*data, w, h, glFormat)_\n_name: loadData_\n_returns: void_\n_returns_description: _\n_parameters: const int16_t *data, int w, int h, int glFormat_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void loadData(*data, w, h, glFormat)\n\n<!--\n_syntax: loadData(*data, w, h, glFormat)_\n_name: loadData_\n_returns: void_\n_returns_description: _\n_parameters: const int32_t *data, int w, int h, int glFormat_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void loadData(*data, w, h, glFormat)\n\n<!--\n_syntax: loadData(*data, w, h, glFormat)_\n_name: loadData_\n_returns: void_\n_returns_description: _\n_parameters: const float *data, int w, int h, int glFormat_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nLoad float pixel data.\n\n**See also**: loadData(const unsigned char* const data, int w, int h, int glFormat)\n\n**Parameters:**\n\ndata Pointer to byte pixel data. Must not be nullptr.\n\nw Pixel data width.\n\nh Pixel data height.\n\nglFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void loadData(*data, w, h, glFormat, glType)\n\n<!--\n_syntax: loadData(*data, w, h, glFormat, glType)_\n_name: loadData_\n_returns: void_\n_returns_description: _\n_parameters: const void *data, int w, int h, int glFormat, int glType_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nLoad byte pixel data.\n\nglFormat can be different to the internal format of the texture on each\nload, i.e. we can upload GL_BGRA pixels into a GL_RGBA texture but the\nnumber of channels need to match according to the OpenGL standard.\n\n\n**Parameters:**\n\ndata Pointer to byte pixel data. Must not be nullptr.\n\nw Pixel data width.\n\nh Pixel data height.\n\nglFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.\n\nglType the OpenGL type of the data.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void loadData(data, w, h, glFormat)\n\n<!--\n_syntax: loadData(data, w, h, glFormat)_\n_name: loadData_\n_returns: void_\n_returns_description: _\n_parameters: const uint8_t *const data, int w, int h, int glFormat_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nLoad byte pixel data.\n\nglFormat can be different to the internal format of the texture on each\nload, i.e. we can upload GL_BGRA pixels into a GL_RGBA texture but the\nnumber of channels need to match according to the OpenGL standard.\n\n\n**Parameters:**\n\ndata Pointer to byte pixel data. Must not be nullptr.\n\nw Pixel data width.\n\nh Pixel data height.\n\nglFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void loadScreenData(x, y, w, h)\n\n<!--\n_syntax: loadScreenData(x, y, w, h)_\n_name: loadScreenData_\n_returns: void_\n_returns_description: _\n_parameters: int x, int y, int w, int h_\n_access: public_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCopy an area of the screen into this texture.\n\nSpecifiy the position (x,y) you wish to grab from, with the width (w)\nand height (h) of the region.\n\nMake sure that you have allocated your texture (using `allocate()`)\nto be large enough to hold the region of the screen you wish to load.\n\n\n**See also**: http://www.opengl.org/sdk/docs/man4/html/glCopyTexSubImage2D.xhtml\n\n\n**Parameters:**\n\nx Upper left corner horizontal screen position.\n\ny Upper left corner vertical screen position.\n\nw Width of the area to copy in pixels.\n\nh Height of the area to copy in pixels.\n\n\n\n\n\n_description: _\n\nGrabs a region of the screen and loads it into the texture. Specifiy the position (x,y) you wish to grab from, with the width (w) and height (h) of the region. Make sure that you have allocated your texture (using allocate()) to be large enough to hold the region of the screen you wish to load.\nLoad data from the current screen into this texture. Grabs a region of the screen and loads it into the texture. Specifiy the position (x,y) you wish to grab from, with the width (w) and height (h) of the region. Make sure that you have allocated your texture (using allocate()) to be large enough to hold the region of the screen you wish to load.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n### ofTexture(&&mom)\n\n<!--\n_syntax: ofTexture(&&mom)_\n_name: ofTexture_\n_returns: _\n_returns_description: _\n_parameters: ofTexture &&mom_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n### ofTexture(&mom)\n\n<!--\n_syntax: ofTexture(&mom)_\n_name: ofTexture_\n_returns: _\n_returns_description: _\n_parameters: const ofTexture &mom_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nConstruct an ofTexture from an existing ofTexture.\n\n**Parameters:**\n\nmom The ofTexture to copy. Reuses internal GL texture ID.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n### ofTexture()\n\n<!--\n_syntax: ofTexture()_\n_name: ofTexture_\n_returns: _\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: False_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\\section Construction and Allocation\nConstruct an ofTexture instance.\n\n\n\n\n\n_description: _\n\nCreates an empty ofTexture instance. You can't draw a texture right after it's been created as it has actually uploaded any data to the graphics card that can be drawn yet.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###ofTexture & operator=(&&mom)\n\n<!--\n_syntax: operator=(&&mom)_\n_name: operator=_\n_returns: ofTexture &_\n_returns_description: _\n_parameters: ofTexture &&mom_\n_access: public_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###ofTexture & operator=(&mom)\n\n<!--\n_syntax: operator=(&mom)_\n_name: operator=_\n_returns: ofTexture &_\n_returns_description: _\n_parameters: const ofTexture &mom_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\\section Update Texture\nCopy a given ofTexture into this texture.\n\n**Parameters:**\n\nmom The ofTexture to copy from. Reuses internal GL texture ID.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void readToPixels(&pixels)\n\n<!--\n_syntax: readToPixels(&pixels)_\n_name: readToPixels_\n_returns: void_\n_returns_description: _\n_parameters: ofPixels &pixels_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\\section Read Pixel Data\nRead current texture data from the GPU into pixels.\n\n\n**Warning**: This is not supported in OpenGL ES and does nothing.\n\n\n**Parameters:**\n\npixels Target ofPixels reference.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void readToPixels(&pixels)\n\n<!--\n_syntax: readToPixels(&pixels)_\n_name: readToPixels_\n_returns: void_\n_returns_description: _\n_parameters: ofShortPixels &pixels_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nRead current texture data from the GPU into pixels.\n\n\n**Warning**: This is not supported in OpenGL ES and does nothing.\n\n\n**Parameters:**\n\npixels Target pixels reference.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void readToPixels(&pixels)\n\n<!--\n_syntax: readToPixels(&pixels)_\n_name: readToPixels_\n_returns: void_\n_returns_description: _\n_parameters: ofFloatPixels &pixels_\n_access: public_\n_version_started: 007_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nRead current texture data from the GPU into pixels.\n\n\n**Warning**: This is not supported in OpenGL ES and does nothing.\n\n\n**Parameters:**\n\npixels Target pixels reference.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void resetAnchor()\n\n<!--\n_syntax: resetAnchor()_\n_name: resetAnchor_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nReset the anchor point to (0, 0).\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setAlphaMask(&mask)\n\n<!--\n_syntax: setAlphaMask(&mask)_\n_name: setAlphaMask_\n_returns: void_\n_returns_description: _\n_parameters: ofTexture &mask_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\\section Texture Settings\nSet another ofTexture to use as an alpha mask.\n\n**Parameters:**\n\nmask The texture to use as alpha mask.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setAnchorPercent(xPct, yPct)\n\n<!--\n_syntax: setAnchorPercent(xPct, yPct)_\n_name: setAnchorPercent_\n_returns: void_\n_returns_description: _\n_parameters: float xPct, float yPct_\n_access: public_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nSet the anchor point the texture is drawn around as a percentage.\n\nThis can be useful if you want to rotate an image around a particular\npoint.\n\n\n**Parameters:**\n\nxPct Horizontal texture position as a percentage (0 - 1).\n\nyPct Vertical texture position as a percentage (0 - 1).\n\n\n\n\n\n_description: _\n\nThe anchor is the point the image is drawn around. This can be useful if you want to rotate an image around a particular point, allowing you to set the anchor as a percentage of the image width/height ( 0.0-1.0 range )\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setAnchorPoint(x, y)\n\n<!--\n_syntax: setAnchorPoint(x, y)_\n_name: setAnchorPoint_\n_returns: void_\n_returns_description: _\n_parameters: float x, float y_\n_access: public_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nSet the anchor point the texture is drawn around in pixels.\n\nThis can be useful if you want to rotate an image around a particular\npoint.\n\n\n**Parameters:**\n\nx Horizontal texture position in pixels.\n\ny Vertical texture position in pixels.\n\n\n\n\n\n_description: _\n\nset the anchor point in pixels\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setCompression(compression)\n\n<!--\n_syntax: setCompression(compression)_\n_name: setCompression_\n_returns: void_\n_returns_description: _\n_parameters: ofTexCompression compression_\n_access: public_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nSet the texture compression.\n\n\\warning: not yet implemented.\n\n**See also**: ofTexCompression\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setRGToRGBASwizzles(rToRGBSwizzles)\n\n<!--\n_syntax: setRGToRGBASwizzles(rToRGBSwizzles)_\n_name: setRGToRGBASwizzles_\n_returns: void_\n_returns_description: _\n_parameters: bool rToRGBSwizzles_\n_access: public_\n_version_started: 0073_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\\todo Define Swizzle in the documentation.\nSwizzle RGBA to grayscale with alpha in the red channel.\n\nUse 1 channel GL_R as luminance instead of red channel in OpenGL 3+.\n\n\n**Warning**: This is not supported in OpenGL ES and does nothing.\n\n**See also**: https://en.wikipedia.org/wiki/Swizzling_(computer_graphics)\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setSwizzle(srcSwizzle, dstChannel)\n\n<!--\n_syntax: setSwizzle(srcSwizzle, dstChannel)_\n_name: setSwizzle_\n_returns: void_\n_returns_description: _\n_parameters: GLenum srcSwizzle, GLenum dstChannel_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nSwizzle a channel to another\n\nExample:\n\n~~~~~\nofTexture tex;\ntex.setSwizzle(GL_TEXTURE_SWIZZLE_R,GL_ALPHA);\n~~~~~\n\nwill make channel 0 appear as alpha in the shader.\n\n\n**Warning**: This is not supported in OpenGL ES and does nothing.\n\n**See also**: https://en.wikipedia.org/wiki/Swizzling_(computer_graphics)\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setTextureMatrix(&m)\n\n<!--\n_syntax: setTextureMatrix(&m)_\n_name: setTextureMatrix_\n_returns: void_\n_returns_description: _\n_parameters: const glm::mat4 &m_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nSets a texture matrix to be uploaded whenever the texture is bound.\n\n**Parameters:**\n\nm The 4x4 texture matrix.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setTextureMinMagFilter(minFilter, magFilter)\n\n<!--\n_syntax: setTextureMinMagFilter(minFilter, magFilter)_\n_name: setTextureMinMagFilter_\n_returns: void_\n_returns_description: _\n_parameters: GLint minFilter, GLint magFilter_\n_access: public_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nSet texture minification/magnification scaling filters.\n\nControls how OpenGL will scale this texture.\n\n\n**See also**: http://www.opengl.org/sdk/docs/man4/html/glTexParameter.xhtml\n\n**See also**: ofTextureSetMinMagFilters()\n\n\n**Warning**: May be overridden.\n\n\n**Parameters:**\n\nminFilter minifying filter for scaling a pixel to a smaller area.\n\nmagFilter magnifying filter for scaling a pixel to a larger area.\n\n\n\n\n\n_description: _\n\nSet how the texture is scaled up and down, when it's being drawn larger or smaller than it's actual size.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setTextureWrap(wrapModeHorizontal, wrapModeVertical)\n\n<!--\n_syntax: setTextureWrap(wrapModeHorizontal, wrapModeVertical)_\n_name: setTextureWrap_\n_returns: void_\n_returns_description: _\n_parameters: GLint wrapModeHorizontal, GLint wrapModeVertical_\n_access: public_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nSet texture wrapping.\n\nBy default, textures are clamped to their edges with `GL_CLAMP_TO_EDGE`.\nSetting a repeat mode like `GL_REPEAT` allows you to create tiled\nbackgrounds with small textures.\n\n\n**See also**: ofTextureSetWrap()\n\n**See also**: http://www.opengl.org/sdk/docs/man4/html/glTexParameter.xhtml\n\n\n**Warning**: May be overridden.\n\n\n**Parameters:**\n\nwrapModeHorizontal wrap parameter for texture coordinate s.\n\nwrapModeVertical wrap parameter for texture coordinate t.\n\n\n\n\n\n_description: _\n\nSets how the texture wraps around the edges of the vertices that the texture is being drawn to.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setUseExternalTextureID(externTexID)\n\n<!--\n_syntax: setUseExternalTextureID(externTexID)_\n_name: setUseExternalTextureID_\n_returns: void_\n_returns_description: _\n_parameters: GLuint externTexID_\n_access: public_\n_version_started: 0072_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nSet the texture ID.\n\nAllows you to point the texture id to an externally allocated id\n(perhaps from another texture). It's up to you to set the rest of the\ntextData parameters manually.\n\n\n**Warning**: When setting an external texture ID, the user must set the\nremaining ofTextureData parameters manually.\n\n**Parameters:**\n\nexternTexID New texture ID.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void unbind(textureLocation = 0)\n\n<!--\n_syntax: unbind(textureLocation = 0)_\n_name: unbind_\n_returns: void_\n_returns_description: _\n_parameters: int textureLocation=0_\n_access: public_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nUnbind the texture.\n\nFor advanced users who need to manually manage texture drawing without\ncalling ofTexture::draw.\n\n\n**See also**: http://www.opengl.org/sdk/docs/man4/html/glBindTexture.xhtml\n\n\n\n\n\n_description: _\n\nThis for the advanced user who wants to draw textures in their own way. This stops vertices from being textured using this texture.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n### ~ofTexture()\n\n<!--\n_syntax: ~ofTexture()_\n_name: ~ofTexture_\n_returns: _\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: False_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nDestroy an ofTexture instance.\n\nofTexture keeps a reference count for the internal OpenGL texture ID.\nThus, the texture ID is only released if there are no additional\nreferences to the internal texture ID.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n##Variables\n\n\n\n###ofPoint anchor\n\n<!--\n_name: anchor_\n_type: ofPoint_\n_access: protected_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: False_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n< The texture's anchor point.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool bAnchorIsPct\n\n<!--\n_name: bAnchorIsPct_\n_type: bool_\n_access: protected_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: False_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n< Is the anchor point represented as a normalized\n< (0 - 1) coordinate?\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool bWantsMipmap\n\n<!--\n_name: bWantsMipmap_\n_type: bool_\n_access: private_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: False_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n< Should mipmaps be created?\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###ofTextureData texData\n\n<!--\n_name: texData_\n_type: ofTextureData_\n_access: public_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: False_\n_advanced: True_\n-->\n\n_inlined_description: _\n\n< Internal texture data access.\n< For backwards compatibility.\n\n\n\n\n\n_description: _\n\ntexData is a variable type ofTextureData. ofTextureData is a structure containing information about the texture such as size.\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n","type":"page"}}],"fetch":[]}