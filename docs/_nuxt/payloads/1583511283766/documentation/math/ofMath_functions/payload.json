{"data":[{"page":{"entry":{"name":"ofMath_functions","filename":"ofMath_functions.markdown","absolute":"/Users/Gilbert/Code/openFrameworks/ofSite/documentation/math/ofMath_functions.markdown","path":"/documentation/math/ofMath_functions","route":"/documentation/math/ofMath_functions.markdown","dir":"../ofSite/documentation/math","ext":"markdown","type":"page","id":2128,"parent":2123,"breadcrumbs":[2123,1718],"siblings":[],"translations":{}},"description":{},"methods":[null,{"syntax":"ofAngleDifferenceDegrees(currentAngle, targetAngle)","name":"ofAngleDifferenceDegrees","returns":"float","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> currentAngle<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> targetAngle","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Calculates the difference between two angles in degrees.</p>\n<p>This will calculate the actual difference, taking into account multiple\nrevolutions. For example:</p>\n<pre><code>\t\t<span class=\"token function\">ofAngleDifferenceDegrees</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">90</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// Returns 90.</span>\n\t\t<span class=\"token function\">ofAngleDifferenceDegrees</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">450</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// Also returns 90.</span>\n</code></pre>\n<p><strong>Parameters:</strong></p>\n<p>currentAngle The current angle in degrees.</p>\n<p>targetAngle the angle to be compared to in degrees.</p>\n<p><strong>Returns</strong>: The difference between two angles in degrees.</p>\n","desc":""},{"syntax":"ofAngleDifferenceRadians(currentAngle, targetAngle)","name":"ofAngleDifferenceRadians","returns":"float","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> currentAngle<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> targetAngle","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Calculates the difference between two angles in radians.</p>\n<p>This will calculate the actual difference, taking into account multiple\nrevolutions. For example:</p>\n<pre><code>\t\t<span class=\"token function\">ofAngleDifferenceRadians</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> PI<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// Returns -PI.</span>\n\t\t<span class=\"token function\">ofAngleDifferenceRadians</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token operator\">*</span>PI<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// Also returns -PI.</span>\n</code></pre>\n<p><strong>Parameters:</strong></p>\n<p>currentAngle The current angle in radians.</p>\n<p>targetAngle the angle to be compared to in radians.</p>\n<p><strong>Returns</strong>: The difference between two angles in radians.</p>\n","desc":""},{"syntax":"ofBezierPoint(&a, &b, &c, &d, t)","name":"ofBezierPoint","returns":"vectype","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> vectype <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> vectype <span class=\"token operator\">&amp;</span>b<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> vectype <span class=\"token operator\">&amp;</span>c<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> vectype <span class=\"token operator\">&amp;</span>d<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> t","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Given the four points that determine a bezier curve, return an interpolated point on the curve.</p>\n<p><strong>Parameters:</strong></p>\n<p>a The beginning point of the curve.</p>\n<p>b The first control point.</p>\n<p>c The second control point.</p>\n<p>d The end point of the curve.</p>\n<p>t an offset along the curve, normalized between 0 and 1.</p>\n<p><strong>Returns</strong>: A glm::vec3 on the curve.</p>\n","desc":""},{"syntax":"ofBezierTangent(&a, &b, &c, &d, t)","name":"ofBezierTangent","returns":"vectype","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> vectype <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> vectype <span class=\"token operator\">&amp;</span>b<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> vectype <span class=\"token operator\">&amp;</span>c<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> vectype <span class=\"token operator\">&amp;</span>d<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> t","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Given the four points that determine a bezier curve and an offset along the curve, return an tangent vector to a point on the curve.\nCurrently this is not a normalized point, and will need to be normalized.</p>\n<p><strong>Parameters:</strong></p>\n<p>a The beginning point of the curve.</p>\n<p>b The first control point.</p>\n<p>c The second control point.</p>\n<p>d The end point of the curve.</p>\n<p>t an offset along the curve, normalized between 0 and 1.</p>\n<p><strong>Returns</strong>: A glm::vec3 on the curve.</p>\n","desc":""},{"syntax":"ofClamp(value,min,max) ","name":"ofClamp","returns":"float","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> value<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> min<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> max","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Clamp a value between min and max.</p>\n<p>Restricts a value to be within a specified range defined by values min and\nmax. If the value is min &lt;= value &lt;= max, returns value.  If the value is\ngreater than max, return max; if the value is less than min, return min.\nOtherwise, return the value unchanged.</p>\n<pre><code>\t\t<span class=\"token keyword\">float</span> val <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">float</span> newVal <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\t\tnewval <span class=\"token operator\">=</span> <span class=\"token function\">ofClamp</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">,</span> <span class=\"token number\">30</span><span class=\"token punctuation\">,</span> <span class=\"token number\">40</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// newval = 30</span>\n\t\tnewval <span class=\"token operator\">=</span> <span class=\"token function\">ofClamp</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">// newval = 5</span>\n\t\tnewval <span class=\"token operator\">=</span> <span class=\"token function\">ofClamp</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// newval = 10</span>\n</code></pre>\n<p><strong>Parameters:</strong></p>\n<p>value The number to be clamped.</p>\n<p>min The lower bound of the range.</p>\n<p>max The upper bound of the range.</p>\n<p><strong>Returns</strong>: a floating point number in the range [min, max].</p>\n","desc":""},{"syntax":"ofCurvePoint(&a, &b, &c, &d, t)","name":"ofCurvePoint","returns":"vectype","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> vectype <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> vectype <span class=\"token operator\">&amp;</span>b<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> vectype <span class=\"token operator\">&amp;</span>c<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> vectype <span class=\"token operator\">&amp;</span>d<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> t","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Given the four points that determine a Catmull Rom curve, return an interpolated point on the curve.</p>\n<p><strong>Parameters:</strong></p>\n<p>a The first control point.</p>\n<p>b The beginning point of the curve.</p>\n<p>c The end point of the curve.</p>\n<p>d The second control point.</p>\n<p>t an offset along the curve, normalized between 0 and 1.</p>\n<p><strong>Returns</strong>: A glm::vec3 on the curve.</p>\n","desc":""},{"syntax":"ofCurveTangent(&a, &b, &c, &d, t)","name":"ofCurveTangent","returns":"vectype","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> vectype <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> vectype <span class=\"token operator\">&amp;</span>b<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> vectype <span class=\"token operator\">&amp;</span>c<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> vectype <span class=\"token operator\">&amp;</span>d<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> t","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Return a tangent point for an offset along a Catmull Rom curve.</p>\n<p><strong>Parameters:</strong></p>\n<p>a The first control point.</p>\n<p>b The beginning point of the curve.</p>\n<p>c The end point of the curve.</p>\n<p>d The second control point.</p>\n<p>t an offset along the curve, normalized between 0 and 1.</p>\n<p><strong>Returns</strong>: A glm::vec3 on the curve.</p>\n","desc":""},{"syntax":"ofDegToRad(degrees)","name":"ofDegToRad","returns":"float","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> degrees","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Convert degrees to radians.</p>\n<p>Example:</p>\n<pre><code>\t\t<span class=\"token keyword\">float</span> result <span class=\"token operator\">=</span> <span class=\"token function\">ofDegToRad</span><span class=\"token punctuation\">(</span><span class=\"token number\">90</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// The result will be PI/2.</span>\n</code></pre>\n<p><strong>Parameters:</strong></p>\n<p>degrees An angle in degrees.</p>\n<p><strong>Returns</strong>: the angle in radians.</p>\n","desc":""},{"syntax":"ofDist(x1, y1, x2, y2)","name":"ofDist","returns":"float","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> x1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> y1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> x2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> y2","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Calculates the 2D distance between two points.</p>\n<p>Uses the <a href=\"http://en.wikipedia.org/wiki/Pythagorean_theorem\">Pythagorean theorem</a>.</p>\n<p><strong>Parameters:</strong></p>\n<p>x1 X position of first point.</p>\n<p>y1 Y position of first point.</p>\n<p>x2 X position of second point.</p>\n<p>y2 Y position of second point.</p>\n<p><strong>Returns</strong>: float Distance between points.</p>\n","desc":""},{"syntax":"ofDist(x1, y1, z1, x2, y2, z2)","name":"ofDist","returns":"float","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> x1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> y1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> z1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> x2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> y2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> z2","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Calculates the 3D distance between two points.</p>\n<p>Uses the <a href=\"http://en.wikipedia.org/wiki/Pythagorean_theorem\">Pythagorean theorem</a>.</p>\n<p><strong>Parameters:</strong></p>\n<p>x1 X position of first point.</p>\n<p>y1 Y position of first point.</p>\n<p>z1 Z position of first point.</p>\n<p>x2 X position of second point.</p>\n<p>y2 Y position of second point.</p>\n<p>z2 Z position of second point.</p>\n<p><strong>Returns</strong>: float Distance between points.</p>\n","desc":""},{"syntax":"ofDistSquared(x1, y1, x2, y2)","name":"ofDistSquared","returns":"float","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> x1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> y1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> x2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> y2","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Calculates the squared 2D distance between two points.</p>\n<p>Same as ofDist() but doesn't take the square root sqrt() of the result,\nwhich is a faster operation if you need to calculate and compare multiple\ndistances.</p>\n<p><strong>Parameters:</strong></p>\n<p>x1 X position of first point.</p>\n<p>y1 Y position of first point.</p>\n<p>x2 X position of second point.</p>\n<p>y2 Y position of second point.</p>\n<p><strong>Returns</strong>: distance-squared between two points.</p>\n","desc":""},{"syntax":"ofDistSquared(x1, y1, z1, x2, y2, z2)","name":"ofDistSquared","returns":"float","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> x1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> y1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> z1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> x2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> y2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> z2","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Calculates the squared 3D distance between two points.</p>\n<p>Same as ofDist() but doesn't take the square root sqrt() of the result,\nwhich is a faster operation if you need to calculate and compare multiple\ndistances.</p>\n<p><strong>Parameters:</strong></p>\n<p>x1 X position of first point.</p>\n<p>y1 Y position of first point.</p>\n<p>z1 Z position of first point.</p>\n<p>x2 X position of second point.</p>\n<p>y2 Y position of second point.</p>\n<p>z2 Z position of second point.</p>\n<p><strong>Returns</strong>: distance-squared between two points.</p>\n","desc":""},{"syntax":"ofInRange(t,min,max)","name":"ofInRange","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> t<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> min<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> max","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Determine if a number is inside of a giv(float)(en range.</p>\n<p><strong>Parameters:</strong></p>\n<p>t The value to test.</p>\n<p>min The lower bound of the range.</p>\n<p>max The upper bound of the range.</p>\n<p><strong>Returns</strong>: true if the number t is the range of [min, max].</p>\n","desc":""},{"syntax":"ofInterpolateCatmullRom(&y0, &y1, &y2, &y3, pct)","name":"ofInterpolateCatmullRom","returns":"Type","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> Type <span class=\"token operator\">&amp;</span>y0<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Type <span class=\"token operator\">&amp;</span>y1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Type <span class=\"token operator\">&amp;</span>y2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Type <span class=\"token operator\">&amp;</span>y3<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> pct","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"ofInterpolateCosine(&y1, &y2, pct)","name":"ofInterpolateCosine","returns":"Type","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> Type <span class=\"token operator\">&amp;</span>y1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Type <span class=\"token operator\">&amp;</span>y2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> pct","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>}</p>\n","desc":""},{"syntax":"ofInterpolateCubic(&y0, &y1, &y2, &y3, pct)","name":"ofInterpolateCubic","returns":"Type","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> Type <span class=\"token operator\">&amp;</span>y0<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Type <span class=\"token operator\">&amp;</span>y1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Type <span class=\"token operator\">&amp;</span>y2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Type <span class=\"token operator\">&amp;</span>y3<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> pct","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"ofInterpolateHermite(&y0, &y1, &y2, &y3, pct)","name":"ofInterpolateHermite","returns":"Type","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> Type <span class=\"token operator\">&amp;</span>y0<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Type <span class=\"token operator\">&amp;</span>y1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Type <span class=\"token operator\">&amp;</span>y2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Type <span class=\"token operator\">&amp;</span>y3<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> pct","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"ofInterpolateHermite(&y0, &y1, &y2, &y3, pct, tension, bias)","name":"ofInterpolateHermite","returns":"Type","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> Type <span class=\"token operator\">&amp;</span>y0<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Type <span class=\"token operator\">&amp;</span>y1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Type <span class=\"token operator\">&amp;</span>y2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Type <span class=\"token operator\">&amp;</span>y3<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> pct<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> tension<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> bias","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"desc":""},{"syntax":"ofLerp(start,stop,amt)","name":"ofLerp","returns":"float","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> start<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> stop<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> amt","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Linearly interpolate a value within a range.</p>\n<p>Calculates a number between two numbers [start, stop] at a specific increment\n(amt).  If we want the new number to be between start and stop numbers, amt\nneeds to be a number between 0 and 1, inclusive.  ofLerp() does not clamp\nthe values.</p>\n<pre><code>\t\t<span class=\"token keyword\">float</span> init <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">float</span> end <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">float</span> increment <span class=\"token operator\">=</span> <span class=\"token number\">0.2</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">float</span> result <span class=\"token operator\">=</span> <span class=\"token function\">ofLerp</span><span class=\"token punctuation\">(</span>init<span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">,</span> increment<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// result = 1.2</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// Values outside 0...1 work as well.</span>\n\t\tincrement <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n\t\tresult <span class=\"token operator\">=</span> <span class=\"token function\">ofLerp</span><span class=\"token punctuation\">(</span>init<span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">,</span> increment<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// result = 3</span>\n</code></pre>\n<p><strong>See also</strong>: float ofClamp(float value, float min, float max)</p>\n<p><strong>Parameters:</strong></p>\n<p>start The lower bound of the range.</p>\n<p>stop The upper bound of the range.</p>\n<p>amt The normalized [0, 1] value within the range to return.</p>\n<p><strong>Returns</strong>: A float between start and stop.</p>\n","desc":""},{"syntax":"ofLerpDegrees(currentAngle, targetAngle, pct)","name":"ofLerpDegrees","returns":"float","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> currentAngle<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> targetAngle<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> pct","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Linearly interpolate a value between two angles in degrees.</p>\n<p>Calculates a number between two numbers [start, stop) at a specific\nincrement (amt). This does constrain the result into a single rotation,\nbut does not clamp the values</p>\n<p><strong>Parameters:</strong></p>\n<p>currentAngle The lower bound of the range in degrees.</p>\n<p>targetAngle The upper bound of the range in degrees.</p>\n<p>pct An amount between [0.0, 1.0] within the range to return.</p>\n<p><strong>Returns</strong>: An angle in degrees between currentAngle and targetAngle.</p>\n","desc":""},{"syntax":"ofLerpRadians(currentAngle, targetAngle, pct)","name":"ofLerpRadians","returns":"float","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> currentAngle<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> targetAngle<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> pct","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Linearly interpolate a value between two angles in radians.</p>\n<p>Calculates a number between two numbers (start, stop) at a specific\nincrement (amt).  This does constrain the result into a single rotation, but\ndoes not clamp the values</p>\n<p><strong>Parameters:</strong></p>\n<p>currentAngle The lower bound of the range in radians.</p>\n<p>targetAngle The upper bound of the range in radians.</p>\n<p>pct An amount between [0.0, 1.0] within the range to return.</p>\n<p><strong>Returns</strong>: An angle in radians between currentAngle and targetAngle.</p>\n","desc":""},{"syntax":"ofLineSegmentIntersection(&line1Start, &line1End, &line2Start, &line2End, &intersection)","name":"ofLineSegmentIntersection","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> vectype <span class=\"token operator\">&amp;</span>line1Start<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> vectype <span class=\"token operator\">&amp;</span>line1End<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> vectype <span class=\"token operator\">&amp;</span>line2Start<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> vectype <span class=\"token operator\">&amp;</span>line2End<span class=\"token punctuation\">,</span> vectype <span class=\"token operator\">&amp;</span>intersection","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Determine the intersection between two lines.</p>\n<p><strong>Parameters:</strong></p>\n<p>line1Start Starting point for first line.</p>\n<p>line1End End point for first line.</p>\n<p>line2Start Starting point for second line.</p>\n<p>line2End End point for second line.</p>\n<p>intersection glm::vec3 reference in which to store the computed intersection point.</p>\n<p><strong>Returns</strong>: True if the lines intersect.</p>\n","desc":""},{"syntax":"ofMap(value, inputMin, inputMax, outputMin, outputMax, clamp = false)","name":"ofMap","returns":"float","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> value<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> inputMin<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> inputMax<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> outputMin<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> outputMax<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> clamp<span class=\"token operator\">=</span><span class=\"token boolean\">false</span>","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Given a value and an input range, map the value to an output range.</p>\n<p>ofMap linearly maps the given value to a new value given an input and output\nrange.  Thus if value is 50% of the way between inputMin and inputMax, the\noutput value will be 50% of the way between outpuMin and outputMax. For\nan input value <em>outside</em> of the intputMin and inputMax range, negative\npercentages and percentages greater than 100% will be used.  For example, if\nthe input value is 150 and the input range is 0 - 100 and the output range\n0 - 1000, the output value will be 1500 or 150% of the total range.  The\nuser can avoid mapping outside of the input range by clamping the output\nvalue.  Clamping is disabled by default and ensures that the output value\nalways stays in the range [outputMin, outputMax).</p>\n<p>Example:</p>\n<pre><code>\t\t<span class=\"token keyword\">float</span> x <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">float</span> newx <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// 0 &amp;lt;= x &amp;lt; 10</span>\n\t\tnewx <span class=\"token operator\">=</span> <span class=\"token function\">ofMap</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">21</span><span class=\"token punctuation\">,</span> <span class=\"token number\">22</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// newx = 21.5 a value [21, 22).</span>\n</code></pre>\n<p><strong>Parameters:</strong></p>\n<p>value The number to be mapped.</p>\n<p>inputMin The lower bound of the input range.</p>\n<p>inputMax The upper bound of the input range.</p>\n<p>outputMin The lower bound of the output range.</p>\n<p>outputMax The upper bound of the output range.</p>\n<p>clamp True if the value should be clamped to [outputMin, outputMax).\n\\note If the absolute difference between inputMin and inputMax is less than\nFLT_EPSILON, outputMin will be returned to prevent divide by zero\nerrors.</p>\n<p><strong>Returns</strong>: a mapped floating point number.</p>\n","desc":""},{"syntax":"ofNextPow2(input)","name":"ofNextPow2","returns":"int","returns_description":null,"parameters":"<span class=\"token keyword\">int</span> a","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Calculates the next larger power of 2.</p>\n<p>If the input is already a power of 2, it will return itself.</p>\n<p>Example:</p>\n<pre><code><span class=\"token function\">ofNextPow2</span><span class=\"token punctuation\">(</span><span class=\"token number\">50</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// returns 64</span>\n<span class=\"token function\">ofNextPow2</span><span class=\"token punctuation\">(</span><span class=\"token number\">64</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// returns 64</span>\n<span class=\"token function\">ofNextPow2</span><span class=\"token punctuation\">(</span><span class=\"token number\">401</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// returns 512</span>\n</code></pre>\n<p><strong>Parameters:</strong></p>\n<p>a The starting point for finding the next power of 2.</p>\n<p><strong>Returns</strong>: value^2.</p>\n","desc":""},{"syntax":"ofNoise(&p)","name":"ofNoise","returns":"float","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> glm<span class=\"token operator\">::</span>vec2 <span class=\"token operator\">&amp;</span>p","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Calculates a two dimensional Perlin noise value between 0.0...1.0.</p>\n","desc":""},{"syntax":"ofNoise(&p)","name":"ofNoise","returns":"float","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> glm<span class=\"token operator\">::</span>vec3 <span class=\"token operator\">&amp;</span>p","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Calculates a three dimensional Perlin noise value between 0.0...1.0.</p>\n","desc":""},{"syntax":"ofNoise(&p)","name":"ofNoise","returns":"float","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> glm<span class=\"token operator\">::</span>vec4 <span class=\"token operator\">&amp;</span>p","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Calculates a four dimensional Perlin noise value between 0.0...1.0.</p>\n","desc":""},{"syntax":"ofNoise(x)","name":"ofNoise","returns":"float","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> x","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Calculates a one dimensional Perlin noise value between 0.0...1.0.</p>\n","desc":""},{"syntax":"ofNoise(x, y)","name":"ofNoise","returns":"float","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> y","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Calculates a two dimensional Perlin noise value between 0.0...1.0.</p>\n","desc":""},{"syntax":"ofNoise(x, y, z)","name":"ofNoise","returns":"float","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> y<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> z","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Calculates a three dimensional Perlin noise value between 0.0...1.0.</p>\n","desc":""},{"syntax":"ofNoise(x, y, z, w)","name":"ofNoise","returns":"float","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> y<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> z<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> w","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Calculates a four dimensional Perlin noise value between 0.0...1.0.</p>\n","desc":""},{"syntax":"ofNormalize(float value, float min, float max)","name":"ofNormalize","returns":"float","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> value<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> min<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> max","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Given a value and an input range, map the value to be within 0 and 1.</p>\n<p>Often, you'll need to work with percentages or other methods that expect a\nvalue between 0 and 1.  This function will take a minimum and maximum and\nthen finds where within that range a value sits.  If the value is outside\nthe range, it will be mapped to 0 or 1.</p>\n<p><strong>Parameters:</strong></p>\n<p>value The number to be normalized.</p>\n<p>min The lower bound of the range.</p>\n<p>max The upper bound of the range.</p>\n<p><strong>Returns</strong>: A float between 0 and 1.</p>\n","desc":""},{"syntax":"ofRadToDeg(radians)","name":"ofRadToDeg","returns":"float","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> radians","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Convert radians to degrees.</p>\n<p>Example:</p>\n<pre><code>\t\t<span class=\"token keyword\">float</span> result <span class=\"token operator\">=</span> <span class=\"token function\">ofRadToDeg</span><span class=\"token punctuation\">(</span>PI<span class=\"token operator\">/</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// The result will be 90.</span>\n</code></pre>\n<p><strong>Parameters:</strong></p>\n<p>radians An angle in radians.</p>\n<p><strong>Returns</strong>: the angle in degrees.</p>\n","desc":""},{"syntax":"ofRandom(max)","name":"ofRandom","returns":"float","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> max","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Get a random floating point number between 0 and max.</p>\n<p>A random number in the range [0, max) will be returned.</p>\n<p>Example:\n~~~~~{.cpp}\n// Return a random floating point number between 0 and 20.\nfloat randomNumber = ofRandom(20);</p>\n<pre><code>\n\n<span class=\"token operator\">*</span><span class=\"token operator\">*</span>Warning<span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">:</span> ofRandom wraps C<span class=\"token operator\">++</span>'s `<span class=\"token function\">rand</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>` which is <span class=\"token operator\">not</span> reentrant <span class=\"token operator\">or</span> thread safe<span class=\"token punctuation\">.</span>\n\n\n<span class=\"token operator\">*</span><span class=\"token operator\">*</span>Parameters<span class=\"token operator\">:</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span>\n\nmax The maximum value of the random number<span class=\"token punctuation\">.</span>\n\n\n\n\n\n</code></pre>\n","desc":""},{"syntax":"ofRandom(val0,val1)","name":"ofRandom","returns":"float","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> val0<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> val1","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Get a random number between two values.</p>\n<p>A random number in the range [min, max) will be returned.</p>\n<p>Example:\n~~~~~{.cpp}\n// Return a random floating point number between -30 and 20.\nfloat randomNumber = ofRandom(-30, 20);</p>\n<pre><code>\n\n<span class=\"token operator\">*</span><span class=\"token operator\">*</span>Warning<span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">:</span> ofRandom wraps `<span class=\"token function\">rand</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>` which is <span class=\"token operator\">not</span> reentrant <span class=\"token operator\">or</span> thread safe<span class=\"token punctuation\">.</span>\n\n\n<span class=\"token operator\">*</span><span class=\"token operator\">*</span>Parameters<span class=\"token operator\">:</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span>\n\nval0 the minimum value of the random number<span class=\"token punctuation\">.</span>\n\nval1 The maximum value of the random number<span class=\"token punctuation\">.</span>\n\n<span class=\"token operator\">*</span><span class=\"token operator\">*</span>Returns<span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">:</span> A random floating point number between val0 <span class=\"token operator\">and</span> val1<span class=\"token punctuation\">.</span>\n\n\n\n\n\n</code></pre>\n","desc":""},{"syntax":"ofRandomHeight()","name":"ofRandomHeight","returns":"float","returns_description":null,"parameters":null,"version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Get a random floating point number between 0 and the screen height.</p>\n<p>A random number in the range [0, ofGetHeight()) will be returned.</p>\n<p><strong>Warning</strong>: ofRandom wraps <code><span class=\"token function\">rand</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code> which is not reentrant or thread safe.</p>\n<p><strong>Returns</strong>: a random number between 0 and ofGetHeight().</p>\n","desc":""},{"syntax":"ofRandomWidth()","name":"ofRandomWidth","returns":"float","returns_description":null,"parameters":null,"version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Get a random floating point number between 0 and the screen width.</p>\n<p>A random number in the range [0, ofGetWidth()) will be returned.</p>\n<p><strong>Warning</strong>: ofRandom wraps <code><span class=\"token function\">rand</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code> which is not reentrant or thread safe.</p>\n<p><strong>Returns</strong>: a random number between 0 and ofGetWidth().</p>\n","desc":""},{"syntax":"ofRandomf()","name":"ofRandomf","returns":"float","returns_description":null,"parameters":null,"version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Get a random floating point number.</p>\n<p><strong>Warning</strong>: ofRandom wraps <code><span class=\"token function\">rand</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code> which is not reentrant or thread safe.</p>\n<p><strong>Returns</strong>: A random floating point number between -1 and 1.</p>\n","desc":""},{"syntax":"ofRandomuf()","name":"ofRandomuf","returns":"float","returns_description":null,"parameters":null,"version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Get a random unsigned floating point number.</p>\n<p><strong>Warning</strong>: ofRandom wraps <code><span class=\"token function\">rand</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code> which is not reentrant or thread safe.</p>\n<p><strong>Returns</strong>: A random floating point number between 0 and 1.</p>\n","desc":""},{"syntax":"ofSeedRandom()","name":"ofSeedRandom","returns":"void","returns_description":null,"parameters":null,"version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Seed the seeds the random number generator with a unique value.</p>\n<p>This seeds the random number generator with an acceptably random value,\ngenerated from clock time and the PID.</p>\n","desc":""},{"syntax":"ofSeedRandom(val)","name":"ofSeedRandom","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">int</span> val","version_started":"006","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Seed the random number generator.</p>\n<p>If the user would like to repeat the same random sequence, a known random\nseed can be used to initialize the random number generator during app\nsetup.  This can be useful for debugging and testing.</p>\n<p><strong>Parameters:</strong></p>\n<p>val The value with which to seed the generator.</p>\n","desc":""},{"syntax":"ofSign(n)","name":"ofSign","returns":"int","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> n","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Returns the sign of a number.</p>\n<p><strong>Returns</strong>: int -1 if n is negative, 1 if n is positive, and 0 is n == 0;</p>\n","desc":""},{"syntax":"ofSignedNoise(&p)","name":"ofSignedNoise","returns":"float","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> glm<span class=\"token operator\">::</span>vec2 <span class=\"token operator\">&amp;</span>p","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Calculates a two dimensional Perlin noise value between -1.0...1.0.</p>\n","desc":""},{"syntax":"ofSignedNoise(&p)","name":"ofSignedNoise","returns":"float","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> glm<span class=\"token operator\">::</span>vec3 <span class=\"token operator\">&amp;</span>p","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Calculates a three dimensional Perlin noise value between -1.0...1.0.</p>\n","desc":""},{"syntax":"ofSignedNoise(&p)","name":"ofSignedNoise","returns":"float","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> glm<span class=\"token operator\">::</span>vec4 <span class=\"token operator\">&amp;</span>p","version_started":"0.10.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Calculates a four dimensional Perlin noise value between -1.0...1.0.</p>\n","desc":""},{"syntax":"ofSignedNoise(x)","name":"ofSignedNoise","returns":"float","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> x","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Calculates a one dimensional Perlin noise value between -1.0...1.0.</p>\n","desc":""},{"syntax":"ofSignedNoise(x, y)","name":"ofSignedNoise","returns":"float","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> y","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Calculates a two dimensional Perlin noise value between -1.0...1.0.</p>\n","desc":""},{"syntax":"ofSignedNoise(x, y, z)","name":"ofSignedNoise","returns":"float","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> y<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> z","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Calculates a three dimensional Perlin noise value between -1.0...1.0.</p>\n","desc":""},{"syntax":"ofSignedNoise(x, y, z, w)","name":"ofSignedNoise","returns":"float","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> y<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> z<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> w","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Calculates a four dimensional Perlin noise value between -1.0...1.0.</p>\n","desc":""},{"syntax":"ofWrap(value, from, to)","name":"ofWrap","returns":"float","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> value<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> from<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> to","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>Find a value within a given range, wrapping the value if it overflows.</p>\n<p>If a value is between from and to, return that value.\nIf a value is NOT within that range, wrap it.</p>\n<p>Example:</p>\n<pre><code>\t\t<span class=\"token function\">ofWrap</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// Returns 5.</span>\n\t\t<span class=\"token function\">ofWrap</span><span class=\"token punctuation\">(</span><span class=\"token number\">15</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// Also returns 5.</span>\n\t\t<span class=\"token function\">ofWrap</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// Also returns 5.</span>\n</code></pre>\n<p><strong>Parameters:</strong></p>\n<p>value The value to map.</p>\n<p>from The lower bound of the range.</p>\n<p><strong>Returns</strong>: to The upper bound of the range.</p>\n","desc":""},{"syntax":"ofWrapDegrees(angle, from = -180, to = +180)","name":"ofWrapDegrees","returns":"float","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> angle<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> from<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> to","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"ofWrapRadians(angle, from = -PI, to = +PI)","name":"ofWrapRadians","returns":"float","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> angle<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> from<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> to","version_started":null,"version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{}],"document":"<p>#functions</p>\n<p>&lt;!--\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>##Description</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float ofAngleDifferenceDegrees(currentAngle, targetAngle)</p>\n<p>&lt;!--\n<em>syntax: ofAngleDifferenceDegrees(currentAngle, targetAngle)</em>\n<em>name: ofAngleDifferenceDegrees</em>\n<em>returns: float</em>\n_returns_description: _\n<em>parameters: float currentAngle, float targetAngle</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Calculates the difference between two angles in degrees.</p>\n<p>This will calculate the actual difference, taking into account multiple\nrevolutions. For example:</p>\n<pre><code>\t\t<span class=\"token function\">ofAngleDifferenceDegrees</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">90</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// Returns 90.</span>\n\t\t<span class=\"token function\">ofAngleDifferenceDegrees</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">450</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// Also returns 90.</span>\n</code></pre>\n<p><strong>Parameters:</strong></p>\n<p>currentAngle The current angle in degrees.</p>\n<p>targetAngle the angle to be compared to in degrees.</p>\n<p><strong>Returns</strong>: The difference between two angles in degrees.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float ofAngleDifferenceRadians(currentAngle, targetAngle)</p>\n<p>&lt;!--\n<em>syntax: ofAngleDifferenceRadians(currentAngle, targetAngle)</em>\n<em>name: ofAngleDifferenceRadians</em>\n<em>returns: float</em>\n_returns_description: _\n<em>parameters: float currentAngle, float targetAngle</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Calculates the difference between two angles in radians.</p>\n<p>This will calculate the actual difference, taking into account multiple\nrevolutions. For example:</p>\n<pre><code>\t\t<span class=\"token function\">ofAngleDifferenceRadians</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> PI<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// Returns -PI.</span>\n\t\t<span class=\"token function\">ofAngleDifferenceRadians</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token operator\">*</span>PI<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// Also returns -PI.</span>\n</code></pre>\n<p><strong>Parameters:</strong></p>\n<p>currentAngle The current angle in radians.</p>\n<p>targetAngle the angle to be compared to in radians.</p>\n<p><strong>Returns</strong>: The difference between two angles in radians.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###vectype ofBezierPoint(&amp;a, &amp;b, &amp;c, &amp;d, t)</p>\n<p>&lt;!--\n<em>syntax: ofBezierPoint(&amp;a, &amp;b, &amp;c, &amp;d, t)</em>\n<em>name: ofBezierPoint</em>\n<em>returns: vectype</em>\n_returns_description: _\n<em>parameters: const vectype &amp;a, const vectype &amp;b, const vectype &amp;c, const vectype &amp;d, float t</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Given the four points that determine a bezier curve, return an interpolated point on the curve.</p>\n<p><strong>Parameters:</strong></p>\n<p>a The beginning point of the curve.</p>\n<p>b The first control point.</p>\n<p>c The second control point.</p>\n<p>d The end point of the curve.</p>\n<p>t an offset along the curve, normalized between 0 and 1.</p>\n<p><strong>Returns</strong>: A glm::vec3 on the curve.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###vectype ofBezierTangent(&amp;a, &amp;b, &amp;c, &amp;d, t)</p>\n<p>&lt;!--\n<em>syntax: ofBezierTangent(&amp;a, &amp;b, &amp;c, &amp;d, t)</em>\n<em>name: ofBezierTangent</em>\n<em>returns: vectype</em>\n_returns_description: _\n<em>parameters: const vectype &amp;a, const vectype &amp;b, const vectype &amp;c, const vectype &amp;d, float t</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Given the four points that determine a bezier curve and an offset along the curve, return an tangent vector to a point on the curve.\nCurrently this is not a normalized point, and will need to be normalized.</p>\n<p><strong>Parameters:</strong></p>\n<p>a The beginning point of the curve.</p>\n<p>b The first control point.</p>\n<p>c The second control point.</p>\n<p>d The end point of the curve.</p>\n<p>t an offset along the curve, normalized between 0 and 1.</p>\n<p><strong>Returns</strong>: A glm::vec3 on the curve.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float ofClamp(value,min,max)</p>\n<p>&lt;!--\n_syntax: ofClamp(value,min,max) _\n<em>name: ofClamp</em>\n<em>returns: float</em>\n_returns_description: _\n<em>parameters: float value, float min, float max</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Clamp a value between min and max.</p>\n<p>Restricts a value to be within a specified range defined by values min and\nmax. If the value is min &lt;= value &lt;= max, returns value.  If the value is\ngreater than max, return max; if the value is less than min, return min.\nOtherwise, return the value unchanged.</p>\n<pre><code>\t\t<span class=\"token keyword\">float</span> val <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">float</span> newVal <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\t\tnewval <span class=\"token operator\">=</span> <span class=\"token function\">ofClamp</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">,</span> <span class=\"token number\">30</span><span class=\"token punctuation\">,</span> <span class=\"token number\">40</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// newval = 30</span>\n\t\tnewval <span class=\"token operator\">=</span> <span class=\"token function\">ofClamp</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">// newval = 5</span>\n\t\tnewval <span class=\"token operator\">=</span> <span class=\"token function\">ofClamp</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// newval = 10</span>\n</code></pre>\n<p><strong>Parameters:</strong></p>\n<p>value The number to be clamped.</p>\n<p>min The lower bound of the range.</p>\n<p>max The upper bound of the range.</p>\n<p><strong>Returns</strong>: a floating point number in the range [min, max].</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###vectype ofCurvePoint(&amp;a, &amp;b, &amp;c, &amp;d, t)</p>\n<p>&lt;!--\n<em>syntax: ofCurvePoint(&amp;a, &amp;b, &amp;c, &amp;d, t)</em>\n<em>name: ofCurvePoint</em>\n<em>returns: vectype</em>\n_returns_description: _\n<em>parameters: const vectype &amp;a, const vectype &amp;b, const vectype &amp;c, const vectype &amp;d, float t</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Given the four points that determine a Catmull Rom curve, return an interpolated point on the curve.</p>\n<p><strong>Parameters:</strong></p>\n<p>a The first control point.</p>\n<p>b The beginning point of the curve.</p>\n<p>c The end point of the curve.</p>\n<p>d The second control point.</p>\n<p>t an offset along the curve, normalized between 0 and 1.</p>\n<p><strong>Returns</strong>: A glm::vec3 on the curve.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###vectype ofCurveTangent(&amp;a, &amp;b, &amp;c, &amp;d, t)</p>\n<p>&lt;!--\n<em>syntax: ofCurveTangent(&amp;a, &amp;b, &amp;c, &amp;d, t)</em>\n<em>name: ofCurveTangent</em>\n<em>returns: vectype</em>\n_returns_description: _\n<em>parameters: const vectype &amp;a, const vectype &amp;b, const vectype &amp;c, const vectype &amp;d, float t</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Return a tangent point for an offset along a Catmull Rom curve.</p>\n<p><strong>Parameters:</strong></p>\n<p>a The first control point.</p>\n<p>b The beginning point of the curve.</p>\n<p>c The end point of the curve.</p>\n<p>d The second control point.</p>\n<p>t an offset along the curve, normalized between 0 and 1.</p>\n<p><strong>Returns</strong>: A glm::vec3 on the curve.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float ofDegToRad(degrees)</p>\n<p>&lt;!--\n<em>syntax: ofDegToRad(degrees)</em>\n<em>name: ofDegToRad</em>\n<em>returns: float</em>\n_returns_description: _\n<em>parameters: float degrees</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Convert degrees to radians.</p>\n<p>Example:</p>\n<pre><code>\t\t<span class=\"token keyword\">float</span> result <span class=\"token operator\">=</span> <span class=\"token function\">ofDegToRad</span><span class=\"token punctuation\">(</span><span class=\"token number\">90</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// The result will be PI/2.</span>\n</code></pre>\n<p><strong>Parameters:</strong></p>\n<p>degrees An angle in degrees.</p>\n<p><strong>Returns</strong>: the angle in radians.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float ofDist(x1, y1, x2, y2)</p>\n<p>&lt;!--\n<em>syntax: ofDist(x1, y1, x2, y2)</em>\n<em>name: ofDist</em>\n<em>returns: float</em>\n_returns_description: _\n<em>parameters: float x1, float y1, float x2, float y2</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Calculates the 2D distance between two points.</p>\n<p>Uses the <a href=\"http://en.wikipedia.org/wiki/Pythagorean_theorem\">Pythagorean theorem</a>.</p>\n<p><strong>Parameters:</strong></p>\n<p>x1 X position of first point.</p>\n<p>y1 Y position of first point.</p>\n<p>x2 X position of second point.</p>\n<p>y2 Y position of second point.</p>\n<p><strong>Returns</strong>: float Distance between points.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float ofDist(x1, y1, z1, x2, y2, z2)</p>\n<p>&lt;!--\n<em>syntax: ofDist(x1, y1, z1, x2, y2, z2)</em>\n<em>name: ofDist</em>\n<em>returns: float</em>\n_returns_description: _\n<em>parameters: float x1, float y1, float z1, float x2, float y2, float z2</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Calculates the 3D distance between two points.</p>\n<p>Uses the <a href=\"http://en.wikipedia.org/wiki/Pythagorean_theorem\">Pythagorean theorem</a>.</p>\n<p><strong>Parameters:</strong></p>\n<p>x1 X position of first point.</p>\n<p>y1 Y position of first point.</p>\n<p>z1 Z position of first point.</p>\n<p>x2 X position of second point.</p>\n<p>y2 Y position of second point.</p>\n<p>z2 Z position of second point.</p>\n<p><strong>Returns</strong>: float Distance between points.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float ofDistSquared(x1, y1, x2, y2)</p>\n<p>&lt;!--\n<em>syntax: ofDistSquared(x1, y1, x2, y2)</em>\n<em>name: ofDistSquared</em>\n<em>returns: float</em>\n_returns_description: _\n<em>parameters: float x1, float y1, float x2, float y2</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Calculates the squared 2D distance between two points.</p>\n<p>Same as ofDist() but doesn't take the square root sqrt() of the result,\nwhich is a faster operation if you need to calculate and compare multiple\ndistances.</p>\n<p><strong>Parameters:</strong></p>\n<p>x1 X position of first point.</p>\n<p>y1 Y position of first point.</p>\n<p>x2 X position of second point.</p>\n<p>y2 Y position of second point.</p>\n<p><strong>Returns</strong>: distance-squared between two points.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float ofDistSquared(x1, y1, z1, x2, y2, z2)</p>\n<p>&lt;!--\n<em>syntax: ofDistSquared(x1, y1, z1, x2, y2, z2)</em>\n<em>name: ofDistSquared</em>\n<em>returns: float</em>\n_returns_description: _\n<em>parameters: float x1, float y1, float z1, float x2, float y2, float z2</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Calculates the squared 3D distance between two points.</p>\n<p>Same as ofDist() but doesn't take the square root sqrt() of the result,\nwhich is a faster operation if you need to calculate and compare multiple\ndistances.</p>\n<p><strong>Parameters:</strong></p>\n<p>x1 X position of first point.</p>\n<p>y1 Y position of first point.</p>\n<p>z1 Z position of first point.</p>\n<p>x2 X position of second point.</p>\n<p>y2 Y position of second point.</p>\n<p>z2 Z position of second point.</p>\n<p><strong>Returns</strong>: distance-squared between two points.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool ofInRange(t,min,max)</p>\n<p>&lt;!--\n<em>syntax: ofInRange(t,min,max)</em>\n<em>name: ofInRange</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: float t, float min, float max</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Determine if a number is inside of a giv(float)(en range.</p>\n<p><strong>Parameters:</strong></p>\n<p>t The value to test.</p>\n<p>min The lower bound of the range.</p>\n<p>max The upper bound of the range.</p>\n<p><strong>Returns</strong>: true if the number t is the range of [min, max].</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###Type ofInterpolateCatmullRom(&amp;y0, &amp;y1, &amp;y2, &amp;y3, pct)</p>\n<p>&lt;!--\n<em>syntax: ofInterpolateCatmullRom(&amp;y0, &amp;y1, &amp;y2, &amp;y3, pct)</em>\n<em>name: ofInterpolateCatmullRom</em>\n<em>returns: Type</em>\n_returns_description: _\n<em>parameters: const Type &amp;y0, const Type &amp;y1, const Type &amp;y2, const Type &amp;y3, float pct</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###Type ofInterpolateCosine(&amp;y1, &amp;y2, pct)</p>\n<p>&lt;!--\n<em>syntax: ofInterpolateCosine(&amp;y1, &amp;y2, pct)</em>\n<em>name: ofInterpolateCosine</em>\n<em>returns: Type</em>\n_returns_description: _\n<em>parameters: const Type &amp;y1, const Type &amp;y2, float pct</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>}</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###Type ofInterpolateCubic(&amp;y0, &amp;y1, &amp;y2, &amp;y3, pct)</p>\n<p>&lt;!--\n<em>syntax: ofInterpolateCubic(&amp;y0, &amp;y1, &amp;y2, &amp;y3, pct)</em>\n<em>name: ofInterpolateCubic</em>\n<em>returns: Type</em>\n_returns_description: _\n<em>parameters: const Type &amp;y0, const Type &amp;y1, const Type &amp;y2, const Type &amp;y3, float pct</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###Type ofInterpolateHermite(&amp;y0, &amp;y1, &amp;y2, &amp;y3, pct)</p>\n<p>&lt;!--\n<em>syntax: ofInterpolateHermite(&amp;y0, &amp;y1, &amp;y2, &amp;y3, pct)</em>\n<em>name: ofInterpolateHermite</em>\n<em>returns: Type</em>\n_returns_description: _\n<em>parameters: const Type &amp;y0, const Type &amp;y1, const Type &amp;y2, const Type &amp;y3, float pct</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###Type ofInterpolateHermite(&amp;y0, &amp;y1, &amp;y2, &amp;y3, pct, tension, bias)</p>\n<p>&lt;!--\n<em>syntax: ofInterpolateHermite(&amp;y0, &amp;y1, &amp;y2, &amp;y3, pct, tension, bias)</em>\n<em>name: ofInterpolateHermite</em>\n<em>returns: Type</em>\n_returns_description: _\n<em>parameters: const Type &amp;y0, const Type &amp;y1, const Type &amp;y2, const Type &amp;y3, float pct, float tension, float bias</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###typename enable_if&lt;is_floating_point&lt; Type&gt;::value, bool &gt;::type ofIsFloatEqual(&amp;a, &amp;b)</p>\n<p>&lt;!--\n<em>syntax: ofIsFloatEqual(&amp;a, &amp;b)</em>\n<em>name: ofIsFloatEqual</em>\n<em>returns: typename enable_if&lt;is_floating_point&lt; Type&gt;::value, bool &gt;::type</em>\n_returns_description: _\n<em>parameters: const Type &amp;a, const Type &amp;b</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Compare two floating point types for equality.</p>\n<p>From C++ FAQ:</p>\n<p>Floating point arithmetic is different from real number arithmetic.\nNever use <code><span class=\"token operator\">==</span></code> to compare two floating point numbers.</p>\n<p>This solution is not completely symmetric, meaning it is possible for\n<code><span class=\"token function\">ofIsFloatEqual</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token function\">ofIsFloatEqual</span><span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span></code>. From a practical\nstandpoint, this does not usually occur when the magnitudes of x and y are\nsignificantly larger than epsilon, but your mileage may vary.</p>\n<p><strong>See also</strong>: https://isocpp.org/wiki/faq/newbie#floating-point-arith</p>\n<p><strong>See also</strong>: https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html\n\\tparam The floating point data type.</p>\n<p><strong>Parameters:</strong></p>\n<p>a The first floating point type variable to compare.</p>\n<p>b The second floating point type variable to compare.</p>\n<p><strong>Returns</strong>: True if <code>std<span class=\"token operator\">::</span><span class=\"token function\">abs</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">-</span> y<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">=</span> std<span class=\"token operator\">::</span>numeric_limits<span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span>Type<span class=\"token operator\">&amp;</span>gt<span class=\"token punctuation\">;</span><span class=\"token operator\">::</span><span class=\"token function\">epsilon</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> std<span class=\"token operator\">::</span><span class=\"token function\">abs</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span></code>.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float ofLerp(start,stop,amt)</p>\n<p>&lt;!--\n<em>syntax: ofLerp(start,stop,amt)</em>\n<em>name: ofLerp</em>\n<em>returns: float</em>\n_returns_description: _\n<em>parameters: float start, float stop, float amt</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Linearly interpolate a value within a range.</p>\n<p>Calculates a number between two numbers [start, stop] at a specific increment\n(amt).  If we want the new number to be between start and stop numbers, amt\nneeds to be a number between 0 and 1, inclusive.  ofLerp() does not clamp\nthe values.</p>\n<pre><code>\t\t<span class=\"token keyword\">float</span> init <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">float</span> end <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">float</span> increment <span class=\"token operator\">=</span> <span class=\"token number\">0.2</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">float</span> result <span class=\"token operator\">=</span> <span class=\"token function\">ofLerp</span><span class=\"token punctuation\">(</span>init<span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">,</span> increment<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// result = 1.2</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// Values outside 0...1 work as well.</span>\n\t\tincrement <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n\t\tresult <span class=\"token operator\">=</span> <span class=\"token function\">ofLerp</span><span class=\"token punctuation\">(</span>init<span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">,</span> increment<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// result = 3</span>\n</code></pre>\n<p><strong>See also</strong>: float ofClamp(float value, float min, float max)</p>\n<p><strong>Parameters:</strong></p>\n<p>start The lower bound of the range.</p>\n<p>stop The upper bound of the range.</p>\n<p>amt The normalized [0, 1] value within the range to return.</p>\n<p><strong>Returns</strong>: A float between start and stop.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float ofLerpDegrees(currentAngle, targetAngle, pct)</p>\n<p>&lt;!--\n<em>syntax: ofLerpDegrees(currentAngle, targetAngle, pct)</em>\n<em>name: ofLerpDegrees</em>\n<em>returns: float</em>\n_returns_description: _\n<em>parameters: float currentAngle, float targetAngle, float pct</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Linearly interpolate a value between two angles in degrees.</p>\n<p>Calculates a number between two numbers [start, stop) at a specific\nincrement (amt). This does constrain the result into a single rotation,\nbut does not clamp the values</p>\n<p><strong>Parameters:</strong></p>\n<p>currentAngle The lower bound of the range in degrees.</p>\n<p>targetAngle The upper bound of the range in degrees.</p>\n<p>pct An amount between [0.0, 1.0] within the range to return.</p>\n<p><strong>Returns</strong>: An angle in degrees between currentAngle and targetAngle.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float ofLerpRadians(currentAngle, targetAngle, pct)</p>\n<p>&lt;!--\n<em>syntax: ofLerpRadians(currentAngle, targetAngle, pct)</em>\n<em>name: ofLerpRadians</em>\n<em>returns: float</em>\n_returns_description: _\n<em>parameters: float currentAngle, float targetAngle, float pct</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Linearly interpolate a value between two angles in radians.</p>\n<p>Calculates a number between two numbers (start, stop) at a specific\nincrement (amt).  This does constrain the result into a single rotation, but\ndoes not clamp the values</p>\n<p><strong>Parameters:</strong></p>\n<p>currentAngle The lower bound of the range in radians.</p>\n<p>targetAngle The upper bound of the range in radians.</p>\n<p>pct An amount between [0.0, 1.0] within the range to return.</p>\n<p><strong>Returns</strong>: An angle in radians between currentAngle and targetAngle.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool ofLineSegmentIntersection(&amp;line1Start, &amp;line1End, &amp;line2Start, &amp;line2End, &amp;intersection)</p>\n<p>&lt;!--\n<em>syntax: ofLineSegmentIntersection(&amp;line1Start, &amp;line1End, &amp;line2Start, &amp;line2End, &amp;intersection)</em>\n<em>name: ofLineSegmentIntersection</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: const vectype &amp;line1Start, const vectype &amp;line1End, const vectype &amp;line2Start, const vectype &amp;line2End, vectype &amp;intersection</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Determine the intersection between two lines.</p>\n<p><strong>Parameters:</strong></p>\n<p>line1Start Starting point for first line.</p>\n<p>line1End End point for first line.</p>\n<p>line2Start Starting point for second line.</p>\n<p>line2End End point for second line.</p>\n<p>intersection glm::vec3 reference in which to store the computed intersection point.</p>\n<p><strong>Returns</strong>: True if the lines intersect.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float ofMap(value, inputMin, inputMax, outputMin, outputMax, clamp = false)</p>\n<p>&lt;!--\n<em>syntax: ofMap(value, inputMin, inputMax, outputMin, outputMax, clamp = false)</em>\n<em>name: ofMap</em>\n<em>returns: float</em>\n_returns_description: _\n<em>parameters: float value, float inputMin, float inputMax, float outputMin, float outputMax, bool clamp=false</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Given a value and an input range, map the value to an output range.</p>\n<p>ofMap linearly maps the given value to a new value given an input and output\nrange.  Thus if value is 50% of the way between inputMin and inputMax, the\noutput value will be 50% of the way between outpuMin and outputMax. For\nan input value <em>outside</em> of the intputMin and inputMax range, negative\npercentages and percentages greater than 100% will be used.  For example, if\nthe input value is 150 and the input range is 0 - 100 and the output range\n0 - 1000, the output value will be 1500 or 150% of the total range.  The\nuser can avoid mapping outside of the input range by clamping the output\nvalue.  Clamping is disabled by default and ensures that the output value\nalways stays in the range [outputMin, outputMax).</p>\n<p>Example:</p>\n<pre><code>\t\t<span class=\"token keyword\">float</span> x <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">float</span> newx <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// 0 &amp;lt;= x &amp;lt; 10</span>\n\t\tnewx <span class=\"token operator\">=</span> <span class=\"token function\">ofMap</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">21</span><span class=\"token punctuation\">,</span> <span class=\"token number\">22</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// newx = 21.5 a value [21, 22).</span>\n</code></pre>\n<p><strong>Parameters:</strong></p>\n<p>value The number to be mapped.</p>\n<p>inputMin The lower bound of the input range.</p>\n<p>inputMax The upper bound of the input range.</p>\n<p>outputMin The lower bound of the output range.</p>\n<p>outputMax The upper bound of the output range.</p>\n<p>clamp True if the value should be clamped to [outputMin, outputMax).\n\\note If the absolute difference between inputMin and inputMax is less than\nFLT_EPSILON, outputMin will be returned to prevent divide by zero\nerrors.</p>\n<p><strong>Returns</strong>: a mapped floating point number.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###int ofNextPow2(input)</p>\n<p>&lt;!--\n<em>syntax: ofNextPow2(input)</em>\n<em>name: ofNextPow2</em>\n<em>returns: int</em>\n_returns_description: _\n<em>parameters: int a</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Calculates the next larger power of 2.</p>\n<p>If the input is already a power of 2, it will return itself.</p>\n<p>Example:</p>\n<pre><code><span class=\"token function\">ofNextPow2</span><span class=\"token punctuation\">(</span><span class=\"token number\">50</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// returns 64</span>\n<span class=\"token function\">ofNextPow2</span><span class=\"token punctuation\">(</span><span class=\"token number\">64</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// returns 64</span>\n<span class=\"token function\">ofNextPow2</span><span class=\"token punctuation\">(</span><span class=\"token number\">401</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// returns 512</span>\n</code></pre>\n<p><strong>Parameters:</strong></p>\n<p>a The starting point for finding the next power of 2.</p>\n<p><strong>Returns</strong>: value^2.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float ofNoise(&amp;p)</p>\n<p>&lt;!--\n<em>syntax: ofNoise(&amp;p)</em>\n<em>name: ofNoise</em>\n<em>returns: float</em>\n_returns_description: _\n<em>parameters: const glm::vec2 &amp;p</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Calculates a two dimensional Perlin noise value between 0.0...1.0.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float ofNoise(&amp;p)</p>\n<p>&lt;!--\n<em>syntax: ofNoise(&amp;p)</em>\n<em>name: ofNoise</em>\n<em>returns: float</em>\n_returns_description: _\n<em>parameters: const glm::vec3 &amp;p</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Calculates a three dimensional Perlin noise value between 0.0...1.0.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float ofNoise(&amp;p)</p>\n<p>&lt;!--\n<em>syntax: ofNoise(&amp;p)</em>\n<em>name: ofNoise</em>\n<em>returns: float</em>\n_returns_description: _\n<em>parameters: const glm::vec4 &amp;p</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Calculates a four dimensional Perlin noise value between 0.0...1.0.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float ofNoise(x)</p>\n<p>&lt;!--\n<em>syntax: ofNoise(x)</em>\n<em>name: ofNoise</em>\n<em>returns: float</em>\n_returns_description: _\n<em>parameters: float x</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Calculates a one dimensional Perlin noise value between 0.0...1.0.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float ofNoise(x, y)</p>\n<p>&lt;!--\n<em>syntax: ofNoise(x, y)</em>\n<em>name: ofNoise</em>\n<em>returns: float</em>\n_returns_description: _\n<em>parameters: float x, float y</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Calculates a two dimensional Perlin noise value between 0.0...1.0.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float ofNoise(x, y, z)</p>\n<p>&lt;!--\n<em>syntax: ofNoise(x, y, z)</em>\n<em>name: ofNoise</em>\n<em>returns: float</em>\n_returns_description: _\n<em>parameters: float x, float y, float z</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Calculates a three dimensional Perlin noise value between 0.0...1.0.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float ofNoise(x, y, z, w)</p>\n<p>&lt;!--\n<em>syntax: ofNoise(x, y, z, w)</em>\n<em>name: ofNoise</em>\n<em>returns: float</em>\n_returns_description: _\n<em>parameters: float x, float y, float z, float w</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Calculates a four dimensional Perlin noise value between 0.0...1.0.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float ofNormalize(float value, float min, float max)</p>\n<p>&lt;!--\n<em>syntax: ofNormalize(float value, float min, float max)</em>\n<em>name: ofNormalize</em>\n<em>returns: float</em>\n_returns_description: _\n<em>parameters: float value, float min, float max</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Given a value and an input range, map the value to be within 0 and 1.</p>\n<p>Often, you'll need to work with percentages or other methods that expect a\nvalue between 0 and 1.  This function will take a minimum and maximum and\nthen finds where within that range a value sits.  If the value is outside\nthe range, it will be mapped to 0 or 1.</p>\n<p><strong>Parameters:</strong></p>\n<p>value The number to be normalized.</p>\n<p>min The lower bound of the range.</p>\n<p>max The upper bound of the range.</p>\n<p><strong>Returns</strong>: A float between 0 and 1.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float ofRadToDeg(radians)</p>\n<p>&lt;!--\n<em>syntax: ofRadToDeg(radians)</em>\n<em>name: ofRadToDeg</em>\n<em>returns: float</em>\n_returns_description: _\n<em>parameters: float radians</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Convert radians to degrees.</p>\n<p>Example:</p>\n<pre><code>\t\t<span class=\"token keyword\">float</span> result <span class=\"token operator\">=</span> <span class=\"token function\">ofRadToDeg</span><span class=\"token punctuation\">(</span>PI<span class=\"token operator\">/</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// The result will be 90.</span>\n</code></pre>\n<p><strong>Parameters:</strong></p>\n<p>radians An angle in radians.</p>\n<p><strong>Returns</strong>: the angle in degrees.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float ofRandom(max)</p>\n<p>&lt;!--\n<em>syntax: ofRandom(max)</em>\n<em>name: ofRandom</em>\n<em>returns: float</em>\n_returns_description: _\n<em>parameters: float max</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Get a random floating point number between 0 and max.</p>\n<p>A random number in the range [0, max) will be returned.</p>\n<p>Example:\n~~~~~{.cpp}\n// Return a random floating point number between 0 and 20.\nfloat randomNumber = ofRandom(20);</p>\n<pre><code>\n\n<span class=\"token operator\">*</span><span class=\"token operator\">*</span>Warning<span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">:</span> ofRandom wraps C<span class=\"token operator\">++</span>'s `<span class=\"token function\">rand</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>` which is <span class=\"token operator\">not</span> reentrant <span class=\"token operator\">or</span> thread safe<span class=\"token punctuation\">.</span>\n\n\n<span class=\"token operator\">*</span><span class=\"token operator\">*</span>Parameters<span class=\"token operator\">:</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span>\n\nmax The maximum value of the random number<span class=\"token punctuation\">.</span>\n\n\n\n\n\n_description<span class=\"token operator\">:</span> _\n\n\n\n\n\n\n\n<span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">&amp;</span>gt<span class=\"token punctuation\">;</span>\n\n###<span class=\"token keyword\">float</span> <span class=\"token function\">ofRandom</span><span class=\"token punctuation\">(</span>val0<span class=\"token punctuation\">,</span>val1<span class=\"token punctuation\">)</span>\n\n<span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span>\n_syntax<span class=\"token operator\">:</span> <span class=\"token function\">ofRandom</span><span class=\"token punctuation\">(</span>val0<span class=\"token punctuation\">,</span>val1<span class=\"token punctuation\">)</span>_\n_name<span class=\"token operator\">:</span> ofRandom_\n_returns<span class=\"token operator\">:</span> float_\n_returns_description<span class=\"token operator\">:</span> _\n_parameters<span class=\"token operator\">:</span> <span class=\"token keyword\">float</span> val0<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> val1_\n_version_started<span class=\"token operator\">:</span> 006_\n_version_deprecated<span class=\"token operator\">:</span> _\n_summary<span class=\"token operator\">:</span> _\n_constant<span class=\"token operator\">:</span> False_\n_static<span class=\"token operator\">:</span> False_\n_visible<span class=\"token operator\">:</span> True_\n_advanced<span class=\"token operator\">:</span> False_\n<span class=\"token operator\">--</span><span class=\"token operator\">&amp;</span>gt<span class=\"token punctuation\">;</span>\n\n_inlined_description<span class=\"token operator\">:</span> _\n\nGet a random number between two values<span class=\"token punctuation\">.</span>\n\nA random number in the range <span class=\"token punctuation\">[</span>min<span class=\"token punctuation\">,</span> max<span class=\"token punctuation\">)</span> will be returned<span class=\"token punctuation\">.</span>\n\nExample<span class=\"token operator\">:</span>\n\t<span class=\"token operator\">~</span><span class=\"token operator\">~</span><span class=\"token operator\">~</span><span class=\"token operator\">~</span><span class=\"token operator\">~</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">.</span>cpp<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">// Return a random floating point number between -30 and 20.</span>\n<span class=\"token keyword\">float</span> randomNumber <span class=\"token operator\">=</span> <span class=\"token function\">ofRandom</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">30</span><span class=\"token punctuation\">,</span> <span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><strong>Warning</strong>: ofRandom wraps <code><span class=\"token function\">rand</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code> which is not reentrant or thread safe.</p>\n<p><strong>Parameters:</strong></p>\n<p>val0 the minimum value of the random number.</p>\n<p>val1 The maximum value of the random number.</p>\n<p><strong>Returns</strong>: A random floating point number between val0 and val1.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float ofRandomHeight()</p>\n<p>&lt;!--\n<em>syntax: ofRandomHeight()</em>\n<em>name: ofRandomHeight</em>\n<em>returns: float</em>\n_returns_description: _\n_parameters: _\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Get a random floating point number between 0 and the screen height.</p>\n<p>A random number in the range [0, ofGetHeight()) will be returned.</p>\n<p><strong>Warning</strong>: ofRandom wraps <code><span class=\"token function\">rand</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code> which is not reentrant or thread safe.</p>\n<p><strong>Returns</strong>: a random number between 0 and ofGetHeight().</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float ofRandomWidth()</p>\n<p>&lt;!--\n<em>syntax: ofRandomWidth()</em>\n<em>name: ofRandomWidth</em>\n<em>returns: float</em>\n_returns_description: _\n_parameters: _\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Get a random floating point number between 0 and the screen width.</p>\n<p>A random number in the range [0, ofGetWidth()) will be returned.</p>\n<p><strong>Warning</strong>: ofRandom wraps <code><span class=\"token function\">rand</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code> which is not reentrant or thread safe.</p>\n<p><strong>Returns</strong>: a random number between 0 and ofGetWidth().</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float ofRandomf()</p>\n<p>&lt;!--\n<em>syntax: ofRandomf()</em>\n<em>name: ofRandomf</em>\n<em>returns: float</em>\n_returns_description: _\n_parameters: _\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Get a random floating point number.</p>\n<p><strong>Warning</strong>: ofRandom wraps <code><span class=\"token function\">rand</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code> which is not reentrant or thread safe.</p>\n<p><strong>Returns</strong>: A random floating point number between -1 and 1.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float ofRandomuf()</p>\n<p>&lt;!--\n<em>syntax: ofRandomuf()</em>\n<em>name: ofRandomuf</em>\n<em>returns: float</em>\n_returns_description: _\n_parameters: _\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Get a random unsigned floating point number.</p>\n<p><strong>Warning</strong>: ofRandom wraps <code><span class=\"token function\">rand</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code> which is not reentrant or thread safe.</p>\n<p><strong>Returns</strong>: A random floating point number between 0 and 1.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void ofSeedRandom()</p>\n<p>&lt;!--\n<em>syntax: ofSeedRandom()</em>\n<em>name: ofSeedRandom</em>\n<em>returns: void</em>\n_returns_description: _\n_parameters: _\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Seed the seeds the random number generator with a unique value.</p>\n<p>This seeds the random number generator with an acceptably random value,\ngenerated from clock time and the PID.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void ofSeedRandom(val)</p>\n<p>&lt;!--\n<em>syntax: ofSeedRandom(val)</em>\n<em>name: ofSeedRandom</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: int val</em>\n<em>version_started: 006</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Seed the random number generator.</p>\n<p>If the user would like to repeat the same random sequence, a known random\nseed can be used to initialize the random number generator during app\nsetup.  This can be useful for debugging and testing.</p>\n<p><strong>Parameters:</strong></p>\n<p>val The value with which to seed the generator.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###int ofSign(n)</p>\n<p>&lt;!--\n<em>syntax: ofSign(n)</em>\n<em>name: ofSign</em>\n<em>returns: int</em>\n_returns_description: _\n<em>parameters: float n</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Returns the sign of a number.</p>\n<p><strong>Returns</strong>: int -1 if n is negative, 1 if n is positive, and 0 is n == 0;</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float ofSignedNoise(&amp;p)</p>\n<p>&lt;!--\n<em>syntax: ofSignedNoise(&amp;p)</em>\n<em>name: ofSignedNoise</em>\n<em>returns: float</em>\n_returns_description: _\n<em>parameters: const glm::vec2 &amp;p</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Calculates a two dimensional Perlin noise value between -1.0...1.0.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float ofSignedNoise(&amp;p)</p>\n<p>&lt;!--\n<em>syntax: ofSignedNoise(&amp;p)</em>\n<em>name: ofSignedNoise</em>\n<em>returns: float</em>\n_returns_description: _\n<em>parameters: const glm::vec3 &amp;p</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Calculates a three dimensional Perlin noise value between -1.0...1.0.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float ofSignedNoise(&amp;p)</p>\n<p>&lt;!--\n<em>syntax: ofSignedNoise(&amp;p)</em>\n<em>name: ofSignedNoise</em>\n<em>returns: float</em>\n_returns_description: _\n<em>parameters: const glm::vec4 &amp;p</em>\n<em>version_started: 0.10.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Calculates a four dimensional Perlin noise value between -1.0...1.0.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float ofSignedNoise(x)</p>\n<p>&lt;!--\n<em>syntax: ofSignedNoise(x)</em>\n<em>name: ofSignedNoise</em>\n<em>returns: float</em>\n_returns_description: _\n<em>parameters: float x</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Calculates a one dimensional Perlin noise value between -1.0...1.0.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float ofSignedNoise(x, y)</p>\n<p>&lt;!--\n<em>syntax: ofSignedNoise(x, y)</em>\n<em>name: ofSignedNoise</em>\n<em>returns: float</em>\n_returns_description: _\n<em>parameters: float x, float y</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Calculates a two dimensional Perlin noise value between -1.0...1.0.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float ofSignedNoise(x, y, z)</p>\n<p>&lt;!--\n<em>syntax: ofSignedNoise(x, y, z)</em>\n<em>name: ofSignedNoise</em>\n<em>returns: float</em>\n_returns_description: _\n<em>parameters: float x, float y, float z</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Calculates a three dimensional Perlin noise value between -1.0...1.0.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float ofSignedNoise(x, y, z, w)</p>\n<p>&lt;!--\n<em>syntax: ofSignedNoise(x, y, z, w)</em>\n<em>name: ofSignedNoise</em>\n<em>returns: float</em>\n_returns_description: _\n<em>parameters: float x, float y, float z, float w</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Calculates a four dimensional Perlin noise value between -1.0...1.0.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float ofWrap(value, from, to)</p>\n<p>&lt;!--\n<em>syntax: ofWrap(value, from, to)</em>\n<em>name: ofWrap</em>\n<em>returns: float</em>\n_returns_description: _\n<em>parameters: float value, float from, float to</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>Find a value within a given range, wrapping the value if it overflows.</p>\n<p>If a value is between from and to, return that value.\nIf a value is NOT within that range, wrap it.</p>\n<p>Example:</p>\n<pre><code>\t\t<span class=\"token function\">ofWrap</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// Returns 5.</span>\n\t\t<span class=\"token function\">ofWrap</span><span class=\"token punctuation\">(</span><span class=\"token number\">15</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// Also returns 5.</span>\n\t\t<span class=\"token function\">ofWrap</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// Also returns 5.</span>\n</code></pre>\n<p><strong>Parameters:</strong></p>\n<p>value The value to map.</p>\n<p>from The lower bound of the range.</p>\n<p><strong>Returns</strong>: to The upper bound of the range.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float ofWrapDegrees(angle, from = -180, to = +180)</p>\n<p>&lt;!--\n<em>syntax: ofWrapDegrees(angle, from = -180, to = +180)</em>\n<em>name: ofWrapDegrees</em>\n<em>returns: float</em>\n_returns_description: _\n<em>parameters: float angle, float from, float to</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float ofWrapRadians(angle, from = -PI, to = +PI)</p>\n<p>&lt;!--\n<em>syntax: ofWrapRadians(angle, from = -PI, to = +PI)</em>\n<em>name: ofWrapRadians</em>\n<em>returns: float</em>\n_returns_description: _\n<em>parameters: float angle, float from, float to</em>\n_version_started: _\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n","raw":"#functions\n\n\n<!--\n_visible: True_\n_advanced: False_\n-->\n\n##Description\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float ofAngleDifferenceDegrees(currentAngle, targetAngle)\n\n<!--\n_syntax: ofAngleDifferenceDegrees(currentAngle, targetAngle)_\n_name: ofAngleDifferenceDegrees_\n_returns: float_\n_returns_description: _\n_parameters: float currentAngle, float targetAngle_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCalculates the difference between two angles in degrees.\n\nThis will calculate the actual difference, taking into account multiple\nrevolutions. For example:\n\n~~~~{.cpp}\n\t\tofAngleDifferenceDegrees(0, 90); // Returns 90.\n\t\tofAngleDifferenceDegrees(0, 450); // Also returns 90.\n~~~~\n\n\n**Parameters:**\n\ncurrentAngle The current angle in degrees.\n\ntargetAngle the angle to be compared to in degrees.\n\n**Returns**: The difference between two angles in degrees.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float ofAngleDifferenceRadians(currentAngle, targetAngle)\n\n<!--\n_syntax: ofAngleDifferenceRadians(currentAngle, targetAngle)_\n_name: ofAngleDifferenceRadians_\n_returns: float_\n_returns_description: _\n_parameters: float currentAngle, float targetAngle_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCalculates the difference between two angles in radians.\n\nThis will calculate the actual difference, taking into account multiple\nrevolutions. For example:\n\n~~~~{.cpp}\n\t\tofAngleDifferenceRadians(0, PI); // Returns -PI.\n\t\tofAngleDifferenceRadians(0, 3*PI); // Also returns -PI.\n~~~~\n\n\n**Parameters:**\n\ncurrentAngle The current angle in radians.\n\ntargetAngle the angle to be compared to in radians.\n\n**Returns**: The difference between two angles in radians.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###vectype ofBezierPoint(&a, &b, &c, &d, t)\n\n<!--\n_syntax: ofBezierPoint(&a, &b, &c, &d, t)_\n_name: ofBezierPoint_\n_returns: vectype_\n_returns_description: _\n_parameters: const vectype &a, const vectype &b, const vectype &c, const vectype &d, float t_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nGiven the four points that determine a bezier curve, return an interpolated point on the curve.\n\n**Parameters:**\n\na The beginning point of the curve.\n\nb The first control point.\n\nc The second control point.\n\nd The end point of the curve.\n\nt an offset along the curve, normalized between 0 and 1.\n\n**Returns**: A glm::vec3 on the curve.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###vectype ofBezierTangent(&a, &b, &c, &d, t)\n\n<!--\n_syntax: ofBezierTangent(&a, &b, &c, &d, t)_\n_name: ofBezierTangent_\n_returns: vectype_\n_returns_description: _\n_parameters: const vectype &a, const vectype &b, const vectype &c, const vectype &d, float t_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nGiven the four points that determine a bezier curve and an offset along the curve, return an tangent vector to a point on the curve.\nCurrently this is not a normalized point, and will need to be normalized.\n\n**Parameters:**\n\na The beginning point of the curve.\n\nb The first control point.\n\nc The second control point.\n\nd The end point of the curve.\n\nt an offset along the curve, normalized between 0 and 1.\n\n**Returns**: A glm::vec3 on the curve.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float ofClamp(value,min,max) \n\n<!--\n_syntax: ofClamp(value,min,max) _\n_name: ofClamp_\n_returns: float_\n_returns_description: _\n_parameters: float value, float min, float max_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nClamp a value between min and max.\n\nRestricts a value to be within a specified range defined by values min and\nmax. If the value is min <= value <= max, returns value.  If the value is\ngreater than max, return max; if the value is less than min, return min.\nOtherwise, return the value unchanged.\n\n~~~~{.cpp}\n\t\tfloat val = 10;\n\t\tfloat newVal = 0;\n\t\tnewval = ofClamp(val, 30, 40); // newval = 30\n\t\tnewval = ofClamp(val, 0, 5);   // newval = 5\n\t\tnewval = ofClamp(val, 0, 20);  // newval = 10\n~~~~\n\n\n**Parameters:**\n\nvalue The number to be clamped.\n\nmin The lower bound of the range.\n\nmax The upper bound of the range.\n\n**Returns**: a floating point number in the range [min, max].\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###vectype ofCurvePoint(&a, &b, &c, &d, t)\n\n<!--\n_syntax: ofCurvePoint(&a, &b, &c, &d, t)_\n_name: ofCurvePoint_\n_returns: vectype_\n_returns_description: _\n_parameters: const vectype &a, const vectype &b, const vectype &c, const vectype &d, float t_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nGiven the four points that determine a Catmull Rom curve, return an interpolated point on the curve.\n\n**Parameters:**\n\na The first control point.\n\nb The beginning point of the curve.\n\nc The end point of the curve.\n\nd The second control point.\n\nt an offset along the curve, normalized between 0 and 1.\n\n**Returns**: A glm::vec3 on the curve.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###vectype ofCurveTangent(&a, &b, &c, &d, t)\n\n<!--\n_syntax: ofCurveTangent(&a, &b, &c, &d, t)_\n_name: ofCurveTangent_\n_returns: vectype_\n_returns_description: _\n_parameters: const vectype &a, const vectype &b, const vectype &c, const vectype &d, float t_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nReturn a tangent point for an offset along a Catmull Rom curve.\n\n**Parameters:**\n\na The first control point.\n\nb The beginning point of the curve.\n\nc The end point of the curve.\n\nd The second control point.\n\nt an offset along the curve, normalized between 0 and 1.\n\n**Returns**: A glm::vec3 on the curve.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float ofDegToRad(degrees)\n\n<!--\n_syntax: ofDegToRad(degrees)_\n_name: ofDegToRad_\n_returns: float_\n_returns_description: _\n_parameters: float degrees_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nConvert degrees to radians.\n\nExample:\n~~~~{.cpp}\n\t\tfloat result = ofDegToRad(90); // The result will be PI/2.\n~~~~\n\n\n**Parameters:**\n\ndegrees An angle in degrees.\n\n**Returns**: the angle in radians.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float ofDist(x1, y1, x2, y2)\n\n<!--\n_syntax: ofDist(x1, y1, x2, y2)_\n_name: ofDist_\n_returns: float_\n_returns_description: _\n_parameters: float x1, float y1, float x2, float y2_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCalculates the 2D distance between two points.\n\nUses the [Pythagorean theorem](http://en.wikipedia.org/wiki/Pythagorean_theorem).\n\n\n**Parameters:**\n\nx1 X position of first point.\n\ny1 Y position of first point.\n\nx2 X position of second point.\n\ny2 Y position of second point.\n\n**Returns**: float Distance between points.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float ofDist(x1, y1, z1, x2, y2, z2)\n\n<!--\n_syntax: ofDist(x1, y1, z1, x2, y2, z2)_\n_name: ofDist_\n_returns: float_\n_returns_description: _\n_parameters: float x1, float y1, float z1, float x2, float y2, float z2_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCalculates the 3D distance between two points.\n\nUses the [Pythagorean theorem](http://en.wikipedia.org/wiki/Pythagorean_theorem).\n\n\n**Parameters:**\n\nx1 X position of first point.\n\ny1 Y position of first point.\n\nz1 Z position of first point.\n\nx2 X position of second point.\n\ny2 Y position of second point.\n\nz2 Z position of second point.\n\n**Returns**: float Distance between points.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float ofDistSquared(x1, y1, x2, y2)\n\n<!--\n_syntax: ofDistSquared(x1, y1, x2, y2)_\n_name: ofDistSquared_\n_returns: float_\n_returns_description: _\n_parameters: float x1, float y1, float x2, float y2_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCalculates the squared 2D distance between two points.\n\nSame as ofDist() but doesn't take the square root sqrt() of the result,\nwhich is a faster operation if you need to calculate and compare multiple\ndistances.\n\n\n**Parameters:**\n\nx1 X position of first point.\n\ny1 Y position of first point.\n\nx2 X position of second point.\n\ny2 Y position of second point.\n\n**Returns**: distance-squared between two points.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float ofDistSquared(x1, y1, z1, x2, y2, z2)\n\n<!--\n_syntax: ofDistSquared(x1, y1, z1, x2, y2, z2)_\n_name: ofDistSquared_\n_returns: float_\n_returns_description: _\n_parameters: float x1, float y1, float z1, float x2, float y2, float z2_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCalculates the squared 3D distance between two points.\n\nSame as ofDist() but doesn't take the square root sqrt() of the result,\nwhich is a faster operation if you need to calculate and compare multiple\ndistances.\n\n\n**Parameters:**\n\nx1 X position of first point.\n\ny1 Y position of first point.\n\nz1 Z position of first point.\n\nx2 X position of second point.\n\ny2 Y position of second point.\n\nz2 Z position of second point.\n\n**Returns**: distance-squared between two points.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool ofInRange(t,min,max)\n\n<!--\n_syntax: ofInRange(t,min,max)_\n_name: ofInRange_\n_returns: bool_\n_returns_description: _\n_parameters: float t, float min, float max_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nDetermine if a number is inside of a giv(float)(en range.\n\n**Parameters:**\n\nt The value to test.\n\nmin The lower bound of the range.\n\nmax The upper bound of the range.\n\n**Returns**: true if the number t is the range of [min, max].\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###Type ofInterpolateCatmullRom(&y0, &y1, &y2, &y3, pct)\n\n<!--\n_syntax: ofInterpolateCatmullRom(&y0, &y1, &y2, &y3, pct)_\n_name: ofInterpolateCatmullRom_\n_returns: Type_\n_returns_description: _\n_parameters: const Type &y0, const Type &y1, const Type &y2, const Type &y3, float pct_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###Type ofInterpolateCosine(&y1, &y2, pct)\n\n<!--\n_syntax: ofInterpolateCosine(&y1, &y2, pct)_\n_name: ofInterpolateCosine_\n_returns: Type_\n_returns_description: _\n_parameters: const Type &y1, const Type &y2, float pct_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\\}\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###Type ofInterpolateCubic(&y0, &y1, &y2, &y3, pct)\n\n<!--\n_syntax: ofInterpolateCubic(&y0, &y1, &y2, &y3, pct)_\n_name: ofInterpolateCubic_\n_returns: Type_\n_returns_description: _\n_parameters: const Type &y0, const Type &y1, const Type &y2, const Type &y3, float pct_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###Type ofInterpolateHermite(&y0, &y1, &y2, &y3, pct)\n\n<!--\n_syntax: ofInterpolateHermite(&y0, &y1, &y2, &y3, pct)_\n_name: ofInterpolateHermite_\n_returns: Type_\n_returns_description: _\n_parameters: const Type &y0, const Type &y1, const Type &y2, const Type &y3, float pct_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###Type ofInterpolateHermite(&y0, &y1, &y2, &y3, pct, tension, bias)\n\n<!--\n_syntax: ofInterpolateHermite(&y0, &y1, &y2, &y3, pct, tension, bias)_\n_name: ofInterpolateHermite_\n_returns: Type_\n_returns_description: _\n_parameters: const Type &y0, const Type &y1, const Type &y2, const Type &y3, float pct, float tension, float bias_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###typename enable_if<is_floating_point< Type>::value, bool >::type ofIsFloatEqual(&a, &b)\n\n<!--\n_syntax: ofIsFloatEqual(&a, &b)_\n_name: ofIsFloatEqual_\n_returns: typename enable_if<is_floating_point< Type>::value, bool >::type_\n_returns_description: _\n_parameters: const Type &a, const Type &b_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCompare two floating point types for equality.\n\nFrom C++ FAQ:\n\nFloating point arithmetic is different from real number arithmetic.\nNever use `==` to compare two floating point numbers.\n\nThis solution is not completely symmetric, meaning it is possible for\n`ofIsFloatEqual(x, y) != ofIsFloatEqual(y, x)`. From a practical\nstandpoint, this does not usually occur when the magnitudes of x and y are\nsignificantly larger than epsilon, but your mileage may vary.\n\n\n**See also**: https://isocpp.org/wiki/faq/newbie#floating-point-arith\n\n**See also**: https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html\n\\tparam The floating point data type.\n\n**Parameters:**\n\na The first floating point type variable to compare.\n\nb The second floating point type variable to compare.\n\n**Returns**: True if `std::abs(x - y) <= std::numeric_limits<Type>::epsilon() * std::abs(x)`.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float ofLerp(start,stop,amt)\n\n<!--\n_syntax: ofLerp(start,stop,amt)_\n_name: ofLerp_\n_returns: float_\n_returns_description: _\n_parameters: float start, float stop, float amt_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nLinearly interpolate a value within a range.\n\nCalculates a number between two numbers [start, stop] at a specific increment\n(amt).  If we want the new number to be between start and stop numbers, amt\nneeds to be a number between 0 and 1, inclusive.  ofLerp() does not clamp\nthe values.\n\n~~~~{.cpp}\n\t\tfloat init = 1;\n\t\tfloat end = 2;\n\t\tfloat increment = 0.2;\n\t\tfloat result = ofLerp(init, end, increment); // result = 1.2\n\t\t// Values outside 0...1 work as well.\n\t\tincrement = 2;\n\t\tresult = ofLerp(init, end, increment); // result = 3\n~~~~\n\n\n**See also**: float ofClamp(float value, float min, float max)\n\n**Parameters:**\n\nstart The lower bound of the range.\n\nstop The upper bound of the range.\n\namt The normalized [0, 1] value within the range to return.\n\n**Returns**: A float between start and stop.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float ofLerpDegrees(currentAngle, targetAngle, pct)\n\n<!--\n_syntax: ofLerpDegrees(currentAngle, targetAngle, pct)_\n_name: ofLerpDegrees_\n_returns: float_\n_returns_description: _\n_parameters: float currentAngle, float targetAngle, float pct_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nLinearly interpolate a value between two angles in degrees.\n\nCalculates a number between two numbers [start, stop) at a specific\nincrement (amt). This does constrain the result into a single rotation,\nbut does not clamp the values\n\n\n**Parameters:**\n\ncurrentAngle The lower bound of the range in degrees.\n\ntargetAngle The upper bound of the range in degrees.\n\npct An amount between [0.0, 1.0] within the range to return.\n\n**Returns**: An angle in degrees between currentAngle and targetAngle.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float ofLerpRadians(currentAngle, targetAngle, pct)\n\n<!--\n_syntax: ofLerpRadians(currentAngle, targetAngle, pct)_\n_name: ofLerpRadians_\n_returns: float_\n_returns_description: _\n_parameters: float currentAngle, float targetAngle, float pct_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nLinearly interpolate a value between two angles in radians.\n\nCalculates a number between two numbers (start, stop) at a specific\nincrement (amt).  This does constrain the result into a single rotation, but\ndoes not clamp the values\n\n\n**Parameters:**\n\ncurrentAngle The lower bound of the range in radians.\n\ntargetAngle The upper bound of the range in radians.\n\npct An amount between [0.0, 1.0] within the range to return.\n\n**Returns**: An angle in radians between currentAngle and targetAngle.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool ofLineSegmentIntersection(&line1Start, &line1End, &line2Start, &line2End, &intersection)\n\n<!--\n_syntax: ofLineSegmentIntersection(&line1Start, &line1End, &line2Start, &line2End, &intersection)_\n_name: ofLineSegmentIntersection_\n_returns: bool_\n_returns_description: _\n_parameters: const vectype &line1Start, const vectype &line1End, const vectype &line2Start, const vectype &line2End, vectype &intersection_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nDetermine the intersection between two lines.\n\n**Parameters:**\n\nline1Start Starting point for first line.\n\nline1End End point for first line.\n\nline2Start Starting point for second line.\n\nline2End End point for second line.\n\nintersection glm::vec3 reference in which to store the computed intersection point.\n\n**Returns**: True if the lines intersect.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float ofMap(value, inputMin, inputMax, outputMin, outputMax, clamp = false)\n\n<!--\n_syntax: ofMap(value, inputMin, inputMax, outputMin, outputMax, clamp = false)_\n_name: ofMap_\n_returns: float_\n_returns_description: _\n_parameters: float value, float inputMin, float inputMax, float outputMin, float outputMax, bool clamp=false_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nGiven a value and an input range, map the value to an output range.\n\nofMap linearly maps the given value to a new value given an input and output\nrange.  Thus if value is 50% of the way between inputMin and inputMax, the\noutput value will be 50% of the way between outpuMin and outputMax. For\nan input value _outside_ of the intputMin and inputMax range, negative\npercentages and percentages greater than 100% will be used.  For example, if\nthe input value is 150 and the input range is 0 - 100 and the output range\n0 - 1000, the output value will be 1500 or 150% of the total range.  The\nuser can avoid mapping outside of the input range by clamping the output\nvalue.  Clamping is disabled by default and ensures that the output value\nalways stays in the range [outputMin, outputMax).\n\nExample:\n~~~~~{.cpp}\n\t\tfloat x = 5;\n\t\tfloat newx = 0;\n\t\t// 0 <= x < 10\n\t\tnewx = ofMap(x, 0, 10, 21, 22); // newx = 21.5 a value [21, 22).\n~~~~~\n\n\n**Parameters:**\n\nvalue The number to be mapped.\n\ninputMin The lower bound of the input range.\n\ninputMax The upper bound of the input range.\n\noutputMin The lower bound of the output range.\n\noutputMax The upper bound of the output range.\n\nclamp True if the value should be clamped to [outputMin, outputMax).\n\\note If the absolute difference between inputMin and inputMax is less than\n\t\t  FLT_EPSILON, outputMin will be returned to prevent divide by zero\n\t\t  errors.\n\n**Returns**: a mapped floating point number.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###int ofNextPow2(input)\n\n<!--\n_syntax: ofNextPow2(input)_\n_name: ofNextPow2_\n_returns: int_\n_returns_description: _\n_parameters: int a_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCalculates the next larger power of 2.\n\nIf the input is already a power of 2, it will return itself.\n\nExample:\n~~~~{.cpp}\nofNextPow2(50); // returns 64\nofNextPow2(64); // returns 64\nofNextPow2(401); // returns 512\n~~~~\n\n\n**Parameters:**\n\na The starting point for finding the next power of 2.\n\n**Returns**: value^2.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float ofNoise(&p)\n\n<!--\n_syntax: ofNoise(&p)_\n_name: ofNoise_\n_returns: float_\n_returns_description: _\n_parameters: const glm::vec2 &p_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCalculates a two dimensional Perlin noise value between 0.0...1.0.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float ofNoise(&p)\n\n<!--\n_syntax: ofNoise(&p)_\n_name: ofNoise_\n_returns: float_\n_returns_description: _\n_parameters: const glm::vec3 &p_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCalculates a three dimensional Perlin noise value between 0.0...1.0.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float ofNoise(&p)\n\n<!--\n_syntax: ofNoise(&p)_\n_name: ofNoise_\n_returns: float_\n_returns_description: _\n_parameters: const glm::vec4 &p_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCalculates a four dimensional Perlin noise value between 0.0...1.0.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float ofNoise(x)\n\n<!--\n_syntax: ofNoise(x)_\n_name: ofNoise_\n_returns: float_\n_returns_description: _\n_parameters: float x_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCalculates a one dimensional Perlin noise value between 0.0...1.0.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float ofNoise(x, y)\n\n<!--\n_syntax: ofNoise(x, y)_\n_name: ofNoise_\n_returns: float_\n_returns_description: _\n_parameters: float x, float y_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCalculates a two dimensional Perlin noise value between 0.0...1.0.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float ofNoise(x, y, z)\n\n<!--\n_syntax: ofNoise(x, y, z)_\n_name: ofNoise_\n_returns: float_\n_returns_description: _\n_parameters: float x, float y, float z_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCalculates a three dimensional Perlin noise value between 0.0...1.0.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float ofNoise(x, y, z, w)\n\n<!--\n_syntax: ofNoise(x, y, z, w)_\n_name: ofNoise_\n_returns: float_\n_returns_description: _\n_parameters: float x, float y, float z, float w_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCalculates a four dimensional Perlin noise value between 0.0...1.0.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float ofNormalize(float value, float min, float max)\n\n<!--\n_syntax: ofNormalize(float value, float min, float max)_\n_name: ofNormalize_\n_returns: float_\n_returns_description: _\n_parameters: float value, float min, float max_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nGiven a value and an input range, map the value to be within 0 and 1.\n\nOften, you'll need to work with percentages or other methods that expect a\nvalue between 0 and 1.  This function will take a minimum and maximum and\nthen finds where within that range a value sits.  If the value is outside\nthe range, it will be mapped to 0 or 1.\n\n\n**Parameters:**\n\nvalue The number to be normalized.\n\nmin The lower bound of the range.\n\nmax The upper bound of the range.\n\n**Returns**: A float between 0 and 1.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float ofRadToDeg(radians)\n\n<!--\n_syntax: ofRadToDeg(radians)_\n_name: ofRadToDeg_\n_returns: float_\n_returns_description: _\n_parameters: float radians_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nConvert radians to degrees.\n\nExample:\n~~~~{.cpp}\n\t\tfloat result = ofRadToDeg(PI/2); // The result will be 90.\n~~~~\n\n\n**Parameters:**\n\nradians An angle in radians.\n\n**Returns**: the angle in degrees.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float ofRandom(max)\n\n<!--\n_syntax: ofRandom(max)_\n_name: ofRandom_\n_returns: float_\n_returns_description: _\n_parameters: float max_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nGet a random floating point number between 0 and max.\n\nA random number in the range [0, max) will be returned.\n\nExample:\n\t~~~~~{.cpp}\n// Return a random floating point number between 0 and 20.\nfloat randomNumber = ofRandom(20);\n~~~~~\n\n\n**Warning**: ofRandom wraps C++'s `rand()` which is not reentrant or thread safe.\n\n\n**Parameters:**\n\nmax The maximum value of the random number.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float ofRandom(val0,val1)\n\n<!--\n_syntax: ofRandom(val0,val1)_\n_name: ofRandom_\n_returns: float_\n_returns_description: _\n_parameters: float val0, float val1_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nGet a random number between two values.\n\nA random number in the range [min, max) will be returned.\n\nExample:\n\t~~~~~{.cpp}\n// Return a random floating point number between -30 and 20.\nfloat randomNumber = ofRandom(-30, 20);\n~~~~~\n\n\n**Warning**: ofRandom wraps `rand()` which is not reentrant or thread safe.\n\n\n**Parameters:**\n\nval0 the minimum value of the random number.\n\nval1 The maximum value of the random number.\n\n**Returns**: A random floating point number between val0 and val1.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float ofRandomHeight()\n\n<!--\n_syntax: ofRandomHeight()_\n_name: ofRandomHeight_\n_returns: float_\n_returns_description: _\n_parameters: _\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nGet a random floating point number between 0 and the screen height.\n\nA random number in the range [0, ofGetHeight()) will be returned.\n\n\n**Warning**: ofRandom wraps `rand()` which is not reentrant or thread safe.\n\n\n**Returns**: a random number between 0 and ofGetHeight().\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float ofRandomWidth()\n\n<!--\n_syntax: ofRandomWidth()_\n_name: ofRandomWidth_\n_returns: float_\n_returns_description: _\n_parameters: _\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nGet a random floating point number between 0 and the screen width.\n\nA random number in the range [0, ofGetWidth()) will be returned.\n\n\n**Warning**: ofRandom wraps `rand()` which is not reentrant or thread safe.\n\n\n**Returns**: a random number between 0 and ofGetWidth().\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float ofRandomf()\n\n<!--\n_syntax: ofRandomf()_\n_name: ofRandomf_\n_returns: float_\n_returns_description: _\n_parameters: _\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nGet a random floating point number.\n\n\n**Warning**: ofRandom wraps `rand()` which is not reentrant or thread safe.\n\n\n**Returns**: A random floating point number between -1 and 1.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float ofRandomuf()\n\n<!--\n_syntax: ofRandomuf()_\n_name: ofRandomuf_\n_returns: float_\n_returns_description: _\n_parameters: _\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nGet a random unsigned floating point number.\n\n\n**Warning**: ofRandom wraps `rand()` which is not reentrant or thread safe.\n\n\n**Returns**: A random floating point number between 0 and 1.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void ofSeedRandom()\n\n<!--\n_syntax: ofSeedRandom()_\n_name: ofSeedRandom_\n_returns: void_\n_returns_description: _\n_parameters: _\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nSeed the seeds the random number generator with a unique value.\n\nThis seeds the random number generator with an acceptably random value,\ngenerated from clock time and the PID.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void ofSeedRandom(val)\n\n<!--\n_syntax: ofSeedRandom(val)_\n_name: ofSeedRandom_\n_returns: void_\n_returns_description: _\n_parameters: int val_\n_version_started: 006_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nSeed the random number generator.\n\nIf the user would like to repeat the same random sequence, a known random\nseed can be used to initialize the random number generator during app\nsetup.  This can be useful for debugging and testing.\n\n\n**Parameters:**\n\nval The value with which to seed the generator.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###int ofSign(n)\n\n<!--\n_syntax: ofSign(n)_\n_name: ofSign_\n_returns: int_\n_returns_description: _\n_parameters: float n_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nReturns the sign of a number.\n\n**Returns**: int -1 if n is negative, 1 if n is positive, and 0 is n == 0;\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float ofSignedNoise(&p)\n\n<!--\n_syntax: ofSignedNoise(&p)_\n_name: ofSignedNoise_\n_returns: float_\n_returns_description: _\n_parameters: const glm::vec2 &p_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCalculates a two dimensional Perlin noise value between -1.0...1.0.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float ofSignedNoise(&p)\n\n<!--\n_syntax: ofSignedNoise(&p)_\n_name: ofSignedNoise_\n_returns: float_\n_returns_description: _\n_parameters: const glm::vec3 &p_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCalculates a three dimensional Perlin noise value between -1.0...1.0.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float ofSignedNoise(&p)\n\n<!--\n_syntax: ofSignedNoise(&p)_\n_name: ofSignedNoise_\n_returns: float_\n_returns_description: _\n_parameters: const glm::vec4 &p_\n_version_started: 0.10.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCalculates a four dimensional Perlin noise value between -1.0...1.0.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float ofSignedNoise(x)\n\n<!--\n_syntax: ofSignedNoise(x)_\n_name: ofSignedNoise_\n_returns: float_\n_returns_description: _\n_parameters: float x_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCalculates a one dimensional Perlin noise value between -1.0...1.0.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float ofSignedNoise(x, y)\n\n<!--\n_syntax: ofSignedNoise(x, y)_\n_name: ofSignedNoise_\n_returns: float_\n_returns_description: _\n_parameters: float x, float y_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCalculates a two dimensional Perlin noise value between -1.0...1.0.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float ofSignedNoise(x, y, z)\n\n<!--\n_syntax: ofSignedNoise(x, y, z)_\n_name: ofSignedNoise_\n_returns: float_\n_returns_description: _\n_parameters: float x, float y, float z_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCalculates a three dimensional Perlin noise value between -1.0...1.0.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float ofSignedNoise(x, y, z, w)\n\n<!--\n_syntax: ofSignedNoise(x, y, z, w)_\n_name: ofSignedNoise_\n_returns: float_\n_returns_description: _\n_parameters: float x, float y, float z, float w_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nCalculates a four dimensional Perlin noise value between -1.0...1.0.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float ofWrap(value, from, to)\n\n<!--\n_syntax: ofWrap(value, from, to)_\n_name: ofWrap_\n_returns: float_\n_returns_description: _\n_parameters: float value, float from, float to_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nFind a value within a given range, wrapping the value if it overflows.\n\nIf a value is between from and to, return that value.\nIf a value is NOT within that range, wrap it.\n\nExample:\n~~~~{.cpp}\n\t\tofWrap(5, 0, 10); // Returns 5.\n\t\tofWrap(15, 0, 10); // Also returns 5.\n\t\tofWrap(-5, 0, 10); // Also returns 5.\n~~~~\n\n\n**Parameters:**\n\nvalue The value to map.\n\nfrom The lower bound of the range.\n\n**Returns**: to The upper bound of the range.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float ofWrapDegrees(angle, from = -180, to = +180)\n\n<!--\n_syntax: ofWrapDegrees(angle, from = -180, to = +180)_\n_name: ofWrapDegrees_\n_returns: float_\n_returns_description: _\n_parameters: float angle, float from, float to_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float ofWrapRadians(angle, from = -PI, to = +PI)\n\n<!--\n_syntax: ofWrapRadians(angle, from = -PI, to = +PI)_\n_name: ofWrapRadians_\n_returns: float_\n_returns_description: _\n_parameters: float angle, float from, float to_\n_version_started: _\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n","type":"page"}}],"fetch":[]}