<!doctype html>
<html data-n-head-ssr>
  <head>
    <title>ofTexture | documentation | ofDocs</title><meta data-n-head="ssr" data-hid="description" name="description" content="openFrameworks documentation and examples browser"><meta data-n-head="ssr" data-hid="keyword" name="keyword" content=""><meta data-n-head="ssr" property="og:description" content="openFrameworks documentation and examples browser" vmid="og:description"><meta data-n-head="ssr" property="og:title" content="ofTexture | documentation | ofDocs" vmid="og:title"><meta data-n-head="ssr" property="og:image" content="/files/images/ofw-logo.png" vmid="og:image"><link rel="preload" href="/_nuxt/5f71eaca0bd2f1a0f939.js" as="script"><link rel="preload" href="/_nuxt/906a3ca0fb13ed3c6651.js" as="script"><link rel="preload" href="/_nuxt/fe12c0cb7395fa1032f4.css" as="style"><link rel="preload" href="/_nuxt/b673915e8a08acf593e8.js" as="script"><link rel="preload" href="/_nuxt/46e8fcacdadb233d9fb6.css" as="style"><link rel="preload" href="/_nuxt/bf355f21967a23c26c07.js" as="script"><link rel="preload" href="/_nuxt/35a90d914f539af1362f.js" as="script"><link rel="stylesheet" href="/_nuxt/fe12c0cb7395fa1032f4.css"><link rel="stylesheet" href="/_nuxt/46e8fcacdadb233d9fb6.css">
  </head>
  <body>
    <div data-server-rendered="true" id="__nuxt"><!----><div id="__layout"><div id="app"><div id="menu"><div class="menu-inner"><div id="settings"></div><h1 class="of"><div class="inner"><span><a href="/" class="nuxt-link-active"><svg version="1.1" viewbox="0 0 110 58" width="110px" height="58px" enable-background="0 0 110 58" xml:space="preserve" class="logo"><g><path d="M58,29 C58,13 45,0 29,0 C13,0 0,13 0,29 C0,45 13,58 29,58 C45,58 58,45 58,29 Z"></path><rect x="59" y="0" width="25" height="58"></rect><rect x="85" y="26" width="15" height="15"></rect><path d="M85,0 L110,0 L85,25 L85,0 Z"></path></g></svg><div class="txt"><span class="docs f7 questrial">Docs </span><span class="version">0.11.0</span></div></a></span></div></h1><div id="search"><div class="inner"><div class="field text"><div class="field-inner"><svg viewbox="0 0 36 36" enable-background="new 0 0 36 36" xml:space="preserve"><path d="M35.525,31.228l-8.88-8.882c1.444-2.238,2.298-4.895,2.298-7.752c0-7.909-6.438-14.343-14.346-14.343							c-7.911,0-14.343,6.434-14.343,14.343c0,7.911,6.433,14.344,14.343,14.344c2.856,0,5.513-0.849,7.752-2.294l8.88,8.88							c0.295,0.297,0.782,0.297,1.076,0l3.22-3.221C35.824,32.008,35.824,31.523,35.525,31.228z M4.81,14.593							c0-5.396,4.391-9.788,9.788-9.788c5.398,0,9.787,4.392,9.787,9.788c0,5.398-4.389,9.789-9.787,9.789							C9.2,24.382,4.81,19.991,4.81,14.593z"></path></svg><!----><div class="text-wrapper"><input id="search_field" name="search_field" placeholder="Search (Alt+F)" autocomplete="off" tabindex="0"></div><!----><!----></div></div></div><!----></div><div id="lists" class="menu-inner mt1 mb2"><div class="inner"></div></div></div><div class="menu-bottom"><div class="inner"><button class="button"><!----><span><span class="ico">nights_stay</span></span></button></div></div></div><div id="document"><div id="renderer" class="main page"><div absolute="/Users/Gilbert/Code/openFrameworks/ofSite/documentation/gl/ofTexture.markdown" route="/documentation/gl/ofTexture.markdown" dir="../ofSite/documentation/gl" ext="markdown" type="page" id="2221" parent="2192" siblings="" translations="[object Object]" class="doc-header"><div class="doc-header-inner"><div class="inner"><span class="breadcrumbs"><span class="crumb"><a href="/" class="pink nuxt-link-active">ofDocs</a><span class="chevron right"></span></span><span class="crumb"><a href="/documentation/" class="pink nuxt-link-active">documentation </a><!----><span class="chevron right"></span></span><span class="crumb"><a href="/documentation/gl/" class="pink nuxt-link-active">gl </a><!----><span class="chevron right"></span></span><span class="crumb"><!----><span class="link selector"><span class="name">ofTexture</span><span class="chevron bottom"></span><select><option value="/documentation/gl/ofBufferObject">ofBufferObject</option><option value="/documentation/gl/ofFbo::Settings">ofFbo::Settings</option><option value="/documentation/gl/ofFbo">ofFbo</option><option value="/documentation/gl/ofFboSettings">ofFboSettings</option><option value="/documentation/gl/ofGLProgrammableRenderer">ofGLProgrammableRenderer</option><option value="/documentation/gl/ofGLRenderer">ofGLRenderer</option><option value="/documentation/gl/ofGLUtils_functions">ofGLUtils (functions)</option><option value="/documentation/gl/ofLight_functions">ofLight (functions)</option><option value="/documentation/gl/ofLight::Data">ofLight::Data</option><option value="/documentation/gl/ofLight">ofLight</option><option value="/documentation/gl/ofMaterial::Data">ofMaterial::Data</option><option value="/documentation/gl/ofMaterial::Shaders">ofMaterial::Shaders</option><option value="/documentation/gl/ofMaterial">ofMaterial</option><option value="/documentation/gl/ofMaterialSettings">ofMaterialSettings</option><option value="/documentation/gl/ofShader::Shader">ofShader::Shader</option><option value="/documentation/gl/ofShader::Source">ofShader::Source</option><option value="/documentation/gl/ofShader::TransformFeedbackBaseBinding">ofShader::TransformFeedbackBaseBinding</option><option value="/documentation/gl/ofShader::TransformFeedbackRangeBinding">ofShader::TransformFeedbackRangeBinding</option><option value="/documentation/gl/ofShader::TransformFeedbackSettings">ofShader::TransformFeedbackSettings</option><option value="/documentation/gl/ofShader">ofShader</option><option value="/documentation/gl/ofShaderSettings">ofShaderSettings</option><option value="/documentation/gl/ofTexture_functions">ofTexture (functions)</option><option value="/documentation/gl/ofTexture">ofTexture</option><option value="/documentation/gl/ofTextureData">ofTextureData</option><option value="/documentation/gl/ofVbo::VertexAttribute">ofVbo::VertexAttribute</option><option value="/documentation/gl/ofVbo">ofVbo</option><option value="/documentation/gl/ofVboMesh">ofVboMesh</option></select></span><!----></span></span></div></div></div><div class="editable-wrapper"><div class="header inner"><h1 class="page-title questrial"><span class="f7"><!----><span>ofTexture</span></span><span class="f3"></span></h1><div class="actions"><a href="/ofdocs/contribute/" class="button"><i class="ico">edit</i><span>Edit</span></a></div></div><div class="rendered"><div id="documentation-page" static="true"><div id="offset-page"><div id="doc-body" class="markdown"><div class="inner"><div id="description"><div class="full-description"><div class="html"><p>ofTexture is used to create textures that live on your graphics card from bitmap data that can then be used to fill other drawn objects, like a bitmap fill on a rectangle. When you draw an ofImage, you're actually just drawing a rectangle of points and then using an ofTexture to fill the space between those points. At it's core, ofTexture is a wrapper for OpenGL textures. It allows use of non-power of 2 textures in opengl, and to upload and draw graphical data.</p>
<h1></h1>
</div></div></div><div id="methods"><hr><section name="allocate" id="allocate" class="mb2"><div class="method mb2"><h3 class="f3 title">allocate( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">allocate</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> ofPixels <span class="token operator">&</span>pix</code><span class="token punctuation">)</span></code><div class="short"><p>Allocate texture using an ofPixels instance.</p>
<p>Pixel type and OpenGL format are determined from pixel settings.</p>
<p><strong>Parameters:</strong></p>
<p>pix Reference to ofPixels instance.</p>
</div><div class="desc"></div></div><hr></section><section name="allocate" id="allocate" class="mb2"><div class="method mb2"><h3 class="f3 title">allocate( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">allocate</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> ofShortPixels <span class="token operator">&</span>pix</code><span class="token punctuation">)</span></code><div class="short"><p>Allocate texture using an ofShortPixels instance.</p>
<p>Same as void allocate(const ofPixels& pix), except using ofShortPixels.</p>
<p><strong>See also</strong>: allocate(const ofPixels& pix)</p>
<p><strong>Parameters:</strong></p>
<p>pix Reference to ofShortPixels instance.</p>
</div><div class="desc"></div></div><hr></section><section name="allocate" id="allocate" class="mb2"><div class="method mb2"><h3 class="f3 title">allocate( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">allocate</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> ofFloatPixels <span class="token operator">&</span>pix</code><span class="token punctuation">)</span></code><div class="short"><p>Allocate texture using an ofFloatPixels instance.</p>
<p>Same as void allocate(const ofPixels& pix), except using ofFloatPixels.</p>
<p><strong>See also</strong>: allocate(const ofPixels& pix)</p>
<p><strong>Parameters:</strong></p>
<p>pix Reference to ofFloatPixels instance.</p>
</div><div class="desc"></div></div><hr></section><section name="allocate" id="allocate" class="mb2"><div class="method mb2"><h3 class="f3 title">allocate( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">allocate</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> ofPixels <span class="token operator">&</span>pix<span class="token punctuation">,</span> <span class="token keyword">bool</span> bUseARBExtension</code><span class="token punctuation">)</span></code><div class="short"><p>Allocate texture using an ofPixels instance and type.</p>
<p>This lets you overide the default OF texture type in case you need a
square GL_TEXTURE_2D texture.</p>
<p><strong>Warning</strong>: ARB textures are not available in OpenGL ES.</p>
<p><strong>See also</strong>: ofEnableArbTex()</p>
<p><strong>See also</strong>: allocate(const ofPixels& pix)</p>
<p><strong>Parameters:</strong></p>
<p>pix Reference to ofPixels instance.</p>
<p>bUseARBExtension Set to true to use rectangular textures.</p>
</div><div class="desc"></div></div><hr></section><section name="allocate" id="allocate" class="mb2"><div class="method mb2"><h3 class="f3 title">allocate( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">allocate</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> ofShortPixels <span class="token operator">&</span>pix<span class="token punctuation">,</span> <span class="token keyword">bool</span> bUseARBExtension</code><span class="token punctuation">)</span></code><div class="short"><p>Allocate texture using an ofShortPixels instance and type.</p>
<p>Same as void void allocate(const ofPixels& pix), except using ofShortPixels.</p>
<p><strong>See also</strong>: allocate(const ofShortPixels& pix)</p>
<p><strong>Parameters:</strong></p>
<p>pix Reference to ofShortPixels instance.</p>
<p>bUseARBExtension Set to true to use rectangular textures.</p>
</div><div class="desc"></div></div><hr></section><section name="allocate" id="allocate" class="mb2"><div class="method mb2"><h3 class="f3 title">allocate( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">allocate</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> ofFloatPixels <span class="token operator">&</span>pix<span class="token punctuation">,</span> <span class="token keyword">bool</span> bUseARBExtension</code><span class="token punctuation">)</span></code><div class="short"><p>Allocate texture using an ofShortPixels instance and type.</p>
<p>Same as void void allocate(const ofPixels& pix), except using ofShortPixels.</p>
<p><strong>See also</strong>: allocate(const ofFloatPixels& pix)</p>
<p><strong>Parameters:</strong></p>
<p>pix Reference to ofFloatPixels instance.</p>
<p>bUseARBExtension Set to true to use rectangular textures.</p>
</div><div class="desc"></div></div><hr></section><section name="allocate" id="allocate" class="mb2"><div class="method mb2"><h3 class="f3 title">allocate( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">allocate</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> ofTextureData <span class="token operator">&</span>textureData</code><span class="token punctuation">)</span></code><div class="short"><p>Allocate the texture using the given settings.</p>
<p>This is useful if you need manual control over loading a number of
textures with the same settings. Make sure to set the texture data
parameters first.</p>
<p><strong>Parameters:</strong></p>
<p>textureData The settings to use when allocating the ofTexture.</p>
</div><div class="desc"></div></div><hr></section><section name="allocate" id="allocate" class="mb2"><div class="method mb2"><h3 class="f3 title">allocate( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">allocate</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> ofTextureData <span class="token operator">&</span>textureData<span class="token punctuation">,</span> <span class="token keyword">int</span> glFormat<span class="token punctuation">,</span> <span class="token keyword">int</span> pixelType</code><span class="token punctuation">)</span></code><div class="short"><p>Allocate the texture using the given settings and custom format.</p>
<p><strong>Parameters:</strong></p>
<p>textureData The settings to use when allocating the ofTexture.</p>
<p>glFormat GL texture format: GL_RGBA, GL_LUMINANCE, etc.</p>
<p>pixelType GL pixel type: GL_UNSIGNED_BYTE, GL_FLOAT, etc.</p>
</div><div class="desc"></div></div><hr></section><section name="allocate" id="allocate" class="mb2"><div class="method mb2"><h3 class="f3 title">allocate( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">allocate</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">int</span> w<span class="token punctuation">,</span> <span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> glInternalFormat</code><span class="token punctuation">)</span></code><div class="short"><p>Allocate texture of a given size and format.</p>
<p>The width (w) and height (h) do not necessarily need to be powers of 2,
but they do need to be large enough to contain the data you will upload
to the texture.</p>
<p>The internal data type <code>glFormat</code> describes how OpenGL will store this
texture internally. For example, if you want a grayscale texture, you
can use <code>GL_LUMINANCE</code>. You can upload what ever type of data you want
(using <code>loadData()</code>) but internally, opengl will store the information
as grayscale. Other types include: <code>GL_RGB</code>, <code>GL_RGBA</code>.</p>
<p>This method applies the currently set OF texture type and defaults to
ARB rectangular textures if they are supported. (They are not supported
on OpenGL ES).</p>
<p><strong>Parameters:</strong></p>
<p>w Desired width in pixels.</p>
<p>h Desired height in pixels.</p>
<p>glInternalFormat OpenGL internal data format: <code>GL_RGBA</code>, <code>GL_LUMINANCE</code>, etc.</p>
</div><div class="desc"><p>This is the call to allocate opengl texture. The width (w) and height (h) do not necessarily need to be powers of 2, but they do need to be large enough to contain the data you will upload to the texture.  The internal data type describes how opengl will store this texture internally. For example, if you want a grayscale texture, you can use "GL_LUMINANCE". You can uplaod what ever type of data you want (using loadData()) but internally, opengl will store the information as grayscale. Other types include: GL_RGB, GL_RGBA.
You need to allocate the texture before drawing it or loading data into it.
uses the currently set OF texture type - default ARB texture</p>
</div></div><hr></section><section name="allocate" id="allocate" class="mb2"><div class="method mb2"><h3 class="f3 title">allocate( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">allocate</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">int</span> w<span class="token punctuation">,</span> <span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> glInternalFormat<span class="token punctuation">,</span> <span class="token keyword">bool</span> bUseARBExtension</code><span class="token punctuation">)</span></code><div class="short"><p>Allocate texture of a given size and format. Specify texture type.</p>
<p>This allows to enable the ARBE extension for this texture.
This will overide the default OF texture type, in case you need a
square texture (<code>GL_TEXTURE_2D</code>).</p>
<p><strong>Warning</strong>: ARB textures are not available in OpenGL ES.</p>
<p><strong>See also</strong>: ofEnableArbTex()</p>
<p><strong>See also</strong>: allocate(int w, int h, int glInternalFormat)</p>
<p><strong>Parameters:</strong></p>
<p>w Desired width in pixels.</p>
<p>h Desired height in pixels.</p>
<p>glInternalFormat The internal openGL format.</p>
<p>bUseARBExtension Set to true to use rectangular textures.</p>
</div><div class="desc"><p>See previous allocate for knowing the behaviour of this function. The parameter bUseARBEExtension allow the user to enable the ARBE extension for this texture.
You need to allocate the texture before drawing it or loading data into it, lets you overide the default OF texture type</p>
</div></div><hr></section><section name="allocate" id="allocate" class="mb2"><div class="method mb2"><h3 class="f3 title">allocate( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">allocate</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">int</span> w<span class="token punctuation">,</span> <span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> glInternalFormat<span class="token punctuation">,</span> <span class="token keyword">bool</span> bUseARBExtension<span class="token punctuation">,</span> <span class="token keyword">int</span> glFormat<span class="token punctuation">,</span> <span class="token keyword">int</span> pixelType</code><span class="token punctuation">)</span></code><div class="short"><p>Allocate texture of a given size, format, & type.</p>
<p><strong>See also</strong>: allocate(int w, int h, int glInternalFormat)</p>
<p><strong>Parameters:</strong></p>
<p>w Desired width in pixels.</p>
<p>h Desired height in pixels.</p>
<p>glInternalFormat OpenGL data format: <code>GL_RGBA</code>, <code>GL_LUMINANCE</code>, etc.</p>
<p>bUseARBExtension Set to true to use rectangular textures.</p>
<p>glFormat The OpenGL format.</p>
<p>pixelType OpenGL pixel type: <code>GL_UNSIGNED_BYTE</code>, <code>GL_FLOAT</code>, etc.</p>
</div><div class="desc"></div></div><hr></section><section name="allocate" id="allocate" class="mb2"><div class="method mb2"><h3 class="f3 title">allocate( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">allocate</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">int</span> w<span class="token punctuation">,</span> <span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> glInternalFormat<span class="token punctuation">,</span> <span class="token keyword">int</span> glFormat<span class="token punctuation">,</span> <span class="token keyword">int</span> pixelType</code><span class="token punctuation">)</span></code><div class="short"><p>Allocate texture of a given size and format.</p>
<p><strong>See also</strong>: allocate(int w, int h, int glInternalFormat)</p>
<p><strong>Parameters:</strong></p>
<p>w Desired width in pixels.</p>
<p>h Desired height in pixels.</p>
<p>glInternalFormat The internal openGL format.</p>
<p>glFormat The openGL format.</p>
<p>pixelType GL pixel type: GL_UNSIGNED_BYTE, GL_FLOAT, etc.</p>
</div><div class="desc"></div></div><hr></section><section name="allocateAsBufferTexture" id="allocateAsBufferTexture" class="mb2"><div class="method mb2"><h3 class="f3 title">allocateAsBufferTexture( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">allocateAsBufferTexture</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> ofBufferObject <span class="token operator">&</span>buffer<span class="token punctuation">,</span> <span class="token keyword">int</span> glInternalFormat</code><span class="token punctuation">)</span></code><div class="short"><p>Allocate texture as a Buffer Texture.</p>
<p>Uses a GPU buffer as data for the texture instead of pixels in RAM
Allows to use texture buffer objects (TBO) which make it easier to send big
amounts of data to a shader as a uniform.</p>
<p>Buffer textures are 1D textures, and may only be sampled using texelFetch
in GLSL.</p>
<p>See textureBufferInstanceExample and https://www.opengl.org/wiki/Buffer_Texture</p>
<p><strong>See also</strong>: allocate(const ofBufferObject & buffer, int glInternalFormat)</p>
<p><strong>Parameters:</strong></p>
<p>buffer Reference to ofBufferObject instance.</p>
<p>glInternalFormat Internal pixel format of the data.</p>
</div><div class="desc"></div></div><hr></section><section name="bind" id="bind" class="mb2"><div class="method mb2"><h3 class="f3 title">bind( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">bind</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">int</span> textureLocation<span class="token operator">=</span><span class="token number">0</span></code><span class="token punctuation">)</span></code><div class="short"><p>Bind the texture.</p>
<p>For advanced users who need to manually manage texture drawing without
calling ofTexture::draw.</p>
<p><strong>See also</strong>: http://www.opengl.org/sdk/docs/man4/html/glBindTexture.xhtml</p>
</div><div class="desc"><p>This is for the advanced user who wants to draw textures in their own way. Each set of vertices that you draw after calling bind() will be textured using this texture.</p>
</div></div><hr></section><section name="bindAsImage" id="bindAsImage" class="mb2"><div class="method mb2"><h3 class="f3 title">bindAsImage( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">bindAsImage</span><span class="token punctuation">(</span><code class="token boolean">GLuint unit<span class="token punctuation">,</span> GLenum access<span class="token punctuation">,</span> GLint level<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> GLboolean layered<span class="token punctuation">,</span> GLint layer<span class="token operator">=</span><span class="token number">0</span></code><span class="token punctuation">)</span></code><div class="short"><p>Calls glBindImageTexture on the texture</p>
<p>Binds the texture as an read or write image, only available since OpenGL 4.2</p>
<p><strong>Warning</strong>: This is not available in OpenGLES</p>
<p><strong>See also</strong>: http://www.opengl.org/wiki/GLAPI/glBindImageTexture</p>
</div><div class="desc"></div></div><hr></section><section name="clear" id="clear" class="mb2"><div class="method mb2"><h3 class="f3 title">clear( <!----> )</h3><code><span class="token keyword">void  </span><span class="token function">clear</span><span class="token punctuation">(</span><!----><span class="token punctuation">)</span></code><div class="short"><p>Clears the texture.</p>
<p>Clears / frees the texture memory, if something was already allocated.
Useful if you need to control the memory on the graphics card.</p>
<p>The internal GL texture ID is only released if this is the last texture
using it.</p>
</div><div class="desc"><p>clears / frees the texture memory, if something was already allocated. useful if you need to control the memory on the graphics card.
Clears all the data from the texture</p>
</div></div><hr></section><section name="copyTo" id="copyTo" class="mb2"><div class="method mb2"><h3 class="f3 title">copyTo( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">copyTo</span><span class="token punctuation">(</span><code class="token boolean">ofBufferObject <span class="token operator">&</span>buffer</code><span class="token punctuation">)</span></code><div class="short"><p>Copy the texture to an ofBufferObject.</p>
<p><strong>Parameters:</strong></p>
<p>buffer the target buffer to copy to.</p>
</div><div class="desc"></div></div><hr></section><section name="disableAlphaMask" id="disableAlphaMask" class="mb2"><div class="method mb2"><h3 class="f3 title">disableAlphaMask( <!----> )</h3><code><span class="token keyword">void  </span><span class="token function">disableAlphaMask</span><span class="token punctuation">(</span><!----><span class="token punctuation">)</span></code><div class="short"><p>Disable the alpha mask.</p>
</div><div class="desc"></div></div><hr></section><section name="disableMipmap" id="disableMipmap" class="mb2"><div class="method mb2"><h3 class="f3 title">disableMipmap( <!----> )</h3><code><span class="token keyword">void  </span><span class="token function">disableMipmap</span><span class="token punctuation">(</span><!----><span class="token punctuation">)</span></code><div class="short"><p>Sets flag disallowing texture to auto-generate mipmap.</p>
<p>By default, this will set your minFilter to GL_LINEAR_MIPMAP_LINEAR.
If you want to change your minFilter later use setTextureMinMagFilter()</p>
<pre><code>If you want to generate a mipmap later, or at a specific
</code></pre>
<p>point in your code, use ofTexture::generateMipmap() instead.</p>
<p><strong>See also</strong>: generateMipmap()</p>
<p><strong>See also</strong>: enableMipmap()</p>
<p><strong>See also</strong>: setTextureMinMagFilter()</p>
</div><div class="desc"></div></div><hr></section><section name="disableTextureMatrix" id="disableTextureMatrix" class="mb2"><div class="method mb2"><h3 class="f3 title">disableTextureMatrix( <!----> )</h3><code><span class="token keyword">void  </span><span class="token function">disableTextureMatrix</span><span class="token punctuation">(</span><!----><span class="token punctuation">)</span></code><div class="short"><p>Disable the texture matrix.
Disable the texture matrix.</p>
</div><div class="desc"></div></div><hr></section><section name="disableTextureTarget" id="disableTextureTarget" class="mb2"><div class="method mb2"><h3 class="f3 title">disableTextureTarget( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">disableTextureTarget</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">int</span> textureLocation</code><span class="token punctuation">)</span></code><div class="short"><p>Disable a texture target.</p>
<p><strong>Parameters:</strong></p>
<p>textureLocation the OpenGL texture ID to enable as a target.</p>
</div><div class="desc"></div></div><hr></section><section name="draw" id="draw" class="mb2"><div class="method mb2"><h3 class="f3 title">draw( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">draw</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> glm<span class="token operator">::</span>vec3 <span class="token operator">&</span>p1<span class="token punctuation">,</span> <span class="token keyword">const</span> glm<span class="token operator">::</span>vec3 <span class="token operator">&</span>p2<span class="token punctuation">,</span> <span class="token keyword">const</span> glm<span class="token operator">::</span>vec3 <span class="token operator">&</span>p3<span class="token punctuation">,</span> <span class="token keyword">const</span> glm<span class="token operator">::</span>vec3 <span class="token operator">&</span>p4</code><span class="token punctuation">)</span></code><div class="short"><p>Draws the texture at 4 points passed in as if you created 4 glVertices.</p>
<p><strong>Parameters:</strong></p>
<p>p1 Upper left position on the x axis.</p>
<p>p2 Upper left position on the y axis.</p>
<p>p3 Lower right position on the x axis.</p>
<p>p4 Lower right position on the y axis.</p>
</div><div class="desc"></div></div><hr></section><section name="draw" id="draw" class="mb2"><div class="method mb2"><h3 class="f3 title">draw( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">draw</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> glm<span class="token operator">::</span>vec3 <span class="token operator">&</span>pos</code><span class="token punctuation">)</span></code><div class="short"></div><div class="desc"></div></div><hr></section><section name="draw" id="draw" class="mb2"><div class="method mb2"><h3 class="f3 title">draw( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">draw</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> glm<span class="token operator">::</span>vec3 <span class="token operator">&</span>pos<span class="token punctuation">,</span> <span class="token keyword">float</span> w<span class="token punctuation">,</span> <span class="token keyword">float</span> h</code><span class="token punctuation">)</span></code><div class="short"></div><div class="desc"><p>Draws the texture at 4 points passed in as if you created 4 glVertices.</p>
</div></div><hr></section><section name="draw" id="draw" class="mb2"><div class="method mb2"><h3 class="f3 title">draw( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">draw</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> x<span class="token punctuation">,</span> <span class="token keyword">float</span> y</code><span class="token punctuation">)</span></code><div class="short"><p>\section Drawing</p>
</div><div class="desc"><p>Draws the texture at a given point (x,y), using the textures true width and height.
Draws the texture at the point passed in.</p>
</div></div><hr></section><section name="draw" id="draw" class="mb2"><div class="method mb2"><h3 class="f3 title">draw( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">draw</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> x<span class="token punctuation">,</span> <span class="token keyword">float</span> y<span class="token punctuation">,</span> <span class="token keyword">float</span> w<span class="token punctuation">,</span> <span class="token keyword">float</span> h</code><span class="token punctuation">)</span></code><div class="short"></div><div class="desc"><p>draws the texture at a given point (x,y), with a given width (w) and height (h).
Draws the texture at the x, y and w, h.</p>
</div></div><hr></section><section name="draw" id="draw" class="mb2"><div class="method mb2"><h3 class="f3 title">draw( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">draw</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> x<span class="token punctuation">,</span> <span class="token keyword">float</span> y<span class="token punctuation">,</span> <span class="token keyword">float</span> z</code><span class="token punctuation">)</span></code><div class="short"></div><div class="desc"><p>Draws the texture at the point passed in in 3D space.</p>
</div></div><hr></section><section name="draw" id="draw" class="mb2"><div class="method mb2"><h3 class="f3 title">draw( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">draw</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> x<span class="token punctuation">,</span> <span class="token keyword">float</span> y<span class="token punctuation">,</span> <span class="token keyword">float</span> z<span class="token punctuation">,</span> <span class="token keyword">float</span> w<span class="token punctuation">,</span> <span class="token keyword">float</span> h</code><span class="token punctuation">)</span></code><div class="short"><p>Draw the texture at a given size witdh and depth.</p>
<p><strong>Parameters:</strong></p>
<p>x Draw position on the x axis.</p>
<p>y Draw position on the y axis.</p>
<p>z Draw position on the z axis.</p>
<p>w Draw width.</p>
<p>h Draw height.</p>
</div><div class="desc"><p>Draws the texture at the x, y, z in 3D space with the width and height at w,h.</p>
</div></div><hr></section><section name="drawSubsection" id="drawSubsection" class="mb2"><div class="method mb2"><h3 class="f3 title">drawSubsection( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">drawSubsection</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> ofRectangle <span class="token operator">&</span>drawBounds<span class="token punctuation">,</span> <span class="token keyword">const</span> ofRectangle <span class="token operator">&</span>subsectionBounds</code><span class="token punctuation">)</span></code><div class="short"><p>Draw a subsection of the texture with an offset.</p>
<p><strong>See also</strong>: drawSubsection(ofRectangle& drawBounds, ofRectangle& subsectionBounds)</p>
<p><strong>Parameters:</strong></p>
<p>drawBounds Draw position and dimensions.</p>
<p>subsectionBounds Subsection position and dimensions within the texture.</p>
</div><div class="desc"></div></div><hr></section><section name="drawSubsection" id="drawSubsection" class="mb2"><div class="method mb2"><h3 class="f3 title">drawSubsection( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">drawSubsection</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> x<span class="token punctuation">,</span> <span class="token keyword">float</span> y<span class="token punctuation">,</span> <span class="token keyword">float</span> w<span class="token punctuation">,</span> <span class="token keyword">float</span> h<span class="token punctuation">,</span> <span class="token keyword">float</span> sx<span class="token punctuation">,</span> <span class="token keyword">float</span> sy</code><span class="token punctuation">)</span></code><div class="short"><p>Draw a subsection of the texture.</p>
<p>Like ofRect() depend on the current <code>OF_RECT_MODE</code>:</p>
<ul>
<li><code>OF_RECT_MODE_CORNER</code>: drawn with the upper left corner = (x,y)</li>
<li><code>OF_RECT_MODE_CENTER</code>: drawn centered on (x,y)</li>
</ul>
<p><strong>See also</strong>: ofSetRectMode()</p>
<p><strong>Parameters:</strong></p>
<p>x Draw position on the x axis.</p>
<p>y Draw position on the y axis.</p>
<p>w Draw width.</p>
<p>h Draw height.</p>
<p>sx Subsection x axis offset within the texture.</p>
<p>sy Subsection y axis offset within the texture.</p>
</div><div class="desc"></div></div><hr></section><section name="drawSubsection" id="drawSubsection" class="mb2"><div class="method mb2"><h3 class="f3 title">drawSubsection( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">drawSubsection</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> x<span class="token punctuation">,</span> <span class="token keyword">float</span> y<span class="token punctuation">,</span> <span class="token keyword">float</span> w<span class="token punctuation">,</span> <span class="token keyword">float</span> h<span class="token punctuation">,</span> <span class="token keyword">float</span> sx<span class="token punctuation">,</span> <span class="token keyword">float</span> sy<span class="token punctuation">,</span> <span class="token keyword">float</span> sw<span class="token punctuation">,</span> <span class="token keyword">float</span> sh</code><span class="token punctuation">)</span></code><div class="short"><p>Draw a subsection of the texture with an offset.</p>
<p><strong>See also</strong>: drawSubsection(float x, float y, float w, float h, float sx, float sy)</p>
<p><strong>Parameters:</strong></p>
<p>x Draw position on the x axis.</p>
<p>y Draw position on the y axis.</p>
<p>w Draw width.</p>
<p>h Draw height.</p>
<p>sx Subsection x axis offset within the texture.</p>
<p>sy Subsection y axis offset within the texture.</p>
<p>sw Subsection width within the texture.</p>
<p>sh Subsection height within the texture.</p>
</div><div class="desc"></div></div><hr></section><section name="drawSubsection" id="drawSubsection" class="mb2"><div class="method mb2"><h3 class="f3 title">drawSubsection( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">drawSubsection</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> x<span class="token punctuation">,</span> <span class="token keyword">float</span> y<span class="token punctuation">,</span> <span class="token keyword">float</span> z<span class="token punctuation">,</span> <span class="token keyword">float</span> w<span class="token punctuation">,</span> <span class="token keyword">float</span> h<span class="token punctuation">,</span> <span class="token keyword">float</span> sx<span class="token punctuation">,</span> <span class="token keyword">float</span> sy</code><span class="token punctuation">)</span></code><div class="short"><p>Draw a subsection of the texture with depth.</p>
<p><strong>See also</strong>: drawSubsection(float x, float y, float w, float h, float sx, float sy)</p>
<p><strong>Parameters:</strong></p>
<p>x Draw position on the x axis.</p>
<p>y Draw position on the y axis.</p>
<p>z Draw position on the z axis.</p>
<p>w Draw width.</p>
<p>h Draw height.</p>
<p>sx Subsection x axis offset within the texture.</p>
<p>sy Subsection y axis offset within the texture.</p>
</div><div class="desc"></div></div><hr></section><section name="drawSubsection" id="drawSubsection" class="mb2"><div class="method mb2"><h3 class="f3 title">drawSubsection( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">drawSubsection</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> x<span class="token punctuation">,</span> <span class="token keyword">float</span> y<span class="token punctuation">,</span> <span class="token keyword">float</span> z<span class="token punctuation">,</span> <span class="token keyword">float</span> w<span class="token punctuation">,</span> <span class="token keyword">float</span> h<span class="token punctuation">,</span> <span class="token keyword">float</span> sx<span class="token punctuation">,</span> <span class="token keyword">float</span> sy<span class="token punctuation">,</span> <span class="token keyword">float</span> sw<span class="token punctuation">,</span> <span class="token keyword">float</span> sh</code><span class="token punctuation">)</span></code><div class="short"><p>Draw a subsection of the texture with an offset and depth.</p>
<p><strong>See also</strong>: drawSubsection(float x, float y, float w, float h, float sx, float sy)</p>
<p><strong>Parameters:</strong></p>
<p>x Draw position on the x axis.</p>
<p>y Draw position on the y axis.</p>
<p>z Draw position on the z axis.</p>
<p>w Draw width.</p>
<p>h Draw height.</p>
<p>sx Subsection x axis offset within the texture.</p>
<p>sy Subsection y axis offset within the texture.</p>
<p>sw Subsection width within the texture.</p>
<p>sh Subsection height within the texture.</p>
</div><div class="desc"></div></div><hr></section><section name="enableMipmap" id="enableMipmap" class="mb2"><div class="method mb2"><h3 class="f3 title">enableMipmap( <!----> )</h3><code><span class="token keyword">void  </span><span class="token function">enableMipmap</span><span class="token punctuation">(</span><!----><span class="token punctuation">)</span></code><div class="short"><p>\section Mipmapping
Sets flag allowing texture to auto-generate a mipmap.</p>
<p>By default, this will set your minFilter to GL_LINEAR_MIPMAP_LINEAR.
If you want to change your minFilter later use setTextureMinMagFilter()</p>
<pre><code>If you want to generate a mipmap later, or at a specific
</code></pre>
<p>point in your code, use generateMipmap() instead.</p>
<p><strong>See also</strong>: generateMipmap()</p>
<p><strong>See also</strong>: disableMipmap()</p>
<p><strong>See also</strong>: setTextureMinMagFilter()</p>
</div><div class="desc"></div></div><hr></section><section name="enableTextureTarget" id="enableTextureTarget" class="mb2"><div class="method mb2"><h3 class="f3 title">enableTextureTarget( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">enableTextureTarget</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">int</span> textureLocation</code><span class="token punctuation">)</span></code><div class="short"><p>Enable a texture target.</p>
<p><strong>Parameters:</strong></p>
<p>textureLocation the OpenGL texture ID to enable as a target.</p>
</div><div class="desc"></div></div><hr></section><section name="generateMipmap" id="generateMipmap" class="mb2"><div class="method mb2"><h3 class="f3 title">generateMipmap( <!----> )</h3><code><span class="token keyword">void  </span><span class="token function">generateMipmap</span><span class="token punctuation">(</span><!----><span class="token punctuation">)</span></code><div class="short"><p>Generate mipmap for the current texture.</p>
<p><strong>Warning</strong>: Only GL_TEXTURE_RECTANGLE - which is the default openFrameworks
texture target - does <em>not</em> support mipmaps, so make sure to call
ofDisableArbTex() before loading texture
data for a texture you want to generate mipmaps for.</p>
<p><strong>See also</strong>: ofEnableArbTex()</p>
<p><strong>See also</strong>: ofDisableArbTex()</p>
</div><div class="desc"></div></div><hr></section><section name="getAlphaMask" id="getAlphaMask" class="mb2"><div class="method mb2"><h3 class="f3 title">getAlphaMask( <!----> )</h3><code><span class="token keyword">const ofTexture *  </span><span class="token function">getAlphaMask</span><span class="token punctuation">(</span><!----><span class="token punctuation">)</span></code><div class="short"></div><div class="desc"></div></div><hr></section><section name="getCoordFromPercent" id="getCoordFromPercent" class="mb2"><div class="method mb2"><h3 class="f3 title">getCoordFromPercent( <code class="pink">...</code> )</h3><code><span class="token keyword">glm::vec2  </span><span class="token function">getCoordFromPercent</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> xPts<span class="token punctuation">,</span> <span class="token keyword">float</span> yPts</code><span class="token punctuation">)</span></code><div class="short"><p>Helper to convert display coordinate to texture coordinate.</p>
<p><strong>Parameters:</strong></p>
<p>xPts Horizontal position in a normalized percentage (0 - 1).</p>
<p>yPts Vertical position in a normalized percentage (0 - 1).</p>
<p><strong>Returns</strong>: Texture coordinate or zero if texture is not allocated.</p>
</div><div class="desc"></div></div><hr></section><section name="getCoordFromPoint" id="getCoordFromPoint" class="mb2"><div class="method mb2"><h3 class="f3 title">getCoordFromPoint( <code class="pink">...</code> )</h3><code><span class="token keyword">glm::vec2  </span><span class="token function">getCoordFromPoint</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> xPos<span class="token punctuation">,</span> <span class="token keyword">float</span> yPos</code><span class="token punctuation">)</span></code><div class="short"><p>Helper to convert display coordinate to texture coordinate.</p>
<p><strong>Parameters:</strong></p>
<p>xPos Horizontal position in pixels.</p>
<p>yPos Vertical position in pixels.</p>
<p><strong>Returns</strong>: Texture coordinate or zero if texture is not allocated.</p>
</div><div class="desc"><p>these are helpers to allow you to get points for the texture ala "glTexCoordf" but are texture type independent. use them for immediate or non immediate mode</p>
</div></div><hr></section><section name="getHeight" id="getHeight" class="mb2"><div class="method mb2"><h3 class="f3 title">getHeight( <!----> )</h3><code><span class="token keyword">float  </span><span class="token function">getHeight</span><span class="token punctuation">(</span><!----><span class="token punctuation">)</span></code><div class="short"><p>\section Size and Coordinates
Display height of texture.</p>
<p>Return value is pixel size (default) or normalized (0 - 1) if ofEnableNormalizedTextures() is set to true.</p>
<p><strong>See also</strong>: ofEnabledNormalizedTextures()</p>
<p><strong>Returns</strong>: Display height of texture in pixels.</p>
</div><div class="desc"><p>Returns the height of the texture. This will be in pixels unless you've set your application to use normalized coordinates.</p>
</div></div><hr></section><section name="getMeshForSubsection" id="getMeshForSubsection" class="mb2"><div class="method mb2"><h3 class="f3 title">getMeshForSubsection( <code class="pink">...</code> )</h3><code><span class="token keyword">ofMesh  </span><span class="token function">getMeshForSubsection</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> x<span class="token punctuation">,</span> <span class="token keyword">float</span> y<span class="token punctuation">,</span> <span class="token keyword">float</span> z<span class="token punctuation">,</span> <span class="token keyword">float</span> w<span class="token punctuation">,</span> <span class="token keyword">float</span> h<span class="token punctuation">,</span> <span class="token keyword">float</span> sx<span class="token punctuation">,</span> <span class="token keyword">float</span> sy<span class="token punctuation">,</span> <span class="token keyword">float</span> sw<span class="token punctuation">,</span> <span class="token keyword">float</span> sh<span class="token punctuation">,</span> <span class="token keyword">bool</span> vflipped<span class="token punctuation">,</span> ofRectMode rectMode</code><span class="token punctuation">)</span></code><div class="short"><p>Get a mesh that has the texture coordinates set.</p>
<p><strong>See also</strong>: drawSubsection(float x, float y, float w, float h, float sx, float sy)</p>
<p><strong>Parameters:</strong></p>
<p>x Draw position on the x axis.</p>
<p>y Draw position on the y axis.</p>
<p>z Draw position on the z axis.</p>
<p>w Draw width.</p>
<p>h Draw height.</p>
<p>sx Subsection x axis offset within the texture.</p>
<p>sy Subsection y axis offset within the texture.</p>
<p>sw Subsection width within the texture.</p>
<p>sh Subsection height within the texture.</p>
<p>vflipped Takes into account the flipped state in OF.</p>
<p>rectMode rectMode Taking x,y as the center or the top left corner.</p>
</div><div class="desc"></div></div><hr></section><section name="getQuad" id="getQuad" class="mb2"><div class="method mb2"><h3 class="f3 title">getQuad( <code class="pink">...</code> )</h3><code><span class="token keyword">ofMesh  </span><span class="token function">getQuad</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> glm<span class="token operator">::</span>vec3 <span class="token operator">&</span>p1<span class="token punctuation">,</span> <span class="token keyword">const</span> glm<span class="token operator">::</span>vec3 <span class="token operator">&</span>p2<span class="token punctuation">,</span> <span class="token keyword">const</span> glm<span class="token operator">::</span>vec3 <span class="token operator">&</span>p3<span class="token punctuation">,</span> <span class="token keyword">const</span> glm<span class="token operator">::</span>vec3 <span class="token operator">&</span>p4</code><span class="token punctuation">)</span></code><div class="short"></div><div class="desc"></div></div><hr></section><section name="getTextureData" id="getTextureData" class="mb2"><div class="method mb2"><h3 class="f3 title">getTextureData( <!----> )</h3><code><span class="token keyword">ofTextureData &  </span><span class="token function">getTextureData</span><span class="token punctuation">(</span><!----><span class="token punctuation">)</span></code><div class="short"><p>\section Texture Data
Internal texture data access.</p>
<p>This returns the internal texture data for this texture, for instance,
its textureID, type of texture, whether it's been allocated and other
data about the state of the texture.</p>
<p><strong>Returns</strong>: a reference to the internal texture data struct.</p>
</div><div class="desc"></div></div><hr></section><section name="getTextureData" id="getTextureData" class="mb2"><div class="method mb2"><h3 class="f3 title">getTextureData( <!----> )</h3><code><span class="token keyword">const ofTextureData &  </span><span class="token function">getTextureData</span><span class="token punctuation">(</span><!----><span class="token punctuation">)</span></code><div class="short"><p>Const version of getTextureData().</p>
<p><strong>See also</strong>: ofTextureData::getTextureData()</p>
</div><div class="desc"><p>This returns the internal texture data for this texture, for instance, its textureID, type of texture, whether it's been allocated, and other data about the state of the texture.</p>
</div></div><hr></section><section name="getTextureMatrix" id="getTextureMatrix" class="mb2"><div class="method mb2"><h3 class="f3 title">getTextureMatrix( <!----> )</h3><code><span class="token keyword">const glm::mat4 &  </span><span class="token function">getTextureMatrix</span><span class="token punctuation">(</span><!----><span class="token punctuation">)</span></code><div class="short"></div><div class="desc"></div></div><hr></section><section name="getWidth" id="getWidth" class="mb2"><div class="method mb2"><h3 class="f3 title">getWidth( <!----> )</h3><code><span class="token keyword">float  </span><span class="token function">getWidth</span><span class="token punctuation">(</span><!----><span class="token punctuation">)</span></code><div class="short"><p>Display width of texture.</p>
<p>Return value is pixel size (default) or normalized (0 - 1) if ofEnableNormalizedTextures() is set to true.</p>
<p><strong>See also</strong>: ofEnabledNormalizedTextures()</p>
<p><strong>Returns</strong>: Display width of texture in pixels.</p>
</div><div class="desc"><p>Returns the width of the texture. This will be in pixels unless you've set your application to use normalized coordinates.</p>
</div></div><hr></section><section name="hasMipmap" id="hasMipmap" class="mb2"><div class="method mb2"><h3 class="f3 title">hasMipmap( <!----> )</h3><code><span class="token keyword">bool  </span><span class="token function">hasMipmap</span><span class="token punctuation">(</span><!----><span class="token punctuation">)</span></code><div class="short"><p>Find out if a mipmap has been generated for the current texture.</p>
<p><strong>See also</strong>: generateMipmap()</p>
<p><strong>See also</strong>: enableMipmap()</p>
</div><div class="desc"></div></div><hr></section><section name="isAllocated" id="isAllocated" class="mb2"><div class="method mb2"><h3 class="f3 title">isAllocated( <!----> )</h3><code><span class="token keyword">bool  </span><span class="token function">isAllocated</span><span class="token punctuation">(</span><!----><span class="token punctuation">)</span></code><div class="short"><p>Determine whether the texture has been allocated.</p>
<p>This lets you check if a texture is safe to draw.  The texture can both
be allocated by using <code>allocate()</code> or loading it with data <code>loadData()</code>.</p>
<p><strong>Returns</strong>: true if the texture has been allocated.</p>
</div><div class="desc"><p>Get whether the texture has been allocated.
ofTextureData getTextureData() ###
// reference to the actual textureData inside the smart pointer
// for backwards compatibility
ofTextureData texData ###
float getHeight() ###
float getWidth() ###</p>
</div></div><hr></section><section name="isUsingTextureMatrix" id="isUsingTextureMatrix" class="mb2"><div class="method mb2"><h3 class="f3 title">isUsingTextureMatrix( <!----> )</h3><code><span class="token keyword">bool  </span><span class="token function">isUsingTextureMatrix</span><span class="token punctuation">(</span><!----><span class="token punctuation">)</span></code><div class="short"></div><div class="desc"></div></div><hr></section><section name="loadData" id="loadData" class="mb2"><div class="method mb2"><h3 class="f3 title">loadData( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">loadData</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> ofBufferObject <span class="token operator">&</span>buffer<span class="token punctuation">,</span> <span class="token keyword">int</span> glFormat<span class="token punctuation">,</span> <span class="token keyword">int</span> glType</code><span class="token punctuation">)</span></code><div class="short"><p>Load pixels from an ofBufferObject</p>
<p>This is different to allocate(ofBufferObject,internal). That
creates a texture which data lives in GL buffer while this
copies the data from the buffer to the texture.</p>
<p>This is usually used to upload data to be shown asynchronously
by using a buffer object binded as a PBO</p>
<p><strong>Parameters:</strong></p>
<p>buffer The buffer to load.</p>
<p>glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.</p>
<p>glType the GL type to load.</p>
</div><div class="desc"></div></div><hr></section><section name="loadData" id="loadData" class="mb2"><div class="method mb2"><h3 class="f3 title">loadData( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">loadData</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> ofPixels <span class="token operator">&</span>pix</code><span class="token punctuation">)</span></code><div class="short"><p>Load pixels from an ofPixels instance.</p>
<p><strong>Parameters:</strong></p>
<p>pix Reference to ofPixels instance.</p>
</div><div class="desc"></div></div><hr></section><section name="loadData" id="loadData" class="mb2"><div class="method mb2"><h3 class="f3 title">loadData( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">loadData</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> ofShortPixels <span class="token operator">&</span>pix</code><span class="token punctuation">)</span></code><div class="short"><p>Load pixels from an ofShortPixels instance.</p>
<p>Same as loadData(ofPixels &) but for ofShortPixels.</p>
<p><strong>See also</strong>: loadData(const ofPixels & pix)</p>
<p><strong>Parameters:</strong></p>
<p>pix Reference to ofShortPixels instance.</p>
</div><div class="desc"></div></div><hr></section><section name="loadData" id="loadData" class="mb2"><div class="method mb2"><h3 class="f3 title">loadData( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">loadData</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> ofFloatPixels <span class="token operator">&</span>pix</code><span class="token punctuation">)</span></code><div class="short"><p>Load pixels from an ofFloatPixels instance.</p>
<p>Same as loadData(ofPixels &) but for ofFloatPixels.</p>
<p><strong>See also</strong>: loadData(const ofPixels & pix)</p>
<p><strong>Parameters:</strong></p>
<p>pix Reference to ofFloatPixels instance.</p>
</div><div class="desc"></div></div><hr></section><section name="loadData" id="loadData" class="mb2"><div class="method mb2"><h3 class="f3 title">loadData( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">loadData</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> ofPixels <span class="token operator">&</span>pix<span class="token punctuation">,</span> <span class="token keyword">int</span> glFormat</code><span class="token punctuation">)</span></code><div class="short"><p>Load pixels from an ofPixels instance and specify the format.</p>
<p>glFormat can be different to the internal format of the texture on each
load, ie. we can upload GL_BGRA pixels into a GL_RGBA texture, but the
number of channels need to match according to the OpenGL standard.</p>
<p><strong>Parameters:</strong></p>
<p>pix Reference to ofPixels instance.</p>
<p>glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.</p>
</div><div class="desc"></div></div><hr></section><section name="loadData" id="loadData" class="mb2"><div class="method mb2"><h3 class="f3 title">loadData( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">loadData</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> ofShortPixels <span class="token operator">&</span>pix<span class="token punctuation">,</span> <span class="token keyword">int</span> glFormat</code><span class="token punctuation">)</span></code><div class="short"><p>Load pixels from an ofShortPixels instance & specify the format.</p>
<p><strong>See also</strong>: loadData(const ofPixels & pix, int glFormat)</p>
<p><strong>Parameters:</strong></p>
<p>pix Reference to ofShortPixels instance.</p>
<p>glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.</p>
</div><div class="desc"></div></div><hr></section><section name="loadData" id="loadData" class="mb2"><div class="method mb2"><h3 class="f3 title">loadData( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">loadData</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> ofFloatPixels <span class="token operator">&</span>pix<span class="token punctuation">,</span> <span class="token keyword">int</span> glFormat</code><span class="token punctuation">)</span></code><div class="short"><p>Load pixels from an ofFloatPixels instance and specify the format.</p>
<p><strong>See also</strong>: loadData(const ofPixels & pix, int glFormat)</p>
<p><strong>Parameters:</strong></p>
<p>pix Reference to ofFloatPixels instance.</p>
<p>glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.</p>
</div><div class="desc"></div></div><hr></section><section name="loadData" id="loadData" class="mb2"><div class="method mb2"><h3 class="f3 title">loadData( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">loadData</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> uint16_t <span class="token operator">*</span>data<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">,</span> <span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> glFormat</code><span class="token punctuation">)</span></code><div class="short"><p>Load short (2 byte) pixel data.</p>
<p><strong>See also</strong>: loadData(const unsigned char* const data, int w, int h, int glFormat)</p>
<p><strong>Parameters:</strong></p>
<p>data Pointer to byte pixel data. Must not be nullptr.</p>
<p>w Pixel data width.</p>
<p>h Pixel data height.</p>
<p>glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.</p>
</div><div class="desc"></div></div><hr></section><section name="loadData" id="loadData" class="mb2"><div class="method mb2"><h3 class="f3 title">loadData( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">loadData</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> uint32_t <span class="token operator">*</span>data<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">,</span> <span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> glFormat</code><span class="token punctuation">)</span></code><div class="short"></div><div class="desc"></div></div><hr></section><section name="loadData" id="loadData" class="mb2"><div class="method mb2"><h3 class="f3 title">loadData( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">loadData</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> int8_t <span class="token operator">*</span>data<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">,</span> <span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> glFormat</code><span class="token punctuation">)</span></code><div class="short"></div><div class="desc"></div></div><hr></section><section name="loadData" id="loadData" class="mb2"><div class="method mb2"><h3 class="f3 title">loadData( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">loadData</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> int16_t <span class="token operator">*</span>data<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">,</span> <span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> glFormat</code><span class="token punctuation">)</span></code><div class="short"></div><div class="desc"></div></div><hr></section><section name="loadData" id="loadData" class="mb2"><div class="method mb2"><h3 class="f3 title">loadData( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">loadData</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> int32_t <span class="token operator">*</span>data<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">,</span> <span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> glFormat</code><span class="token punctuation">)</span></code><div class="short"></div><div class="desc"></div></div><hr></section><section name="loadData" id="loadData" class="mb2"><div class="method mb2"><h3 class="f3 title">loadData( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">loadData</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> <span class="token keyword">float</span> <span class="token operator">*</span>data<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">,</span> <span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> glFormat</code><span class="token punctuation">)</span></code><div class="short"><p>Load float pixel data.</p>
<p><strong>See also</strong>: loadData(const unsigned char* const data, int w, int h, int glFormat)</p>
<p><strong>Parameters:</strong></p>
<p>data Pointer to byte pixel data. Must not be nullptr.</p>
<p>w Pixel data width.</p>
<p>h Pixel data height.</p>
<p>glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.</p>
</div><div class="desc"></div></div><hr></section><section name="loadData" id="loadData" class="mb2"><div class="method mb2"><h3 class="f3 title">loadData( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">loadData</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">,</span> <span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> glFormat<span class="token punctuation">,</span> <span class="token keyword">int</span> glType</code><span class="token punctuation">)</span></code><div class="short"><p>Load byte pixel data.</p>
<p>glFormat can be different to the internal format of the texture on each
load, i.e. we can upload GL_BGRA pixels into a GL_RGBA texture but the
number of channels need to match according to the OpenGL standard.</p>
<p><strong>Parameters:</strong></p>
<p>data Pointer to byte pixel data. Must not be nullptr.</p>
<p>w Pixel data width.</p>
<p>h Pixel data height.</p>
<p>glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.</p>
<p>glType the OpenGL type of the data.</p>
</div><div class="desc"></div></div><hr></section><section name="loadData" id="loadData" class="mb2"><div class="method mb2"><h3 class="f3 title">loadData( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">loadData</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> uint8_t <span class="token operator">*</span><span class="token keyword">const</span> data<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">,</span> <span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> glFormat</code><span class="token punctuation">)</span></code><div class="short"><p>Load byte pixel data.</p>
<p>glFormat can be different to the internal format of the texture on each
load, i.e. we can upload GL_BGRA pixels into a GL_RGBA texture but the
number of channels need to match according to the OpenGL standard.</p>
<p><strong>Parameters:</strong></p>
<p>data Pointer to byte pixel data. Must not be nullptr.</p>
<p>w Pixel data width.</p>
<p>h Pixel data height.</p>
<p>glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.</p>
</div><div class="desc"></div></div><hr></section><section name="loadScreenData" id="loadScreenData" class="mb2"><div class="method mb2"><h3 class="f3 title">loadScreenData( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">loadScreenData</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">,</span> <span class="token keyword">int</span> h</code><span class="token punctuation">)</span></code><div class="short"><p>Copy an area of the screen into this texture.</p>
<p>Specifiy the position (x,y) you wish to grab from, with the width (w)
and height (h) of the region.</p>
<p>Make sure that you have allocated your texture (using <code>allocate()</code>)
to be large enough to hold the region of the screen you wish to load.</p>
<p><strong>See also</strong>: http://www.opengl.org/sdk/docs/man4/html/glCopyTexSubImage2D.xhtml</p>
<p><strong>Parameters:</strong></p>
<p>x Upper left corner horizontal screen position.</p>
<p>y Upper left corner vertical screen position.</p>
<p>w Width of the area to copy in pixels.</p>
<p>h Height of the area to copy in pixels.</p>
</div><div class="desc"><p>Grabs a region of the screen and loads it into the texture. Specifiy the position (x,y) you wish to grab from, with the width (w) and height (h) of the region. Make sure that you have allocated your texture (using allocate()) to be large enough to hold the region of the screen you wish to load.
Load data from the current screen into this texture. Grabs a region of the screen and loads it into the texture. Specifiy the position (x,y) you wish to grab from, with the width (w) and height (h) of the region. Make sure that you have allocated your texture (using allocate()) to be large enough to hold the region of the screen you wish to load.</p>
</div></div><hr></section><section name="ofTexture" id="ofTexture" class="mb2"><div class="method mb2"><h3 class="f3 title">ofTexture( <code class="pink">...</code> )</h3><code><!----><span class="token function">ofTexture</span><span class="token punctuation">(</span><code class="token boolean">ofTexture <span class="token operator">&&</span>mom</code><span class="token punctuation">)</span></code><div class="short"></div><div class="desc"></div></div><hr></section><section name="ofTexture" id="ofTexture" class="mb2"><div class="method mb2"><h3 class="f3 title">ofTexture( <code class="pink">...</code> )</h3><code><!----><span class="token function">ofTexture</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> ofTexture <span class="token operator">&</span>mom</code><span class="token punctuation">)</span></code><div class="short"><p>Construct an ofTexture from an existing ofTexture.</p>
<p><strong>Parameters:</strong></p>
<p>mom The ofTexture to copy. Reuses internal GL texture ID.</p>
</div><div class="desc"></div></div><hr></section><section name="ofTexture" id="ofTexture" class="mb2"><div class="method mb2"><h3 class="f3 title">ofTexture( <!----> )</h3><code><!----><span class="token function">ofTexture</span><span class="token punctuation">(</span><!----><span class="token punctuation">)</span></code><div class="short"><p>\section Construction and Allocation
Construct an ofTexture instance.</p>
</div><div class="desc"><p>Creates an empty ofTexture instance. You can't draw a texture right after it's been created as it has actually uploaded any data to the graphics card that can be drawn yet.</p>
</div></div><hr></section><section name="operator=" id="operator=" class="mb2"><div class="method mb2"><h3 class="f3 title">operator=( <code class="pink">...</code> )</h3><code><span class="token keyword">ofTexture &  </span><span class="token function">operator=</span><span class="token punctuation">(</span><code class="token boolean">ofTexture <span class="token operator">&&</span>mom</code><span class="token punctuation">)</span></code><div class="short"></div><div class="desc"></div></div><hr></section><section name="operator=" id="operator=" class="mb2"><div class="method mb2"><h3 class="f3 title">operator=( <code class="pink">...</code> )</h3><code><span class="token keyword">ofTexture &  </span><span class="token function">operator=</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> ofTexture <span class="token operator">&</span>mom</code><span class="token punctuation">)</span></code><div class="short"><p>\section Update Texture
Copy a given ofTexture into this texture.</p>
<p><strong>Parameters:</strong></p>
<p>mom The ofTexture to copy from. Reuses internal GL texture ID.</p>
</div><div class="desc"></div></div><hr></section><section name="readToPixels" id="readToPixels" class="mb2"><div class="method mb2"><h3 class="f3 title">readToPixels( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">readToPixels</span><span class="token punctuation">(</span><code class="token boolean">ofPixels <span class="token operator">&</span>pixels</code><span class="token punctuation">)</span></code><div class="short"><p>\section Read Pixel Data
Read current texture data from the GPU into pixels.</p>
<p><strong>Warning</strong>: This is not supported in OpenGL ES and does nothing.</p>
<p><strong>Parameters:</strong></p>
<p>pixels Target ofPixels reference.</p>
</div><div class="desc"></div></div><hr></section><section name="readToPixels" id="readToPixels" class="mb2"><div class="method mb2"><h3 class="f3 title">readToPixels( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">readToPixels</span><span class="token punctuation">(</span><code class="token boolean">ofShortPixels <span class="token operator">&</span>pixels</code><span class="token punctuation">)</span></code><div class="short"><p>Read current texture data from the GPU into pixels.</p>
<p><strong>Warning</strong>: This is not supported in OpenGL ES and does nothing.</p>
<p><strong>Parameters:</strong></p>
<p>pixels Target pixels reference.</p>
</div><div class="desc"></div></div><hr></section><section name="readToPixels" id="readToPixels" class="mb2"><div class="method mb2"><h3 class="f3 title">readToPixels( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">readToPixels</span><span class="token punctuation">(</span><code class="token boolean">ofFloatPixels <span class="token operator">&</span>pixels</code><span class="token punctuation">)</span></code><div class="short"><p>Read current texture data from the GPU into pixels.</p>
<p><strong>Warning</strong>: This is not supported in OpenGL ES and does nothing.</p>
<p><strong>Parameters:</strong></p>
<p>pixels Target pixels reference.</p>
</div><div class="desc"></div></div><hr></section><section name="resetAnchor" id="resetAnchor" class="mb2"><div class="method mb2"><h3 class="f3 title">resetAnchor( <!----> )</h3><code><span class="token keyword">void  </span><span class="token function">resetAnchor</span><span class="token punctuation">(</span><!----><span class="token punctuation">)</span></code><div class="short"><p>Reset the anchor point to (0, 0).</p>
</div><div class="desc"></div></div><hr></section><section name="setAlphaMask" id="setAlphaMask" class="mb2"><div class="method mb2"><h3 class="f3 title">setAlphaMask( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">setAlphaMask</span><span class="token punctuation">(</span><code class="token boolean">ofTexture <span class="token operator">&</span>mask</code><span class="token punctuation">)</span></code><div class="short"><p>\section Texture Settings
Set another ofTexture to use as an alpha mask.</p>
<p><strong>Parameters:</strong></p>
<p>mask The texture to use as alpha mask.</p>
</div><div class="desc"></div></div><hr></section><section name="setAnchorPercent" id="setAnchorPercent" class="mb2"><div class="method mb2"><h3 class="f3 title">setAnchorPercent( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">setAnchorPercent</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> xPct<span class="token punctuation">,</span> <span class="token keyword">float</span> yPct</code><span class="token punctuation">)</span></code><div class="short"><p>Set the anchor point the texture is drawn around as a percentage.</p>
<p>This can be useful if you want to rotate an image around a particular
point.</p>
<p><strong>Parameters:</strong></p>
<p>xPct Horizontal texture position as a percentage (0 - 1).</p>
<p>yPct Vertical texture position as a percentage (0 - 1).</p>
</div><div class="desc"><p>The anchor is the point the image is drawn around. This can be useful if you want to rotate an image around a particular point, allowing you to set the anchor as a percentage of the image width/height ( 0.0-1.0 range )</p>
</div></div><hr></section><section name="setAnchorPoint" id="setAnchorPoint" class="mb2"><div class="method mb2"><h3 class="f3 title">setAnchorPoint( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">setAnchorPoint</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> x<span class="token punctuation">,</span> <span class="token keyword">float</span> y</code><span class="token punctuation">)</span></code><div class="short"><p>Set the anchor point the texture is drawn around in pixels.</p>
<p>This can be useful if you want to rotate an image around a particular
point.</p>
<p><strong>Parameters:</strong></p>
<p>x Horizontal texture position in pixels.</p>
<p>y Vertical texture position in pixels.</p>
</div><div class="desc"><p>set the anchor point in pixels</p>
</div></div><hr></section><section name="setCompression" id="setCompression" class="mb2"><div class="method mb2"><h3 class="f3 title">setCompression( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">setCompression</span><span class="token punctuation">(</span><code class="token boolean">ofTexCompression compression</code><span class="token punctuation">)</span></code><div class="short"><p>Set the texture compression.</p>
<p>\warning: not yet implemented.</p>
<p><strong>See also</strong>: ofTexCompression</p>
</div><div class="desc"></div></div><hr></section><section name="setRGToRGBASwizzles" id="setRGToRGBASwizzles" class="mb2"><div class="method mb2"><h3 class="f3 title">setRGToRGBASwizzles( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">setRGToRGBASwizzles</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">bool</span> rToRGBSwizzles</code><span class="token punctuation">)</span></code><div class="short"><p>\todo Define Swizzle in the documentation.
Swizzle RGBA to grayscale with alpha in the red channel.</p>
<p>Use 1 channel GL_R as luminance instead of red channel in OpenGL 3+.</p>
<p><strong>Warning</strong>: This is not supported in OpenGL ES and does nothing.</p>
<p><strong>See also</strong>: https://en.wikipedia.org/wiki/Swizzling_(computer_graphics)</p>
</div><div class="desc"></div></div><hr></section><section name="setSwizzle" id="setSwizzle" class="mb2"><div class="method mb2"><h3 class="f3 title">setSwizzle( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">setSwizzle</span><span class="token punctuation">(</span><code class="token boolean">GLenum srcSwizzle<span class="token punctuation">,</span> GLenum dstChannel</code><span class="token punctuation">)</span></code><div class="short"><p>Swizzle a channel to another</p>
<p>Example:</p>
<pre><code>ofTexture tex<span class="token punctuation">;</span>
tex<span class="token punctuation">.</span><span class="token function">setSwizzle</span><span class="token punctuation">(</span>GL_TEXTURE_SWIZZLE_R<span class="token punctuation">,</span>GL_ALPHA<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>will make channel 0 appear as alpha in the shader.</p>
<p><strong>Warning</strong>: This is not supported in OpenGL ES and does nothing.</p>
<p><strong>See also</strong>: https://en.wikipedia.org/wiki/Swizzling_(computer_graphics)</p>
</div><div class="desc"></div></div><hr></section><section name="setTextureMatrix" id="setTextureMatrix" class="mb2"><div class="method mb2"><h3 class="f3 title">setTextureMatrix( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">setTextureMatrix</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> glm<span class="token operator">::</span>mat4 <span class="token operator">&</span>m</code><span class="token punctuation">)</span></code><div class="short"><p>Sets a texture matrix to be uploaded whenever the texture is bound.</p>
<p><strong>Parameters:</strong></p>
<p>m The 4x4 texture matrix.</p>
</div><div class="desc"></div></div><hr></section><section name="setTextureMinMagFilter" id="setTextureMinMagFilter" class="mb2"><div class="method mb2"><h3 class="f3 title">setTextureMinMagFilter( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">setTextureMinMagFilter</span><span class="token punctuation">(</span><code class="token boolean">GLint minFilter<span class="token punctuation">,</span> GLint magFilter</code><span class="token punctuation">)</span></code><div class="short"><p>Set texture minification/magnification scaling filters.</p>
<p>Controls how OpenGL will scale this texture.</p>
<p><strong>See also</strong>: http://www.opengl.org/sdk/docs/man4/html/glTexParameter.xhtml</p>
<p><strong>See also</strong>: ofTextureSetMinMagFilters()</p>
<p><strong>Warning</strong>: May be overridden.</p>
<p><strong>Parameters:</strong></p>
<p>minFilter minifying filter for scaling a pixel to a smaller area.</p>
<p>magFilter magnifying filter for scaling a pixel to a larger area.</p>
</div><div class="desc"><p>Set how the texture is scaled up and down, when it's being drawn larger or smaller than it's actual size.</p>
</div></div><hr></section><section name="setTextureWrap" id="setTextureWrap" class="mb2"><div class="method mb2"><h3 class="f3 title">setTextureWrap( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">setTextureWrap</span><span class="token punctuation">(</span><code class="token boolean">GLint wrapModeHorizontal<span class="token punctuation">,</span> GLint wrapModeVertical</code><span class="token punctuation">)</span></code><div class="short"><p>Set texture wrapping.</p>
<p>By default, textures are clamped to their edges with <code>GL_CLAMP_TO_EDGE</code>.
Setting a repeat mode like <code>GL_REPEAT</code> allows you to create tiled
backgrounds with small textures.</p>
<p><strong>See also</strong>: ofTextureSetWrap()</p>
<p><strong>See also</strong>: http://www.opengl.org/sdk/docs/man4/html/glTexParameter.xhtml</p>
<p><strong>Warning</strong>: May be overridden.</p>
<p><strong>Parameters:</strong></p>
<p>wrapModeHorizontal wrap parameter for texture coordinate s.</p>
<p>wrapModeVertical wrap parameter for texture coordinate t.</p>
</div><div class="desc"><p>Sets how the texture wraps around the edges of the vertices that the texture is being drawn to.</p>
</div></div><hr></section><section name="setUseExternalTextureID" id="setUseExternalTextureID" class="mb2"><div class="method mb2"><h3 class="f3 title">setUseExternalTextureID( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">setUseExternalTextureID</span><span class="token punctuation">(</span><code class="token boolean">GLuint externTexID</code><span class="token punctuation">)</span></code><div class="short"><p>Set the texture ID.</p>
<p>Allows you to point the texture id to an externally allocated id
(perhaps from another texture). It's up to you to set the rest of the
textData parameters manually.</p>
<p><strong>Warning</strong>: When setting an external texture ID, the user must set the
remaining ofTextureData parameters manually.</p>
<p><strong>Parameters:</strong></p>
<p>externTexID New texture ID.</p>
</div><div class="desc"></div></div><hr></section><section name="unbind" id="unbind" class="mb2"><div class="method mb2"><h3 class="f3 title">unbind( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">unbind</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">int</span> textureLocation<span class="token operator">=</span><span class="token number">0</span></code><span class="token punctuation">)</span></code><div class="short"><p>Unbind the texture.</p>
<p>For advanced users who need to manually manage texture drawing without
calling ofTexture::draw.</p>
<p><strong>See also</strong>: http://www.opengl.org/sdk/docs/man4/html/glBindTexture.xhtml</p>
</div><div class="desc"><p>This for the advanced user who wants to draw textures in their own way. This stops vertices from being textured using this texture.</p>
</div></div><hr></section><section name="~ofTexture" id="~ofTexture" class="mb2"><div class="method mb2"><h3 class="f3 title">~ofTexture( <!----> )</h3><code><!----><span class="token function">~ofTexture</span><span class="token punctuation">(</span><!----><span class="token punctuation">)</span></code><div class="short"><p>Destroy an ofTexture instance.</p>
<p>ofTexture keeps a reference count for the internal OpenGL texture ID.
Thus, the texture ID is only released if there are no additional
references to the internal texture ID.</p>
</div><div class="desc"></div></div><hr></section></div></div></div></div><div id="side-menu"><div id="params"><h4 class="f3">Variables</h4><code><div class="functions"></div><div class="variable"><div class="title"><span class="token keyword">ofPoint </span><span>anchor</span><span class="token comment">&lt; The texture's anchor point.
</span></div><div class="desc"></div></div></code><code><div class="functions"></div><div class="variable"><div class="title"><span class="token keyword">bool </span><span>bAnchorIsPct</span><span class="token comment">&lt; Is the anchor point represented as a normalized
&lt; (0 - 1) coordinate?
</span></div><div class="desc"></div></div></code><code><div class="functions"></div><div class="variable"><div class="title"><span class="token keyword">bool </span><span>bWantsMipmap</span><span class="token comment">&lt; Should mipmaps be created?
</span></div><div class="desc"></div></div></code><code><div class="functions"></div><div class="variable"><div class="title"><span class="token keyword">ofTextureData </span><span>texData</span><span class="token comment">&lt; Internal texture data access.
&lt; For backwards compatibility.
</span></div><div class="desc"><p>texData is a variable type ofTextureData. ofTextureData is a structure containing information about the texture such as size.</p>
</div></div></code></div><div id="methods-list"><h4 class="f3">Methods</h4><div class="anchor"><code><a href="#allocate" class="pink"><span>allocate</span><span>(12)</span></a></code></div><div class="anchor"><code><a href="#allocateAsBufferTexture" class="pink"><span>allocateAsBufferTexture</span><!----></a></code></div><div class="anchor"><code><a href="#bind" class="pink"><span>bind</span><!----></a></code></div><div class="anchor"><code><a href="#bindAsImage" class="pink"><span>bindAsImage</span><!----></a></code></div><div class="anchor"><code><a href="#clear" class="pink"><span>clear</span><!----></a></code></div><div class="anchor"><code><a href="#copyTo" class="pink"><span>copyTo</span><!----></a></code></div><div class="anchor"><code><a href="#disableAlphaMask" class="pink"><span>disableAlphaMask</span><!----></a></code></div><div class="anchor"><code><a href="#disableMipmap" class="pink"><span>disableMipmap</span><!----></a></code></div><div class="anchor"><code><a href="#disableTextureMatrix" class="pink"><span>disableTextureMatrix</span><!----></a></code></div><div class="anchor"><code><a href="#disableTextureTarget" class="pink"><span>disableTextureTarget</span><!----></a></code></div><div class="anchor"><code><a href="#draw" class="pink"><span>draw</span><span>(7)</span></a></code></div><div class="anchor"><code><a href="#drawSubsection" class="pink"><span>drawSubsection</span><span>(5)</span></a></code></div><div class="anchor"><code><a href="#enableMipmap" class="pink"><span>enableMipmap</span><!----></a></code></div><div class="anchor"><code><a href="#enableTextureTarget" class="pink"><span>enableTextureTarget</span><!----></a></code></div><div class="anchor"><code><a href="#generateMipmap" class="pink"><span>generateMipmap</span><!----></a></code></div><div class="anchor"><code><a href="#getAlphaMask"><span>getAlphaMask</span><!----></a></code></div><div class="anchor"><code><a href="#getCoordFromPercent" class="pink"><span>getCoordFromPercent</span><!----></a></code></div><div class="anchor"><code><a href="#getCoordFromPoint" class="pink"><span>getCoordFromPoint</span><!----></a></code></div><div class="anchor"><code><a href="#getHeight" class="pink"><span>getHeight</span><!----></a></code></div><div class="anchor"><code><a href="#getMeshForSubsection" class="pink"><span>getMeshForSubsection</span><!----></a></code></div><div class="anchor"><code><a href="#getQuad"><span>getQuad</span><!----></a></code></div><div class="anchor"><code><a href="#getTextureData" class="pink"><span>getTextureData</span><span>(2)</span></a></code></div><div class="anchor"><code><a href="#getTextureMatrix"><span>getTextureMatrix</span><!----></a></code></div><div class="anchor"><code><a href="#getWidth" class="pink"><span>getWidth</span><!----></a></code></div><div class="anchor"><code><a href="#hasMipmap" class="pink"><span>hasMipmap</span><!----></a></code></div><div class="anchor"><code><a href="#isAllocated" class="pink"><span>isAllocated</span><!----></a></code></div><div class="anchor"><code><a href="#isUsingTextureMatrix"><span>isUsingTextureMatrix</span><!----></a></code></div><div class="anchor"><code><a href="#loadData" class="pink"><span>loadData</span><span>(15)</span></a></code></div><div class="anchor"><code><a href="#loadScreenData" class="pink"><span>loadScreenData</span><!----></a></code></div><div class="anchor"><code><a href="#ofTexture"><span>ofTexture</span><span>(3)</span></a></code></div><div class="anchor"><code><a href="#operator="><span>operator=</span><span>(2)</span></a></code></div><div class="anchor"><code><a href="#readToPixels" class="pink"><span>readToPixels</span><span>(3)</span></a></code></div><div class="anchor"><code><a href="#resetAnchor" class="pink"><span>resetAnchor</span><!----></a></code></div><div class="anchor"><code><a href="#setAlphaMask" class="pink"><span>setAlphaMask</span><!----></a></code></div><div class="anchor"><code><a href="#setAnchorPercent" class="pink"><span>setAnchorPercent</span><!----></a></code></div><div class="anchor"><code><a href="#setAnchorPoint" class="pink"><span>setAnchorPoint</span><!----></a></code></div><div class="anchor"><code><a href="#setCompression" class="pink"><span>setCompression</span><!----></a></code></div><div class="anchor"><code><a href="#setRGToRGBASwizzles" class="pink"><span>setRGToRGBASwizzles</span><!----></a></code></div><div class="anchor"><code><a href="#setSwizzle" class="pink"><span>setSwizzle</span><!----></a></code></div><div class="anchor"><code><a href="#setTextureMatrix" class="pink"><span>setTextureMatrix</span><!----></a></code></div><div class="anchor"><code><a href="#setTextureMinMagFilter" class="pink"><span>setTextureMinMagFilter</span><!----></a></code></div><div class="anchor"><code><a href="#setTextureWrap" class="pink"><span>setTextureWrap</span><!----></a></code></div><div class="anchor"><code><a href="#setUseExternalTextureID" class="pink"><span>setUseExternalTextureID</span><!----></a></code></div><div class="anchor"><code><a href="#unbind" class="pink"><span>unbind</span><!----></a></code></div><div class="anchor"><code><a href="#~ofTexture" class="pink"><span>~ofTexture</span><!----></a></code></div></div><div id="see-also" filename="ofTexture.markdown" absolute="/Users/Gilbert/Code/openFrameworks/ofSite/documentation/gl/ofTexture.markdown" route="/documentation/gl/ofTexture.markdown" dir="../ofSite/documentation/gl" ext="markdown" type="page" parent="2192" breadcrumbs="2192,1968" siblings="" translations="[object Object]" class="see-also"><h4 class="f3">See also</h4><div class="also"><a href="/documentation/gl/ofTextureData"><span class="origin">documentation</span><span class="name">ofTextureData</span></a></div><div class="also"><a href="/documentation/gl/ofTexture_functions"><span class="origin">documentation</span><span class="name">ofTexture (functions)</span></a></div><div class="also"><a href="/openframeworks/gl/ofTexture_h"><span class="origin">openframeworks</span><span class="name">ofTexture.h</span></a></div><div class="also"><a href="/openframeworks/gl/ofTexture_cpp"><span class="origin">openframeworks</span><span class="name">ofTexture.cpp</span></a></div></div></div></div></div><textarea rows="0" class="markdown-editor" style="display:none">#class ofTexture


&lt;!--
_visible: True_
_advanced: False_
_istemplated: False_
_extends: ofBaseDraws_
-->

##InlineDescription


A wrapper class for an OpenGL texture.





##Description

ofTexture is used to create textures that live on your graphics card from bitmap data that can then be used to fill other drawn objects, like a bitmap fill on a rectangle. When you draw an ofImage, you're actually just drawing a rectangle of points and then using an ofTexture to fill the space between those points. At it's core, ofTexture is a wrapper for OpenGL textures. It allows use of non-power of 2 textures in opengl, and to upload and draw graphical data.





##Methods



###void allocate(&pix)

&lt;!--
_syntax: allocate(&pix)_
_name: allocate_
_returns: void_
_returns_description: _
_parameters: const ofPixels &pix_
_access: public_
_version_started: 0071_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Allocate texture using an ofPixels instance.

Pixel type and OpenGL format are determined from pixel settings.


**Parameters:**

pix Reference to ofPixels instance.





_description: _







&lt;!----------------------------------------------------------------------------->

###void allocate(&pix)

&lt;!--
_syntax: allocate(&pix)_
_name: allocate_
_returns: void_
_returns_description: _
_parameters: const ofShortPixels &pix_
_access: public_
_version_started: 0073_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Allocate texture using an ofShortPixels instance.

Same as void allocate(const ofPixels& pix), except using ofShortPixels.


**See also**: allocate(const ofPixels& pix)

**Parameters:**

pix Reference to ofShortPixels instance.





_description: _







&lt;!----------------------------------------------------------------------------->

###void allocate(&pix)

&lt;!--
_syntax: allocate(&pix)_
_name: allocate_
_returns: void_
_returns_description: _
_parameters: const ofFloatPixels &pix_
_access: public_
_version_started: 0073_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Allocate texture using an ofFloatPixels instance.

Same as void allocate(const ofPixels& pix), except using ofFloatPixels.


**See also**: allocate(const ofPixels& pix)

**Parameters:**

pix Reference to ofFloatPixels instance.





_description: _







&lt;!----------------------------------------------------------------------------->

###void allocate(&pix, bUseARBExtension)

&lt;!--
_syntax: allocate(&pix, bUseARBExtension)_
_name: allocate_
_returns: void_
_returns_description: _
_parameters: const ofPixels &pix, bool bUseARBExtension_
_access: public_
_version_started: 0073_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Allocate texture using an ofPixels instance and type.

This lets you overide the default OF texture type in case you need a
square GL_TEXTURE_2D texture.


**Warning**: ARB textures are not available in OpenGL ES.

**See also**: ofEnableArbTex()

**See also**: allocate(const ofPixels& pix)

**Parameters:**

pix Reference to ofPixels instance.

bUseARBExtension Set to true to use rectangular textures.





_description: _







&lt;!----------------------------------------------------------------------------->

###void allocate(&pix, bUseARBExtension)

&lt;!--
_syntax: allocate(&pix, bUseARBExtension)_
_name: allocate_
_returns: void_
_returns_description: _
_parameters: const ofShortPixels &pix, bool bUseARBExtension_
_access: public_
_version_started: 0073_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Allocate texture using an ofShortPixels instance and type.

Same as void void allocate(const ofPixels& pix), except using ofShortPixels.


**See also**: allocate(const ofShortPixels& pix)

**Parameters:**

pix Reference to ofShortPixels instance.

bUseARBExtension Set to true to use rectangular textures.





_description: _







&lt;!----------------------------------------------------------------------------->

###void allocate(&pix, bUseARBExtension)

&lt;!--
_syntax: allocate(&pix, bUseARBExtension)_
_name: allocate_
_returns: void_
_returns_description: _
_parameters: const ofFloatPixels &pix, bool bUseARBExtension_
_access: public_
_version_started: 0073_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Allocate texture using an ofShortPixels instance and type.

Same as void void allocate(const ofPixels& pix), except using ofShortPixels.


**See also**: allocate(const ofFloatPixels& pix)

**Parameters:**

pix Reference to ofFloatPixels instance.

bUseARBExtension Set to true to use rectangular textures.





_description: _







&lt;!----------------------------------------------------------------------------->

###void allocate(&textureData)

&lt;!--
_syntax: allocate(&textureData)_
_name: allocate_
_returns: void_
_returns_description: _
_parameters: const ofTextureData &textureData_
_access: public_
_version_started: 007_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Allocate the texture using the given settings.

This is useful if you need manual control over loading a number of
textures with the same settings. Make sure to set the texture data
parameters first.


**Parameters:**

textureData The settings to use when allocating the ofTexture.





_description: _







&lt;!----------------------------------------------------------------------------->

###void allocate(&textureData, glFormat, pixelType)

&lt;!--
_syntax: allocate(&textureData, glFormat, pixelType)_
_name: allocate_
_returns: void_
_returns_description: _
_parameters: const ofTextureData &textureData, int glFormat, int pixelType_
_access: public_
_version_started: 0073_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Allocate the texture using the given settings and custom format.

**Parameters:**

textureData The settings to use when allocating the ofTexture.

glFormat GL texture format: GL_RGBA, GL_LUMINANCE, etc.

pixelType GL pixel type: GL_UNSIGNED_BYTE, GL_FLOAT, etc.





_description: _







&lt;!----------------------------------------------------------------------------->

###void allocate(w, h, glInternalFormat)

&lt;!--
_syntax: allocate(w, h, glInternalFormat)_
_name: allocate_
_returns: void_
_returns_description: _
_parameters: int w, int h, int glInternalFormat_
_access: public_
_version_started: 006_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Allocate texture of a given size and format.

The width (w) and height (h) do not necessarily need to be powers of 2,
but they do need to be large enough to contain the data you will upload
to the texture.

The internal data type `glFormat` describes how OpenGL will store this
texture internally. For example, if you want a grayscale texture, you
can use `GL_LUMINANCE`. You can upload what ever type of data you want
(using `loadData()`) but internally, opengl will store the information
as grayscale. Other types include: `GL_RGB`, `GL_RGBA`.

This method applies the currently set OF texture type and defaults to
ARB rectangular textures if they are supported. (They are not supported
on OpenGL ES).


**Parameters:**

w Desired width in pixels.

h Desired height in pixels.

glInternalFormat OpenGL internal data format: `GL_RGBA`, `GL_LUMINANCE`, etc.





_description: _

This is the call to allocate opengl texture. The width (w) and height (h) do not necessarily need to be powers of 2, but they do need to be large enough to contain the data you will upload to the texture.  The internal data type describes how opengl will store this texture internally. For example, if you want a grayscale texture, you can use "GL_LUMINANCE". You can uplaod what ever type of data you want (using loadData()) but internally, opengl will store the information as grayscale. Other types include: GL_RGB, GL_RGBA.
You need to allocate the texture before drawing it or loading data into it.
uses the currently set OF texture type - default ARB texture





&lt;!----------------------------------------------------------------------------->

###void allocate(w, h, glInternalFormat, bUseARBExtension)

&lt;!--
_syntax: allocate(w, h, glInternalFormat, bUseARBExtension)_
_name: allocate_
_returns: void_
_returns_description: _
_parameters: int w, int h, int glInternalFormat, bool bUseARBExtension_
_access: public_
_version_started: 006_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Allocate texture of a given size and format. Specify texture type.

This allows to enable the ARBE extension for this texture.
This will overide the default OF texture type, in case you need a
square texture (`GL_TEXTURE_2D`).


**Warning**: ARB textures are not available in OpenGL ES.

**See also**: ofEnableArbTex()

**See also**: allocate(int w, int h, int glInternalFormat)

**Parameters:**

w Desired width in pixels.

h Desired height in pixels.

glInternalFormat The internal openGL format.

bUseARBExtension Set to true to use rectangular textures.





_description: _

See previous allocate for knowing the behaviour of this function. The parameter bUseARBEExtension allow the user to enable the ARBE extension for this texture.
You need to allocate the texture before drawing it or loading data into it, lets you overide the default OF texture type





&lt;!----------------------------------------------------------------------------->

###void allocate(w, h, glInternalFormat, bUseARBExtension, glFormat, pixelType)

&lt;!--
_syntax: allocate(w, h, glInternalFormat, bUseARBExtension, glFormat, pixelType)_
_name: allocate_
_returns: void_
_returns_description: _
_parameters: int w, int h, int glInternalFormat, bool bUseARBExtension, int glFormat, int pixelType_
_access: public_
_version_started: 0073_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Allocate texture of a given size, format, & type.


**See also**: allocate(int w, int h, int glInternalFormat)

**Parameters:**

w Desired width in pixels.

h Desired height in pixels.

glInternalFormat OpenGL data format: `GL_RGBA`, `GL_LUMINANCE`, etc.

bUseARBExtension Set to true to use rectangular textures.

glFormat The OpenGL format.

pixelType OpenGL pixel type: `GL_UNSIGNED_BYTE`, `GL_FLOAT`, etc.





_description: _







&lt;!----------------------------------------------------------------------------->

###void allocate(w, h, glInternalFormat, glFormat, pixelType)

&lt;!--
_syntax: allocate(w, h, glInternalFormat, glFormat, pixelType)_
_name: allocate_
_returns: void_
_returns_description: _
_parameters: int w, int h, int glInternalFormat, int glFormat, int pixelType_
_access: public_
_version_started: 0073_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Allocate texture of a given size and format.


**See also**: allocate(int w, int h, int glInternalFormat)

**Parameters:**

w Desired width in pixels.

h Desired height in pixels.

glInternalFormat The internal openGL format.

glFormat The openGL format.

pixelType GL pixel type: GL_UNSIGNED_BYTE, GL_FLOAT, etc.





_description: _







&lt;!----------------------------------------------------------------------------->

###void allocateAsBufferTexture(&buffer, glInternalFormat)

&lt;!--
_syntax: allocateAsBufferTexture(&buffer, glInternalFormat)_
_name: allocateAsBufferTexture_
_returns: void_
_returns_description: _
_parameters: const ofBufferObject &buffer, int glInternalFormat_
_access: public_
_version_started: 0.9.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Allocate texture as a Buffer Texture.

Uses a GPU buffer as data for the texture instead of pixels in RAM
Allows to use texture buffer objects (TBO) which make it easier to send big
amounts of data to a shader as a uniform.

Buffer textures are 1D textures, and may only be sampled using texelFetch
in GLSL.

See textureBufferInstanceExample and https://www.opengl.org/wiki/Buffer_Texture


**See also**: allocate(const ofBufferObject & buffer, int glInternalFormat)

**Parameters:**

buffer Reference to ofBufferObject instance.

glInternalFormat Internal pixel format of the data.





_description: _







&lt;!----------------------------------------------------------------------------->

###void bind(textureLocation = 0)

&lt;!--
_syntax: bind(textureLocation = 0)_
_name: bind_
_returns: void_
_returns_description: _
_parameters: int textureLocation=0_
_access: public_
_version_started: 006_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Bind the texture.

For advanced users who need to manually manage texture drawing without
calling ofTexture::draw.


**See also**: http://www.opengl.org/sdk/docs/man4/html/glBindTexture.xhtml





_description: _

This is for the advanced user who wants to draw textures in their own way. Each set of vertices that you draw after calling bind() will be textured using this texture.





&lt;!----------------------------------------------------------------------------->

###void bindAsImage(unit, access, level = 0, layered, layer = 0)

&lt;!--
_syntax: bindAsImage(unit, access, level = 0, layered, layer = 0)_
_name: bindAsImage_
_returns: void_
_returns_description: _
_parameters: GLuint unit, GLenum access, GLint level=0, GLboolean layered, GLint layer=0_
_access: public_
_version_started: 0.9.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Calls glBindImageTexture on the texture

Binds the texture as an read or write image, only available since OpenGL 4.2

**Warning**: This is not available in OpenGLES

**See also**: http://www.opengl.org/wiki/GLAPI/glBindImageTexture





_description: _







&lt;!----------------------------------------------------------------------------->

###void clear()

&lt;!--
_syntax: clear()_
_name: clear_
_returns: void_
_returns_description: _
_parameters: _
_access: public_
_version_started: 006_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Clears the texture.

Clears / frees the texture memory, if something was already allocated.
Useful if you need to control the memory on the graphics card.

The internal GL texture ID is only released if this is the last texture
using it.





_description: _

clears / frees the texture memory, if something was already allocated. useful if you need to control the memory on the graphics card.
Clears all the data from the texture





&lt;!----------------------------------------------------------------------------->

###void copyTo(&buffer)

&lt;!--
_syntax: copyTo(&buffer)_
_name: copyTo_
_returns: void_
_returns_description: _
_parameters: ofBufferObject &buffer_
_access: public_
_version_started: 0.9.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Copy the texture to an ofBufferObject.

**Parameters:**

buffer the target buffer to copy to.





_description: _







&lt;!----------------------------------------------------------------------------->

###void disableAlphaMask()

&lt;!--
_syntax: disableAlphaMask()_
_name: disableAlphaMask_
_returns: void_
_returns_description: _
_parameters: _
_access: public_
_version_started: 0.9.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Disable the alpha mask.





_description: _







&lt;!----------------------------------------------------------------------------->

###void disableMipmap()

&lt;!--
_syntax: disableMipmap()_
_name: disableMipmap_
_returns: void_
_returns_description: _
_parameters: _
_access: public_
_version_started: 0.9.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Sets flag disallowing texture to auto-generate mipmap.

By default, this will set your minFilter to GL_LINEAR_MIPMAP_LINEAR.
If you want to change your minFilter later use setTextureMinMagFilter()

	If you want to generate a mipmap later, or at a specific
point in your code, use ofTexture::generateMipmap() instead.


**See also**: generateMipmap()

**See also**: enableMipmap()

**See also**: setTextureMinMagFilter()





_description: _







&lt;!----------------------------------------------------------------------------->

###void disableTextureMatrix()

&lt;!--
_syntax: disableTextureMatrix()_
_name: disableTextureMatrix_
_returns: void_
_returns_description: _
_parameters: _
_access: public_
_version_started: 0.9.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Disable the texture matrix.
Disable the texture matrix.





_description: _







&lt;!----------------------------------------------------------------------------->

###void disableTextureTarget(textureLocation)

&lt;!--
_syntax: disableTextureTarget(textureLocation)_
_name: disableTextureTarget_
_returns: void_
_returns_description: _
_parameters: int textureLocation_
_access: protected_
_version_started: 0073_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Disable a texture target.

**Parameters:**

textureLocation the OpenGL texture ID to enable as a target.





_description: _







&lt;!----------------------------------------------------------------------------->

###void draw(&p1, &p2, &p3, &p4)

&lt;!--
_syntax: draw(&p1, &p2, &p3, &p4)_
_name: draw_
_returns: void_
_returns_description: _
_parameters: const glm::vec3 &p1, const glm::vec3 &p2, const glm::vec3 &p3, const glm::vec3 &p4_
_access: public_
_version_started: 0.10.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Draws the texture at 4 points passed in as if you created 4 glVertices.


**Parameters:**

p1 Upper left position on the x axis.

p2 Upper left position on the y axis.

p3 Lower right position on the x axis.

p4 Lower right position on the y axis.





_description: _







&lt;!----------------------------------------------------------------------------->

###void draw(&pos)

&lt;!--
_syntax: draw(&pos)_
_name: draw_
_returns: void_
_returns_description: _
_parameters: const glm::vec3 &pos_
_access: public_
_version_started: 0.10.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

###void draw(&pos, w, h)

&lt;!--
_syntax: draw(&pos, w, h)_
_name: draw_
_returns: void_
_returns_description: _
_parameters: const glm::vec3 &pos, float w, float h_
_access: public_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _

Draws the texture at 4 points passed in as if you created 4 glVertices.





&lt;!----------------------------------------------------------------------------->

###void draw(x, y)

&lt;!--
_syntax: draw(x, y)_
_name: draw_
_returns: void_
_returns_description: _
_parameters: float x, float y_
_access: public_
_version_started: 006_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

\section Drawing





_description: _

Draws the texture at a given point (x,y), using the textures true width and height.
Draws the texture at the point passed in.





&lt;!----------------------------------------------------------------------------->

###void draw(x, y, w, h)

&lt;!--
_syntax: draw(x, y, w, h)_
_name: draw_
_returns: void_
_returns_description: _
_parameters: float x, float y, float w, float h_
_access: public_
_version_started: 006_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _

draws the texture at a given point (x,y), with a given width (w) and height (h).
Draws the texture at the x, y and w, h.





&lt;!----------------------------------------------------------------------------->

###void draw(x, y, z)

&lt;!--
_syntax: draw(x, y, z)_
_name: draw_
_returns: void_
_returns_description: _
_parameters: float x, float y, float z_
_access: public_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _

Draws the texture at the point passed in in 3D space.





&lt;!----------------------------------------------------------------------------->

###void draw(x, y, z, w, h)

&lt;!--
_syntax: draw(x, y, z, w, h)_
_name: draw_
_returns: void_
_returns_description: _
_parameters: float x, float y, float z, float w, float h_
_access: public_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Draw the texture at a given size witdh and depth.


**Parameters:**

x Draw position on the x axis.

y Draw position on the y axis.

z Draw position on the z axis.

w Draw width.

h Draw height.





_description: _

Draws the texture at the x, y, z in 3D space with the width and height at w,h.





&lt;!----------------------------------------------------------------------------->

###void drawSubsection(&drawBounds, &subsectionBounds)

&lt;!--
_syntax: drawSubsection(&drawBounds, &subsectionBounds)_
_name: drawSubsection_
_returns: void_
_returns_description: _
_parameters: const ofRectangle &drawBounds, const ofRectangle &subsectionBounds_
_access: public_
_version_started: 0.10.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Draw a subsection of the texture with an offset.


**See also**: drawSubsection(ofRectangle& drawBounds, ofRectangle& subsectionBounds)

**Parameters:**

drawBounds Draw position and dimensions.

subsectionBounds Subsection position and dimensions within the texture.





_description: _







&lt;!----------------------------------------------------------------------------->

###void drawSubsection(x, y, w, h, sx, sy)

&lt;!--
_syntax: drawSubsection(x, y, w, h, sx, sy)_
_name: drawSubsection_
_returns: void_
_returns_description: _
_parameters: float x, float y, float w, float h, float sx, float sy_
_access: public_
_version_started: 0071_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Draw a subsection of the texture.

Like ofRect() depend on the current `OF_RECT_MODE`:

* `OF_RECT_MODE_CORNER`: drawn with the upper left corner = (x,y)
* `OF_RECT_MODE_CENTER`: drawn centered on (x,y)


**See also**: ofSetRectMode()


**Parameters:**

x Draw position on the x axis.

y Draw position on the y axis.

w Draw width.

h Draw height.

sx Subsection x axis offset within the texture.

sy Subsection y axis offset within the texture.





_description: _







&lt;!----------------------------------------------------------------------------->

###void drawSubsection(x, y, w, h, sx, sy, sw, sh)

&lt;!--
_syntax: drawSubsection(x, y, w, h, sx, sy, sw, sh)_
_name: drawSubsection_
_returns: void_
_returns_description: _
_parameters: float x, float y, float w, float h, float sx, float sy, float sw, float sh_
_access: public_
_version_started: 0071_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Draw a subsection of the texture with an offset.


**See also**: drawSubsection(float x, float y, float w, float h, float sx, float sy)

**Parameters:**

x Draw position on the x axis.

y Draw position on the y axis.

w Draw width.

h Draw height.

sx Subsection x axis offset within the texture.

sy Subsection y axis offset within the texture.

sw Subsection width within the texture.

sh Subsection height within the texture.





_description: _







&lt;!----------------------------------------------------------------------------->

###void drawSubsection(x, y, z, w, h, sx, sy)

&lt;!--
_syntax: drawSubsection(x, y, z, w, h, sx, sy)_
_name: drawSubsection_
_returns: void_
_returns_description: _
_parameters: float x, float y, float z, float w, float h, float sx, float sy_
_access: public_
_version_started: 0071_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Draw a subsection of the texture with depth.


**See also**: drawSubsection(float x, float y, float w, float h, float sx, float sy)

**Parameters:**

x Draw position on the x axis.

y Draw position on the y axis.

z Draw position on the z axis.

w Draw width.

h Draw height.

sx Subsection x axis offset within the texture.

sy Subsection y axis offset within the texture.





_description: _







&lt;!----------------------------------------------------------------------------->

###void drawSubsection(x, y, z, w, h, sx, sy, sw, sh)

&lt;!--
_syntax: drawSubsection(x, y, z, w, h, sx, sy, sw, sh)_
_name: drawSubsection_
_returns: void_
_returns_description: _
_parameters: float x, float y, float z, float w, float h, float sx, float sy, float sw, float sh_
_access: public_
_version_started: 0071_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Draw a subsection of the texture with an offset and depth.


**See also**: drawSubsection(float x, float y, float w, float h, float sx, float sy)

**Parameters:**

x Draw position on the x axis.

y Draw position on the y axis.

z Draw position on the z axis.

w Draw width.

h Draw height.

sx Subsection x axis offset within the texture.

sy Subsection y axis offset within the texture.

sw Subsection width within the texture.

sh Subsection height within the texture.





_description: _







&lt;!----------------------------------------------------------------------------->

###void enableMipmap()

&lt;!--
_syntax: enableMipmap()_
_name: enableMipmap_
_returns: void_
_returns_description: _
_parameters: _
_access: public_
_version_started: 0.9.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

\section Mipmapping
Sets flag allowing texture to auto-generate a mipmap.

By default, this will set your minFilter to GL_LINEAR_MIPMAP_LINEAR.
If you want to change your minFilter later use setTextureMinMagFilter()

	If you want to generate a mipmap later, or at a specific
point in your code, use generateMipmap() instead.


**See also**: generateMipmap()

**See also**: disableMipmap()

**See also**: setTextureMinMagFilter()





_description: _







&lt;!----------------------------------------------------------------------------->

###void enableTextureTarget(textureLocation)

&lt;!--
_syntax: enableTextureTarget(textureLocation)_
_name: enableTextureTarget_
_returns: void_
_returns_description: _
_parameters: int textureLocation_
_access: protected_
_version_started: 0073_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Enable a texture target.

**Parameters:**

textureLocation the OpenGL texture ID to enable as a target.





_description: _







&lt;!----------------------------------------------------------------------------->

###void generateMipmap()

&lt;!--
_syntax: generateMipmap()_
_name: generateMipmap_
_returns: void_
_returns_description: _
_parameters: _
_access: public_
_version_started: 0.9.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Generate mipmap for the current texture.


**Warning**: Only GL_TEXTURE_RECTANGLE - which is the default openFrameworks
texture target - does *not* support mipmaps, so make sure to call
ofDisableArbTex() before loading texture
data for a texture you want to generate mipmaps for.


**See also**: ofEnableArbTex()

**See also**: ofDisableArbTex()





_description: _







&lt;!----------------------------------------------------------------------------->

###const ofTexture * getAlphaMask()

&lt;!--
_syntax: getAlphaMask()_
_name: getAlphaMask_
_returns: const ofTexture *_
_returns_description: _
_parameters: _
_access: public_
_version_started: 0.9.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

###glm::vec2 getCoordFromPercent(xPts, yPts)

&lt;!--
_syntax: getCoordFromPercent(xPts, yPts)_
_name: getCoordFromPercent_
_returns: glm::vec2_
_returns_description: _
_parameters: float xPts, float yPts_
_access: public_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Helper to convert display coordinate to texture coordinate.

**Parameters:**

xPts Horizontal position in a normalized percentage (0 - 1).

yPts Vertical position in a normalized percentage (0 - 1).

**Returns**: Texture coordinate or zero if texture is not allocated.





_description: _







&lt;!----------------------------------------------------------------------------->

###glm::vec2 getCoordFromPoint(xPos, yPos)

&lt;!--
_syntax: getCoordFromPoint(xPos, yPos)_
_name: getCoordFromPoint_
_returns: glm::vec2_
_returns_description: _
_parameters: float xPos, float yPos_
_access: public_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Helper to convert display coordinate to texture coordinate.

**Parameters:**

xPos Horizontal position in pixels.

yPos Vertical position in pixels.

**Returns**: Texture coordinate or zero if texture is not allocated.





_description: _

these are helpers to allow you to get points for the texture ala "glTexCoordf" but are texture type independent. use them for immediate or non immediate mode





&lt;!----------------------------------------------------------------------------->

###float getHeight()

&lt;!--
_syntax: getHeight()_
_name: getHeight_
_returns: float_
_returns_description: _
_parameters: _
_access: public_
_version_started: 006_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

\section Size and Coordinates
Display height of texture.

Return value is pixel size (default) or normalized (0 - 1) if ofEnableNormalizedTextures() is set to true.


**See also**: ofEnabledNormalizedTextures()


**Returns**: Display height of texture in pixels.





_description: _

Returns the height of the texture. This will be in pixels unless you've set your application to use normalized coordinates.





&lt;!----------------------------------------------------------------------------->

###ofMesh getMeshForSubsection(x, y, z, w, h, sx, sy, sw, sh, vflipped, rectMode)

&lt;!--
_syntax: getMeshForSubsection(x, y, z, w, h, sx, sy, sw, sh, vflipped, rectMode)_
_name: getMeshForSubsection_
_returns: ofMesh_
_returns_description: _
_parameters: float x, float y, float z, float w, float h, float sx, float sy, float sw, float sh, bool vflipped, ofRectMode rectMode_
_access: public_
_version_started: 0.9.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Get a mesh that has the texture coordinates set.


**See also**: drawSubsection(float x, float y, float w, float h, float sx, float sy)

**Parameters:**

x Draw position on the x axis.

y Draw position on the y axis.

z Draw position on the z axis.

w Draw width.

h Draw height.

sx Subsection x axis offset within the texture.

sy Subsection y axis offset within the texture.

sw Subsection width within the texture.

sh Subsection height within the texture.

vflipped Takes into account the flipped state in OF.

rectMode rectMode Taking x,y as the center or the top left corner.





_description: _







&lt;!----------------------------------------------------------------------------->

###ofMesh getQuad(&p1, &p2, &p3, &p4)

&lt;!--
_syntax: getQuad(&p1, &p2, &p3, &p4)_
_name: getQuad_
_returns: ofMesh_
_returns_description: _
_parameters: const glm::vec3 &p1, const glm::vec3 &p2, const glm::vec3 &p3, const glm::vec3 &p4_
_access: public_
_version_started: 0.9.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

###ofTextureData & getTextureData()

&lt;!--
_syntax: getTextureData()_
_name: getTextureData_
_returns: ofTextureData &_
_returns_description: _
_parameters: _
_access: public_
_version_started: 0.8.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

\section Texture Data
Internal texture data access.

This returns the internal texture data for this texture, for instance,
its textureID, type of texture, whether it's been allocated and other
data about the state of the texture.


**Returns**: a reference to the internal texture data struct.





_description: _







&lt;!----------------------------------------------------------------------------->

###const ofTextureData & getTextureData()

&lt;!--
_syntax: getTextureData()_
_name: getTextureData_
_returns: const ofTextureData &_
_returns_description: _
_parameters: _
_access: public_
_version_started: 006_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Const version of getTextureData().

**See also**: ofTextureData::getTextureData()





_description: _

This returns the internal texture data for this texture, for instance, its textureID, type of texture, whether it's been allocated, and other data about the state of the texture.





&lt;!----------------------------------------------------------------------------->

###const glm::mat4 & getTextureMatrix()

&lt;!--
_syntax: getTextureMatrix()_
_name: getTextureMatrix_
_returns: const glm::mat4 &_
_returns_description: _
_parameters: _
_access: public_
_version_started: 0.9.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

###float getWidth()

&lt;!--
_syntax: getWidth()_
_name: getWidth_
_returns: float_
_returns_description: _
_parameters: _
_access: public_
_version_started: 006_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Display width of texture.

Return value is pixel size (default) or normalized (0 - 1) if ofEnableNormalizedTextures() is set to true.


**See also**: ofEnabledNormalizedTextures()


**Returns**: Display width of texture in pixels.





_description: _

Returns the width of the texture. This will be in pixels unless you've set your application to use normalized coordinates.





&lt;!----------------------------------------------------------------------------->

###bool hasMipmap()

&lt;!--
_syntax: hasMipmap()_
_name: hasMipmap_
_returns: bool_
_returns_description: _
_parameters: _
_access: public_
_version_started: 0.10.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Find out if a mipmap has been generated for the current texture.


**See also**: generateMipmap()

**See also**: enableMipmap()





_description: _







&lt;!----------------------------------------------------------------------------->

###bool isAllocated()

&lt;!--
_syntax: isAllocated()_
_name: isAllocated_
_returns: bool_
_returns_description: _
_parameters: _
_access: public_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Determine whether the texture has been allocated.

This lets you check if a texture is safe to draw.  The texture can both
be allocated by using `allocate()` or loading it with data `loadData()`.


**Returns**: true if the texture has been allocated.





_description: _

Get whether the texture has been allocated.
ofTextureData getTextureData() ###
// reference to the actual textureData inside the smart pointer
// for backwards compatibility
ofTextureData texData ###
float getHeight() ###
float getWidth() ###





&lt;!----------------------------------------------------------------------------->

###bool isUsingTextureMatrix()

&lt;!--
_syntax: isUsingTextureMatrix()_
_name: isUsingTextureMatrix_
_returns: bool_
_returns_description: _
_parameters: _
_access: public_
_version_started: 0.9.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

###void loadData(&buffer, glFormat, glType)

&lt;!--
_syntax: loadData(&buffer, glFormat, glType)_
_name: loadData_
_returns: void_
_returns_description: _
_parameters: const ofBufferObject &buffer, int glFormat, int glType_
_access: public_
_version_started: 0.9.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Load pixels from an ofBufferObject

This is different to allocate(ofBufferObject,internal). That
creates a texture which data lives in GL buffer while this
copies the data from the buffer to the texture.

This is usually used to upload data to be shown asynchronously
by using a buffer object binded as a PBO


**Parameters:**

buffer The buffer to load.

glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.

glType the GL type to load.





_description: _







&lt;!----------------------------------------------------------------------------->

###void loadData(&pix)

&lt;!--
_syntax: loadData(&pix)_
_name: loadData_
_returns: void_
_returns_description: _
_parameters: const ofPixels &pix_
_access: public_
_version_started: 007_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Load pixels from an ofPixels instance.

**Parameters:**

pix Reference to ofPixels instance.





_description: _







&lt;!----------------------------------------------------------------------------->

###void loadData(&pix)

&lt;!--
_syntax: loadData(&pix)_
_name: loadData_
_returns: void_
_returns_description: _
_parameters: const ofShortPixels &pix_
_access: public_
_version_started: 007_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Load pixels from an ofShortPixels instance.

Same as loadData(ofPixels &) but for ofShortPixels.


**See also**: loadData(const ofPixels & pix)

**Parameters:**

pix Reference to ofShortPixels instance.





_description: _







&lt;!----------------------------------------------------------------------------->

###void loadData(&pix)

&lt;!--
_syntax: loadData(&pix)_
_name: loadData_
_returns: void_
_returns_description: _
_parameters: const ofFloatPixels &pix_
_access: public_
_version_started: 007_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Load pixels from an ofFloatPixels instance.

Same as loadData(ofPixels &) but for ofFloatPixels.


**See also**: loadData(const ofPixels & pix)

**Parameters:**

pix Reference to ofFloatPixels instance.





_description: _







&lt;!----------------------------------------------------------------------------->

###void loadData(&pix, glFormat)

&lt;!--
_syntax: loadData(&pix, glFormat)_
_name: loadData_
_returns: void_
_returns_description: _
_parameters: const ofPixels &pix, int glFormat_
_access: public_
_version_started: 0073_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Load pixels from an ofPixels instance and specify the format.

glFormat can be different to the internal format of the texture on each
load, ie. we can upload GL_BGRA pixels into a GL_RGBA texture, but the
number of channels need to match according to the OpenGL standard.


**Parameters:**

pix Reference to ofPixels instance.

glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.





_description: _







&lt;!----------------------------------------------------------------------------->

###void loadData(&pix, glFormat)

&lt;!--
_syntax: loadData(&pix, glFormat)_
_name: loadData_
_returns: void_
_returns_description: _
_parameters: const ofShortPixels &pix, int glFormat_
_access: public_
_version_started: 0073_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Load pixels from an ofShortPixels instance & specify the format.


**See also**: loadData(const ofPixels & pix, int glFormat)

**Parameters:**

pix Reference to ofShortPixels instance.

glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.





_description: _







&lt;!----------------------------------------------------------------------------->

###void loadData(&pix, glFormat)

&lt;!--
_syntax: loadData(&pix, glFormat)_
_name: loadData_
_returns: void_
_returns_description: _
_parameters: const ofFloatPixels &pix, int glFormat_
_access: public_
_version_started: 0073_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Load pixels from an ofFloatPixels instance and specify the format.


**See also**: loadData(const ofPixels & pix, int glFormat)

**Parameters:**

pix Reference to ofFloatPixels instance.

glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.





_description: _







&lt;!----------------------------------------------------------------------------->

###void loadData(*data, w, h, glFormat)

&lt;!--
_syntax: loadData(*data, w, h, glFormat)_
_name: loadData_
_returns: void_
_returns_description: _
_parameters: const uint16_t *data, int w, int h, int glFormat_
_access: public_
_version_started: 007_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Load short (2 byte) pixel data.

**See also**: loadData(const unsigned char* const data, int w, int h, int glFormat)

**Parameters:**

data Pointer to byte pixel data. Must not be nullptr.

w Pixel data width.

h Pixel data height.

glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.





_description: _







&lt;!----------------------------------------------------------------------------->

###void loadData(*data, w, h, glFormat)

&lt;!--
_syntax: loadData(*data, w, h, glFormat)_
_name: loadData_
_returns: void_
_returns_description: _
_parameters: const uint32_t *data, int w, int h, int glFormat_
_access: public_
_version_started: 0.10.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

###void loadData(*data, w, h, glFormat)

&lt;!--
_syntax: loadData(*data, w, h, glFormat)_
_name: loadData_
_returns: void_
_returns_description: _
_parameters: const int8_t *data, int w, int h, int glFormat_
_access: public_
_version_started: 0.10.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

###void loadData(*data, w, h, glFormat)

&lt;!--
_syntax: loadData(*data, w, h, glFormat)_
_name: loadData_
_returns: void_
_returns_description: _
_parameters: const int16_t *data, int w, int h, int glFormat_
_access: public_
_version_started: 0.10.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

###void loadData(*data, w, h, glFormat)

&lt;!--
_syntax: loadData(*data, w, h, glFormat)_
_name: loadData_
_returns: void_
_returns_description: _
_parameters: const int32_t *data, int w, int h, int glFormat_
_access: public_
_version_started: 0.10.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

###void loadData(*data, w, h, glFormat)

&lt;!--
_syntax: loadData(*data, w, h, glFormat)_
_name: loadData_
_returns: void_
_returns_description: _
_parameters: const float *data, int w, int h, int glFormat_
_access: public_
_version_started: 007_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Load float pixel data.

**See also**: loadData(const unsigned char* const data, int w, int h, int glFormat)

**Parameters:**

data Pointer to byte pixel data. Must not be nullptr.

w Pixel data width.

h Pixel data height.

glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.





_description: _







&lt;!----------------------------------------------------------------------------->

###void loadData(*data, w, h, glFormat, glType)

&lt;!--
_syntax: loadData(*data, w, h, glFormat, glType)_
_name: loadData_
_returns: void_
_returns_description: _
_parameters: const void *data, int w, int h, int glFormat, int glType_
_access: public_
_version_started: 0073_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Load byte pixel data.

glFormat can be different to the internal format of the texture on each
load, i.e. we can upload GL_BGRA pixels into a GL_RGBA texture but the
number of channels need to match according to the OpenGL standard.


**Parameters:**

data Pointer to byte pixel data. Must not be nullptr.

w Pixel data width.

h Pixel data height.

glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.

glType the OpenGL type of the data.





_description: _







&lt;!----------------------------------------------------------------------------->

###void loadData(data, w, h, glFormat)

&lt;!--
_syntax: loadData(data, w, h, glFormat)_
_name: loadData_
_returns: void_
_returns_description: _
_parameters: const uint8_t *const data, int w, int h, int glFormat_
_access: public_
_version_started: 007_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Load byte pixel data.

glFormat can be different to the internal format of the texture on each
load, i.e. we can upload GL_BGRA pixels into a GL_RGBA texture but the
number of channels need to match according to the OpenGL standard.


**Parameters:**

data Pointer to byte pixel data. Must not be nullptr.

w Pixel data width.

h Pixel data height.

glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.





_description: _







&lt;!----------------------------------------------------------------------------->

###void loadScreenData(x, y, w, h)

&lt;!--
_syntax: loadScreenData(x, y, w, h)_
_name: loadScreenData_
_returns: void_
_returns_description: _
_parameters: int x, int y, int w, int h_
_access: public_
_version_started: 006_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Copy an area of the screen into this texture.

Specifiy the position (x,y) you wish to grab from, with the width (w)
and height (h) of the region.

Make sure that you have allocated your texture (using `allocate()`)
to be large enough to hold the region of the screen you wish to load.


**See also**: http://www.opengl.org/sdk/docs/man4/html/glCopyTexSubImage2D.xhtml


**Parameters:**

x Upper left corner horizontal screen position.

y Upper left corner vertical screen position.

w Width of the area to copy in pixels.

h Height of the area to copy in pixels.





_description: _

Grabs a region of the screen and loads it into the texture. Specifiy the position (x,y) you wish to grab from, with the width (w) and height (h) of the region. Make sure that you have allocated your texture (using allocate()) to be large enough to hold the region of the screen you wish to load.
Load data from the current screen into this texture. Grabs a region of the screen and loads it into the texture. Specifiy the position (x,y) you wish to grab from, with the width (w) and height (h) of the region. Make sure that you have allocated your texture (using allocate()) to be large enough to hold the region of the screen you wish to load.





&lt;!----------------------------------------------------------------------------->

### ofTexture(&&mom)

&lt;!--
_syntax: ofTexture(&&mom)_
_name: ofTexture_
_returns: _
_returns_description: _
_parameters: ofTexture &&mom_
_access: public_
_version_started: 0.10.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

### ofTexture(&mom)

&lt;!--
_syntax: ofTexture(&mom)_
_name: ofTexture_
_returns: _
_returns_description: _
_parameters: const ofTexture &mom_
_access: public_
_version_started: 007_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Construct an ofTexture from an existing ofTexture.

**Parameters:**

mom The ofTexture to copy. Reuses internal GL texture ID.





_description: _







&lt;!----------------------------------------------------------------------------->

### ofTexture()

&lt;!--
_syntax: ofTexture()_
_name: ofTexture_
_returns: _
_returns_description: _
_parameters: _
_access: public_
_version_started: 006_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: False_
_advanced: False_
-->

_inlined_description: _

\section Construction and Allocation
Construct an ofTexture instance.





_description: _

Creates an empty ofTexture instance. You can't draw a texture right after it's been created as it has actually uploaded any data to the graphics card that can be drawn yet.





&lt;!----------------------------------------------------------------------------->

###ofTexture & operator=(&&mom)

&lt;!--
_syntax: operator=(&&mom)_
_name: operator=_
_returns: ofTexture &_
_returns_description: _
_parameters: ofTexture &&mom_
_access: public_
_version_started: 0.10.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

###ofTexture & operator=(&mom)

&lt;!--
_syntax: operator=(&mom)_
_name: operator=_
_returns: ofTexture &_
_returns_description: _
_parameters: const ofTexture &mom_
_access: public_
_version_started: 007_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

\section Update Texture
Copy a given ofTexture into this texture.

**Parameters:**

mom The ofTexture to copy from. Reuses internal GL texture ID.





_description: _







&lt;!----------------------------------------------------------------------------->

###void readToPixels(&pixels)

&lt;!--
_syntax: readToPixels(&pixels)_
_name: readToPixels_
_returns: void_
_returns_description: _
_parameters: ofPixels &pixels_
_access: public_
_version_started: 007_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

\section Read Pixel Data
Read current texture data from the GPU into pixels.


**Warning**: This is not supported in OpenGL ES and does nothing.


**Parameters:**

pixels Target ofPixels reference.





_description: _







&lt;!----------------------------------------------------------------------------->

###void readToPixels(&pixels)

&lt;!--
_syntax: readToPixels(&pixels)_
_name: readToPixels_
_returns: void_
_returns_description: _
_parameters: ofShortPixels &pixels_
_access: public_
_version_started: 007_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Read current texture data from the GPU into pixels.


**Warning**: This is not supported in OpenGL ES and does nothing.


**Parameters:**

pixels Target pixels reference.





_description: _







&lt;!----------------------------------------------------------------------------->

###void readToPixels(&pixels)

&lt;!--
_syntax: readToPixels(&pixels)_
_name: readToPixels_
_returns: void_
_returns_description: _
_parameters: ofFloatPixels &pixels_
_access: public_
_version_started: 007_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Read current texture data from the GPU into pixels.


**Warning**: This is not supported in OpenGL ES and does nothing.


**Parameters:**

pixels Target pixels reference.





_description: _







&lt;!----------------------------------------------------------------------------->

###void resetAnchor()

&lt;!--
_syntax: resetAnchor()_
_name: resetAnchor_
_returns: void_
_returns_description: _
_parameters: _
_access: public_
_version_started: 006_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Reset the anchor point to (0, 0).





_description: _







&lt;!----------------------------------------------------------------------------->

###void setAlphaMask(&mask)

&lt;!--
_syntax: setAlphaMask(&mask)_
_name: setAlphaMask_
_returns: void_
_returns_description: _
_parameters: ofTexture &mask_
_access: public_
_version_started: 0.9.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

\section Texture Settings
Set another ofTexture to use as an alpha mask.

**Parameters:**

mask The texture to use as alpha mask.





_description: _







&lt;!----------------------------------------------------------------------------->

###void setAnchorPercent(xPct, yPct)

&lt;!--
_syntax: setAnchorPercent(xPct, yPct)_
_name: setAnchorPercent_
_returns: void_
_returns_description: _
_parameters: float xPct, float yPct_
_access: public_
_version_started: 006_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Set the anchor point the texture is drawn around as a percentage.

This can be useful if you want to rotate an image around a particular
point.


**Parameters:**

xPct Horizontal texture position as a percentage (0 - 1).

yPct Vertical texture position as a percentage (0 - 1).





_description: _

The anchor is the point the image is drawn around. This can be useful if you want to rotate an image around a particular point, allowing you to set the anchor as a percentage of the image width/height ( 0.0-1.0 range )





&lt;!----------------------------------------------------------------------------->

###void setAnchorPoint(x, y)

&lt;!--
_syntax: setAnchorPoint(x, y)_
_name: setAnchorPoint_
_returns: void_
_returns_description: _
_parameters: float x, float y_
_access: public_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Set the anchor point the texture is drawn around in pixels.

This can be useful if you want to rotate an image around a particular
point.


**Parameters:**

x Horizontal texture position in pixels.

y Vertical texture position in pixels.





_description: _

set the anchor point in pixels





&lt;!----------------------------------------------------------------------------->

###void setCompression(compression)

&lt;!--
_syntax: setCompression(compression)_
_name: setCompression_
_returns: void_
_returns_description: _
_parameters: ofTexCompression compression_
_access: public_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Set the texture compression.

\warning: not yet implemented.

**See also**: ofTexCompression





_description: _







&lt;!----------------------------------------------------------------------------->

###void setRGToRGBASwizzles(rToRGBSwizzles)

&lt;!--
_syntax: setRGToRGBASwizzles(rToRGBSwizzles)_
_name: setRGToRGBASwizzles_
_returns: void_
_returns_description: _
_parameters: bool rToRGBSwizzles_
_access: public_
_version_started: 0073_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

\todo Define Swizzle in the documentation.
Swizzle RGBA to grayscale with alpha in the red channel.

Use 1 channel GL_R as luminance instead of red channel in OpenGL 3+.


**Warning**: This is not supported in OpenGL ES and does nothing.

**See also**: https://en.wikipedia.org/wiki/Swizzling_(computer_graphics)





_description: _







&lt;!----------------------------------------------------------------------------->

###void setSwizzle(srcSwizzle, dstChannel)

&lt;!--
_syntax: setSwizzle(srcSwizzle, dstChannel)_
_name: setSwizzle_
_returns: void_
_returns_description: _
_parameters: GLenum srcSwizzle, GLenum dstChannel_
_access: public_
_version_started: 0.9.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Swizzle a channel to another

Example:

~~~~~
ofTexture tex;
tex.setSwizzle(GL_TEXTURE_SWIZZLE_R,GL_ALPHA);
~~~~~

will make channel 0 appear as alpha in the shader.


**Warning**: This is not supported in OpenGL ES and does nothing.

**See also**: https://en.wikipedia.org/wiki/Swizzling_(computer_graphics)





_description: _







&lt;!----------------------------------------------------------------------------->

###void setTextureMatrix(&m)

&lt;!--
_syntax: setTextureMatrix(&m)_
_name: setTextureMatrix_
_returns: void_
_returns_description: _
_parameters: const glm::mat4 &m_
_access: public_
_version_started: 0.9.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Sets a texture matrix to be uploaded whenever the texture is bound.

**Parameters:**

m The 4x4 texture matrix.





_description: _







&lt;!----------------------------------------------------------------------------->

###void setTextureMinMagFilter(minFilter, magFilter)

&lt;!--
_syntax: setTextureMinMagFilter(minFilter, magFilter)_
_name: setTextureMinMagFilter_
_returns: void_
_returns_description: _
_parameters: GLint minFilter, GLint magFilter_
_access: public_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Set texture minification/magnification scaling filters.

Controls how OpenGL will scale this texture.


**See also**: http://www.opengl.org/sdk/docs/man4/html/glTexParameter.xhtml

**See also**: ofTextureSetMinMagFilters()


**Warning**: May be overridden.


**Parameters:**

minFilter minifying filter for scaling a pixel to a smaller area.

magFilter magnifying filter for scaling a pixel to a larger area.





_description: _

Set how the texture is scaled up and down, when it's being drawn larger or smaller than it's actual size.





&lt;!----------------------------------------------------------------------------->

###void setTextureWrap(wrapModeHorizontal, wrapModeVertical)

&lt;!--
_syntax: setTextureWrap(wrapModeHorizontal, wrapModeVertical)_
_name: setTextureWrap_
_returns: void_
_returns_description: _
_parameters: GLint wrapModeHorizontal, GLint wrapModeVertical_
_access: public_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Set texture wrapping.

By default, textures are clamped to their edges with `GL_CLAMP_TO_EDGE`.
Setting a repeat mode like `GL_REPEAT` allows you to create tiled
backgrounds with small textures.


**See also**: ofTextureSetWrap()

**See also**: http://www.opengl.org/sdk/docs/man4/html/glTexParameter.xhtml


**Warning**: May be overridden.


**Parameters:**

wrapModeHorizontal wrap parameter for texture coordinate s.

wrapModeVertical wrap parameter for texture coordinate t.





_description: _

Sets how the texture wraps around the edges of the vertices that the texture is being drawn to.





&lt;!----------------------------------------------------------------------------->

###void setUseExternalTextureID(externTexID)

&lt;!--
_syntax: setUseExternalTextureID(externTexID)_
_name: setUseExternalTextureID_
_returns: void_
_returns_description: _
_parameters: GLuint externTexID_
_access: public_
_version_started: 0072_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Set the texture ID.

Allows you to point the texture id to an externally allocated id
(perhaps from another texture). It's up to you to set the rest of the
textData parameters manually.


**Warning**: When setting an external texture ID, the user must set the
remaining ofTextureData parameters manually.

**Parameters:**

externTexID New texture ID.





_description: _







&lt;!----------------------------------------------------------------------------->

###void unbind(textureLocation = 0)

&lt;!--
_syntax: unbind(textureLocation = 0)_
_name: unbind_
_returns: void_
_returns_description: _
_parameters: int textureLocation=0_
_access: public_
_version_started: 006_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Unbind the texture.

For advanced users who need to manually manage texture drawing without
calling ofTexture::draw.


**See also**: http://www.opengl.org/sdk/docs/man4/html/glBindTexture.xhtml





_description: _

This for the advanced user who wants to draw textures in their own way. This stops vertices from being textured using this texture.





&lt;!----------------------------------------------------------------------------->

### ~ofTexture()

&lt;!--
_syntax: ~ofTexture()_
_name: ~ofTexture_
_returns: _
_returns_description: _
_parameters: _
_access: public_
_version_started: 006_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: False_
_advanced: False_
-->

_inlined_description: _

Destroy an ofTexture instance.

ofTexture keeps a reference count for the internal OpenGL texture ID.
Thus, the texture ID is only released if there are no additional
references to the internal texture ID.





_description: _







&lt;!----------------------------------------------------------------------------->

##Variables



###ofPoint anchor

&lt;!--
_name: anchor_
_type: ofPoint_
_access: protected_
_version_started: 006_
_version_deprecated: _
_summary: _
_visible: True_
_constant: False_
_advanced: False_
-->

_inlined_description: _

&lt; The texture's anchor point.





_description: _







&lt;!----------------------------------------------------------------------------->

###bool bAnchorIsPct

&lt;!--
_name: bAnchorIsPct_
_type: bool_
_access: protected_
_version_started: 006_
_version_deprecated: _
_summary: _
_visible: True_
_constant: False_
_advanced: False_
-->

_inlined_description: _

&lt; Is the anchor point represented as a normalized
&lt; (0 - 1) coordinate?





_description: _







&lt;!----------------------------------------------------------------------------->

###bool bWantsMipmap

&lt;!--
_name: bWantsMipmap_
_type: bool_
_access: private_
_version_started: 0.9.0_
_version_deprecated: _
_summary: _
_visible: True_
_constant: False_
_advanced: False_
-->

_inlined_description: _

&lt; Should mipmaps be created?





_description: _







&lt;!----------------------------------------------------------------------------->

###ofTextureData texData

&lt;!--
_name: texData_
_type: ofTextureData_
_access: public_
_version_started: 006_
_version_deprecated: _
_summary: _
_visible: True_
_constant: False_
_advanced: True_
-->

_inlined_description: _

&lt; Internal texture data access.
&lt; For backwards compatibility.





_description: _

texData is a variable type ofTextureData. ofTextureData is a structure containing information about the texture such as size.





&lt;!----------------------------------------------------------------------------->

</textarea></div></div></div></div></div></div><script defer src="/_nuxt/payloads/1586012716389/documentation/gl/ofTexture/payload.js"></script><script src="/_nuxt/5f71eaca0bd2f1a0f939.js" defer></script><script src="/_nuxt/35a90d914f539af1362f.js" defer></script><script src="/_nuxt/906a3ca0fb13ed3c6651.js" defer></script><script src="/_nuxt/b673915e8a08acf593e8.js" defer></script><script src="/_nuxt/bf355f21967a23c26c07.js" defer></script>
  </body>
</html>
