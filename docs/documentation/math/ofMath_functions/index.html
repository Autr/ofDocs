<!doctype html>
<html data-n-head-ssr>
  <head>
    <title>ofMath_functions | documentation | ofDocs</title><meta data-n-head="ssr" data-hid="description" name="description" content="openFrameworks documentation and examples browser"><meta data-n-head="ssr" data-hid="keyword" name="keyword" content=""><meta data-n-head="ssr" property="og:description" content="openFrameworks documentation and examples browser" vmid="og:description"><meta data-n-head="ssr" property="og:title" content="ofMath_functions | documentation | ofDocs" vmid="og:title"><meta data-n-head="ssr" property="og:image" content="/files/images/ofw-logo.png" vmid="og:image"><link rel="preload" href="/_nuxt/3213b67383225fc2f59b.js" as="script"><link rel="preload" href="/_nuxt/5fe5bba000836bc4a25f.js" as="script"><link rel="preload" href="/_nuxt/fe12c0cb7395fa1032f4.css" as="style"><link rel="preload" href="/_nuxt/f8d94d1c92ade1d8a6da.js" as="script"><link rel="preload" href="/_nuxt/a24b354526a25539cceb.css" as="style"><link rel="preload" href="/_nuxt/9a7e20c23e9625feab77.js" as="script"><link rel="preload" href="/_nuxt/21c4d0f9583096394838.css" as="style"><link rel="preload" href="/_nuxt/d1291586b31fa28ca9d5.js" as="script"><link rel="stylesheet" href="/_nuxt/fe12c0cb7395fa1032f4.css"><link rel="stylesheet" href="/_nuxt/a24b354526a25539cceb.css"><link rel="stylesheet" href="/_nuxt/21c4d0f9583096394838.css">
  </head>
  <body>
    <div data-server-rendered="true" id="__nuxt"><!----><div id="__layout"><div id="app" class="unknown"><div id="menu"><h1 class="of"><div class="inner"><span><a href="/" class="nuxt-link-active"><div class="txt"><span class="docs f7 questrial">ofDocs </span><span class="version">0.11.0</span></div></a></span></div></h1><div id="search"><div class="inner"><div class="field text"><div class="field-inner"><svg viewbox="0 0 36 36" x="0px" y="0px" enable-background="new 0 0 36 36" xml:space="preserve"><path d="M35.525,31.228l-8.88-8.882c1.444-2.238,2.298-4.895,2.298-7.752c0-7.909-6.438-14.343-14.346-14.343						c-7.911,0-14.343,6.434-14.343,14.343c0,7.911,6.433,14.344,14.343,14.344c2.856,0,5.513-0.849,7.752-2.294l8.88,8.88						c0.295,0.297,0.782,0.297,1.076,0l3.22-3.221C35.824,32.008,35.824,31.523,35.525,31.228z M4.81,14.593						c0-5.396,4.391-9.788,9.788-9.788c5.398,0,9.787,4.392,9.787,9.788c0,5.398-4.389,9.789-9.787,9.789						C9.2,24.382,4.81,19.991,4.81,14.593z"></path></svg><!----><div class="text-wrapper"><input id="search_field" name="search_field" placeholder="Search (Alt+F)" autocomplete="off" tabindex="0"></div><!----><!----></div></div></div><div id="results" class="mt1"></div></div><div id="lists" class="menu-inner mt1"><div class="inner"><div class="item documentation"><a href="/documentation/" title="/documentation/" class="nuxt-link-active"><i class="ico" style="display:none"></i><span>documentation</span><span style="display:none">documentation</span></a><div class="list"><div class="item 3d"><a href="/documentation/3d/" title="/documentation/3d/"><i class="ico" style="display:none"></i><span style="display:none"></span><span>3d</span></a><!----></div><div class="item addons"><a href="/documentation/addons/" title="/documentation/addons/"><i class="ico" style="display:none">extension</i><span style="display:none"></span><span>addons</span></a><!----></div><div class="item application"><a href="/documentation/application/" title="/documentation/application/"><i class="ico" style="display:none">web</i><span style="display:none"></span><span>application</span></a><!----></div><div class="item communication"><a href="/documentation/communication/" title="/documentation/communication/"><i class="ico" style="display:none">language</i><span style="display:none"></span><span>communication</span></a><!----></div><div class="item events"><a href="/documentation/events/" title="/documentation/events/"><i class="ico" style="display:none">question_answer</i><span style="display:none"></span><span>events</span></a><!----></div><div class="item gl"><a href="/documentation/gl/" title="/documentation/gl/"><i class="ico" style="display:none"></i><span style="display:none"></span><span>gl</span></a><!----></div><div class="item glm"><a href="/documentation/glm/" title="/documentation/glm/"><i class="ico" style="display:none"></i><span style="display:none"></span><span>glm</span></a><!----></div><div class="item graphics"><a href="/documentation/graphics/" title="/documentation/graphics/"><i class="ico" style="display:none">category</i><span style="display:none"></span><span>graphics</span></a><!----></div><div class="item math"><a href="/documentation/math/" title="/documentation/math/" class="nuxt-link-active"><i class="ico" style="display:none">border_clear</i><span style="display:none"></span><span>math</span></a><div class="list"><div class="item ofMath_functions"><a href="/documentation/math/ofMath_functions" title="/documentation/math/ofMath_functions.markdown" class="nuxt-link-exact-active nuxt-link-active"><i class="ico" style="display:none"></i><span style="display:none"></span><span>ofMath_functions</span></a><div class="list"></div></div><div class="item ofMath"><a href="/documentation/math/ofMath" title="/documentation/math/ofMath.markdown"><i class="ico" style="display:none"></i><span style="display:none"></span><span>ofMath</span></a><div class="list"></div></div><div class="item ofMatrix3x3"><a href="/documentation/math/ofMatrix3x3" title="/documentation/math/ofMatrix3x3.markdown"><i class="ico" style="display:none"></i><span style="display:none"></span><span>ofMatrix3x3</span></a><!----></div><div class="item ofMatrix4x4"><a href="/documentation/math/ofMatrix4x4" title="/documentation/math/ofMatrix4x4.markdown"><i class="ico" style="display:none"></i><span style="display:none"></span><span>ofMatrix4x4</span></a><!----></div><div class="item ofQuaternion"><a href="/documentation/math/ofQuaternion" title="/documentation/math/ofQuaternion.markdown"><i class="ico" style="display:none"></i><span style="display:none"></span><span>ofQuaternion</span></a><!----></div><div class="item ofVec2f"><a href="/documentation/math/ofVec2f" title="/documentation/math/ofVec2f.markdown"><i class="ico" style="display:none"></i><span style="display:none"></span><span>ofVec2f</span></a><!----></div><div class="item ofVec3f"><a href="/documentation/math/ofVec3f" title="/documentation/math/ofVec3f.markdown"><i class="ico" style="display:none"></i><span style="display:none"></span><span>ofVec3f</span></a><!----></div><div class="item ofVec4f"><a href="/documentation/math/ofVec4f" title="/documentation/math/ofVec4f.markdown"><i class="ico" style="display:none"></i><span style="display:none"></span><span>ofVec4f</span></a><!----></div><div class="item ofVectorMath_functions"><a href="/documentation/math/ofVectorMath_functions" title="/documentation/math/ofVectorMath_functions.markdown"><i class="ico" style="display:none"></i><span style="display:none"></span><span>ofVectorMath_functions</span></a><!----></div></div></div><div class="item sound"><a href="/documentation/sound/" title="/documentation/sound/"><i class="ico" style="display:none">volume_up</i><span style="display:none"></span><span>sound</span></a><!----></div><div class="item types"><a href="/documentation/types/" title="/documentation/types/"><i class="ico" style="display:none">ring_volume</i><span style="display:none"></span><span>types</span></a><!----></div><div class="item utils"><a href="/documentation/utils/" title="/documentation/utils/"><i class="ico" style="display:none">build</i><span style="display:none"></span><span>utils</span></a><!----></div><div class="item video"><a href="/documentation/video/" title="/documentation/video/"><i class="ico" style="display:none">videocam</i><span style="display:none"></span><span>video</span></a><!----></div></div></div><div class="item examples"><a href="/examples/" title="/examples/"><i class="ico" style="display:none"></i><span>examples</span><span style="display:none">examples</span></a><!----></div><div class="item openframeworks"><a href="/openframeworks/" title="/openframeworks/"><i class="ico" style="display:none"></i><span>openFrameworks</span><span style="display:none">openframeworks</span></a><!----></div><div class="item addons"><a href="/addons/" title="/addons/"><i class="ico" style="display:none">extension</i><span>addons</span><span style="display:none">addons</span></a><!----></div><div class="item guides"><a href="/guides/" title="/guides/"><i class="ico" style="display:none"></i><span>guides</span><span style="display:none">guides</span></a><!----></div></div></div></div><div id="document"><div id="renderer" class="main"><div absolute="/Users/gilbertsinnott/Code/openFrameworks/ofSite/documentation/math/ofMath_functions.markdown" route="/documentation/math/ofMath_functions.markdown" dir="../ofSite/documentation/math" ext="markdown" type="page" id="2128" parent="2123" siblings="" translations="[object Object]" class="doc-header"><div class="doc-header-inner"><div class="inner"><div class="mt2 mb2"><span class="breadcrumbs"><span class="crumb"><a href="/" class="pink nuxt-link-active">ofDocs</a><span class="chevron right"></span></span><span class="crumb"><a href="/documentation/" class="pink nuxt-link-active">documentation </a><!----><span class="chevron right"></span></span><span class="crumb"><a href="/documentation/math/" class="pink nuxt-link-active">math </a><!----><span class="chevron right"></span></span><span class="crumb"><!----><span class="link selector"><span>ofMath_functions </span><span class="chevron bottom"></span><select><option value="/documentation/math/ofMath_functions">ofMath_functions</option><option value="/documentation/math/ofMath">ofMath</option><option value="/documentation/math/ofMatrix3x3">ofMatrix3x3</option><option value="/documentation/math/ofMatrix4x4">ofMatrix4x4</option><option value="/documentation/math/ofQuaternion">ofQuaternion</option><option value="/documentation/math/ofVec2f">ofVec2f</option><option value="/documentation/math/ofVec3f">ofVec3f</option><option value="/documentation/math/ofVec4f">ofVec4f</option><option value="/documentation/math/ofVectorMath_functions">ofVectorMath_functions</option></select></span><!----></span></span></div></div></div></div><div class="editable-wrapper"><div class="header inner"><h1 class="page-title mb4 questrial"><span class="f7"><!----><span>ofMath_functions </span></span><span class="f3"></span></h1><div class="actions"><a href="/about/contribute/" class="button"><i class="ico">edit</i><span>Edit</span></a></div></div><div class="rendered"><div id="documentation-page" static="true"><div id="offset-page"><div id="doc-body" class="markdown"><div class="inner"><div id="description"><!----></div><div id="methods"><hr><section name="ofAngleDifferenceDegrees" id="ofAngleDifferenceDegrees" class="mb2"><div class="method mb2"><h3 class="f3 title">ofAngleDifferenceDegrees(<code class="pink">…</code>)</h3><code><span class="token keyword">float  </span><span class="token function">ofAngleDifferenceDegrees</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> currentAngle<span class="token punctuation">,</span> <span class="token keyword">float</span> targetAngle</code><span class="token punctuation">)</span></code><div class="short"><p>Calculates the difference between two angles in degrees.</p>
<p>This will calculate the actual difference, taking into account multiple
revolutions. For example:</p>
<pre><code>		<span class="token function">ofAngleDifferenceDegrees</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Returns 90.</span>
		<span class="token function">ofAngleDifferenceDegrees</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">450</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Also returns 90.</span>
</code></pre>
<p><strong>Parameters:</strong></p>
<p>currentAngle The current angle in degrees.</p>
<p>targetAngle the angle to be compared to in degrees.</p>
<p><strong>Returns</strong>: The difference between two angles in degrees.</p>
</div><div class="desc"></div></div><hr></section><section name="ofAngleDifferenceRadians" id="ofAngleDifferenceRadians" class="mb2"><div class="method mb2"><h3 class="f3 title">ofAngleDifferenceRadians(<code class="pink">…</code>)</h3><code><span class="token keyword">float  </span><span class="token function">ofAngleDifferenceRadians</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> currentAngle<span class="token punctuation">,</span> <span class="token keyword">float</span> targetAngle</code><span class="token punctuation">)</span></code><div class="short"><p>Calculates the difference between two angles in radians.</p>
<p>This will calculate the actual difference, taking into account multiple
revolutions. For example:</p>
<pre><code>		<span class="token function">ofAngleDifferenceRadians</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> PI<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Returns -PI.</span>
		<span class="token function">ofAngleDifferenceRadians</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token operator">*</span>PI<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Also returns -PI.</span>
</code></pre>
<p><strong>Parameters:</strong></p>
<p>currentAngle The current angle in radians.</p>
<p>targetAngle the angle to be compared to in radians.</p>
<p><strong>Returns</strong>: The difference between two angles in radians.</p>
</div><div class="desc"></div></div><hr></section><section name="ofBezierPoint" id="ofBezierPoint" class="mb2"><div class="method mb2"><h3 class="f3 title">ofBezierPoint(<code class="pink">…</code>)</h3><code><span class="token keyword">vectype  </span><span class="token function">ofBezierPoint</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> vectype <span class="token operator">&</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> vectype <span class="token operator">&</span>b<span class="token punctuation">,</span> <span class="token keyword">const</span> vectype <span class="token operator">&</span>c<span class="token punctuation">,</span> <span class="token keyword">const</span> vectype <span class="token operator">&</span>d<span class="token punctuation">,</span> <span class="token keyword">float</span> t</code><span class="token punctuation">)</span></code><div class="short"><p>Given the four points that determine a bezier curve, return an interpolated point on the curve.</p>
<p><strong>Parameters:</strong></p>
<p>a The beginning point of the curve.</p>
<p>b The first control point.</p>
<p>c The second control point.</p>
<p>d The end point of the curve.</p>
<p>t an offset along the curve, normalized between 0 and 1.</p>
<p><strong>Returns</strong>: A glm::vec3 on the curve.</p>
</div><div class="desc"></div></div><hr></section><section name="ofBezierTangent" id="ofBezierTangent" class="mb2"><div class="method mb2"><h3 class="f3 title">ofBezierTangent(<code class="pink">…</code>)</h3><code><span class="token keyword">vectype  </span><span class="token function">ofBezierTangent</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> vectype <span class="token operator">&</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> vectype <span class="token operator">&</span>b<span class="token punctuation">,</span> <span class="token keyword">const</span> vectype <span class="token operator">&</span>c<span class="token punctuation">,</span> <span class="token keyword">const</span> vectype <span class="token operator">&</span>d<span class="token punctuation">,</span> <span class="token keyword">float</span> t</code><span class="token punctuation">)</span></code><div class="short"><p>Given the four points that determine a bezier curve and an offset along the curve, return an tangent vector to a point on the curve.
Currently this is not a normalized point, and will need to be normalized.</p>
<p><strong>Parameters:</strong></p>
<p>a The beginning point of the curve.</p>
<p>b The first control point.</p>
<p>c The second control point.</p>
<p>d The end point of the curve.</p>
<p>t an offset along the curve, normalized between 0 and 1.</p>
<p><strong>Returns</strong>: A glm::vec3 on the curve.</p>
</div><div class="desc"></div></div><hr></section><section name="ofClamp" id="ofClamp" class="mb2"><div class="method mb2"><h3 class="f3 title">ofClamp(<code class="pink">…</code>)</h3><code><span class="token keyword">float  </span><span class="token function">ofClamp</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> value<span class="token punctuation">,</span> <span class="token keyword">float</span> min<span class="token punctuation">,</span> <span class="token keyword">float</span> max</code><span class="token punctuation">)</span></code><div class="short"><p>Clamp a value between min and max.</p>
<p>Restricts a value to be within a specified range defined by values min and
max. If the value is min &lt;= value &lt;= max, returns value.  If the value is
greater than max, return max; if the value is less than min, return min.
Otherwise, return the value unchanged.</p>
<pre><code>		<span class="token keyword">float</span> val <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
		<span class="token keyword">float</span> newVal <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		newval <span class="token operator">=</span> <span class="token function">ofClamp</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// newval = 30</span>
		newval <span class="token operator">=</span> <span class="token function">ofClamp</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// newval = 5</span>
		newval <span class="token operator">=</span> <span class="token function">ofClamp</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// newval = 10</span>
</code></pre>
<p><strong>Parameters:</strong></p>
<p>value The number to be clamped.</p>
<p>min The lower bound of the range.</p>
<p>max The upper bound of the range.</p>
<p><strong>Returns</strong>: a floating point number in the range [min, max].</p>
</div><div class="desc"></div></div><hr></section><section name="ofCurvePoint" id="ofCurvePoint" class="mb2"><div class="method mb2"><h3 class="f3 title">ofCurvePoint(<code class="pink">…</code>)</h3><code><span class="token keyword">vectype  </span><span class="token function">ofCurvePoint</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> vectype <span class="token operator">&</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> vectype <span class="token operator">&</span>b<span class="token punctuation">,</span> <span class="token keyword">const</span> vectype <span class="token operator">&</span>c<span class="token punctuation">,</span> <span class="token keyword">const</span> vectype <span class="token operator">&</span>d<span class="token punctuation">,</span> <span class="token keyword">float</span> t</code><span class="token punctuation">)</span></code><div class="short"><p>Given the four points that determine a Catmull Rom curve, return an interpolated point on the curve.</p>
<p><strong>Parameters:</strong></p>
<p>a The first control point.</p>
<p>b The beginning point of the curve.</p>
<p>c The end point of the curve.</p>
<p>d The second control point.</p>
<p>t an offset along the curve, normalized between 0 and 1.</p>
<p><strong>Returns</strong>: A glm::vec3 on the curve.</p>
</div><div class="desc"></div></div><hr></section><section name="ofCurveTangent" id="ofCurveTangent" class="mb2"><div class="method mb2"><h3 class="f3 title">ofCurveTangent(<code class="pink">…</code>)</h3><code><span class="token keyword">vectype  </span><span class="token function">ofCurveTangent</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> vectype <span class="token operator">&</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> vectype <span class="token operator">&</span>b<span class="token punctuation">,</span> <span class="token keyword">const</span> vectype <span class="token operator">&</span>c<span class="token punctuation">,</span> <span class="token keyword">const</span> vectype <span class="token operator">&</span>d<span class="token punctuation">,</span> <span class="token keyword">float</span> t</code><span class="token punctuation">)</span></code><div class="short"><p>Return a tangent point for an offset along a Catmull Rom curve.</p>
<p><strong>Parameters:</strong></p>
<p>a The first control point.</p>
<p>b The beginning point of the curve.</p>
<p>c The end point of the curve.</p>
<p>d The second control point.</p>
<p>t an offset along the curve, normalized between 0 and 1.</p>
<p><strong>Returns</strong>: A glm::vec3 on the curve.</p>
</div><div class="desc"></div></div><hr></section><section name="ofDegToRad" id="ofDegToRad" class="mb2"><div class="method mb2"><h3 class="f3 title">ofDegToRad(<code class="pink">…</code>)</h3><code><span class="token keyword">float  </span><span class="token function">ofDegToRad</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> degrees</code><span class="token punctuation">)</span></code><div class="short"><p>Convert degrees to radians.</p>
<p>Example:</p>
<pre><code>		<span class="token keyword">float</span> result <span class="token operator">=</span> <span class="token function">ofDegToRad</span><span class="token punctuation">(</span><span class="token number">90</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// The result will be PI/2.</span>
</code></pre>
<p><strong>Parameters:</strong></p>
<p>degrees An angle in degrees.</p>
<p><strong>Returns</strong>: the angle in radians.</p>
</div><div class="desc"></div></div><hr></section><section name="ofDist" id="ofDist" class="mb2"><div class="method mb2"><h3 class="f3 title">ofDist(<code class="pink">…</code>)</h3><code><span class="token keyword">float  </span><span class="token function">ofDist</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> x1<span class="token punctuation">,</span> <span class="token keyword">float</span> y1<span class="token punctuation">,</span> <span class="token keyword">float</span> x2<span class="token punctuation">,</span> <span class="token keyword">float</span> y2</code><span class="token punctuation">)</span></code><div class="short"><p>Calculates the 2D distance between two points.</p>
<p>Uses the <a href="http://en.wikipedia.org/wiki/Pythagorean_theorem">Pythagorean theorem</a>.</p>
<p><strong>Parameters:</strong></p>
<p>x1 X position of first point.</p>
<p>y1 Y position of first point.</p>
<p>x2 X position of second point.</p>
<p>y2 Y position of second point.</p>
<p><strong>Returns</strong>: float Distance between points.</p>
</div><div class="desc"></div></div><hr></section><section name="ofDist" id="ofDist" class="mb2"><div class="method mb2"><h3 class="f3 title">ofDist(<code class="pink">…</code>)</h3><code><span class="token keyword">float  </span><span class="token function">ofDist</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> x1<span class="token punctuation">,</span> <span class="token keyword">float</span> y1<span class="token punctuation">,</span> <span class="token keyword">float</span> z1<span class="token punctuation">,</span> <span class="token keyword">float</span> x2<span class="token punctuation">,</span> <span class="token keyword">float</span> y2<span class="token punctuation">,</span> <span class="token keyword">float</span> z2</code><span class="token punctuation">)</span></code><div class="short"><p>Calculates the 3D distance between two points.</p>
<p>Uses the <a href="http://en.wikipedia.org/wiki/Pythagorean_theorem">Pythagorean theorem</a>.</p>
<p><strong>Parameters:</strong></p>
<p>x1 X position of first point.</p>
<p>y1 Y position of first point.</p>
<p>z1 Z position of first point.</p>
<p>x2 X position of second point.</p>
<p>y2 Y position of second point.</p>
<p>z2 Z position of second point.</p>
<p><strong>Returns</strong>: float Distance between points.</p>
</div><div class="desc"></div></div><hr></section><section name="ofDistSquared" id="ofDistSquared" class="mb2"><div class="method mb2"><h3 class="f3 title">ofDistSquared(<code class="pink">…</code>)</h3><code><span class="token keyword">float  </span><span class="token function">ofDistSquared</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> x1<span class="token punctuation">,</span> <span class="token keyword">float</span> y1<span class="token punctuation">,</span> <span class="token keyword">float</span> x2<span class="token punctuation">,</span> <span class="token keyword">float</span> y2</code><span class="token punctuation">)</span></code><div class="short"><p>Calculates the squared 2D distance between two points.</p>
<p>Same as ofDist() but doesn't take the square root sqrt() of the result,
which is a faster operation if you need to calculate and compare multiple
distances.</p>
<p><strong>Parameters:</strong></p>
<p>x1 X position of first point.</p>
<p>y1 Y position of first point.</p>
<p>x2 X position of second point.</p>
<p>y2 Y position of second point.</p>
<p><strong>Returns</strong>: distance-squared between two points.</p>
</div><div class="desc"></div></div><hr></section><section name="ofDistSquared" id="ofDistSquared" class="mb2"><div class="method mb2"><h3 class="f3 title">ofDistSquared(<code class="pink">…</code>)</h3><code><span class="token keyword">float  </span><span class="token function">ofDistSquared</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> x1<span class="token punctuation">,</span> <span class="token keyword">float</span> y1<span class="token punctuation">,</span> <span class="token keyword">float</span> z1<span class="token punctuation">,</span> <span class="token keyword">float</span> x2<span class="token punctuation">,</span> <span class="token keyword">float</span> y2<span class="token punctuation">,</span> <span class="token keyword">float</span> z2</code><span class="token punctuation">)</span></code><div class="short"><p>Calculates the squared 3D distance between two points.</p>
<p>Same as ofDist() but doesn't take the square root sqrt() of the result,
which is a faster operation if you need to calculate and compare multiple
distances.</p>
<p><strong>Parameters:</strong></p>
<p>x1 X position of first point.</p>
<p>y1 Y position of first point.</p>
<p>z1 Z position of first point.</p>
<p>x2 X position of second point.</p>
<p>y2 Y position of second point.</p>
<p>z2 Z position of second point.</p>
<p><strong>Returns</strong>: distance-squared between two points.</p>
</div><div class="desc"></div></div><hr></section><section name="ofInRange" id="ofInRange" class="mb2"><div class="method mb2"><h3 class="f3 title">ofInRange(<code class="pink">…</code>)</h3><code><span class="token keyword">bool  </span><span class="token function">ofInRange</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> t<span class="token punctuation">,</span> <span class="token keyword">float</span> min<span class="token punctuation">,</span> <span class="token keyword">float</span> max</code><span class="token punctuation">)</span></code><div class="short"><p>Determine if a number is inside of a giv(float)(en range.</p>
<p><strong>Parameters:</strong></p>
<p>t The value to test.</p>
<p>min The lower bound of the range.</p>
<p>max The upper bound of the range.</p>
<p><strong>Returns</strong>: true if the number t is the range of [min, max].</p>
</div><div class="desc"></div></div><hr></section><section name="ofInterpolateCatmullRom" id="ofInterpolateCatmullRom" class="mb2"><div class="method mb2"><h3 class="f3 title">ofInterpolateCatmullRom(<code class="pink">…</code>)</h3><code><span class="token keyword">Type  </span><span class="token function">ofInterpolateCatmullRom</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> Type <span class="token operator">&</span>y0<span class="token punctuation">,</span> <span class="token keyword">const</span> Type <span class="token operator">&</span>y1<span class="token punctuation">,</span> <span class="token keyword">const</span> Type <span class="token operator">&</span>y2<span class="token punctuation">,</span> <span class="token keyword">const</span> Type <span class="token operator">&</span>y3<span class="token punctuation">,</span> <span class="token keyword">float</span> pct</code><span class="token punctuation">)</span></code><div class="short"></div><div class="desc"></div></div><hr></section><section name="ofInterpolateCosine" id="ofInterpolateCosine" class="mb2"><div class="method mb2"><h3 class="f3 title">ofInterpolateCosine(<code class="pink">…</code>)</h3><code><span class="token keyword">Type  </span><span class="token function">ofInterpolateCosine</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> Type <span class="token operator">&</span>y1<span class="token punctuation">,</span> <span class="token keyword">const</span> Type <span class="token operator">&</span>y2<span class="token punctuation">,</span> <span class="token keyword">float</span> pct</code><span class="token punctuation">)</span></code><div class="short"><p>}</p>
</div><div class="desc"></div></div><hr></section><section name="ofInterpolateCubic" id="ofInterpolateCubic" class="mb2"><div class="method mb2"><h3 class="f3 title">ofInterpolateCubic(<code class="pink">…</code>)</h3><code><span class="token keyword">Type  </span><span class="token function">ofInterpolateCubic</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> Type <span class="token operator">&</span>y0<span class="token punctuation">,</span> <span class="token keyword">const</span> Type <span class="token operator">&</span>y1<span class="token punctuation">,</span> <span class="token keyword">const</span> Type <span class="token operator">&</span>y2<span class="token punctuation">,</span> <span class="token keyword">const</span> Type <span class="token operator">&</span>y3<span class="token punctuation">,</span> <span class="token keyword">float</span> pct</code><span class="token punctuation">)</span></code><div class="short"></div><div class="desc"></div></div><hr></section><section name="ofInterpolateHermite" id="ofInterpolateHermite" class="mb2"><div class="method mb2"><h3 class="f3 title">ofInterpolateHermite(<code class="pink">…</code>)</h3><code><span class="token keyword">Type  </span><span class="token function">ofInterpolateHermite</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> Type <span class="token operator">&</span>y0<span class="token punctuation">,</span> <span class="token keyword">const</span> Type <span class="token operator">&</span>y1<span class="token punctuation">,</span> <span class="token keyword">const</span> Type <span class="token operator">&</span>y2<span class="token punctuation">,</span> <span class="token keyword">const</span> Type <span class="token operator">&</span>y3<span class="token punctuation">,</span> <span class="token keyword">float</span> pct</code><span class="token punctuation">)</span></code><div class="short"></div><div class="desc"></div></div><hr></section><section name="ofInterpolateHermite" id="ofInterpolateHermite" class="mb2"><div class="method mb2"><h3 class="f3 title">ofInterpolateHermite(<code class="pink">…</code>)</h3><code><span class="token keyword">Type  </span><span class="token function">ofInterpolateHermite</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> Type <span class="token operator">&</span>y0<span class="token punctuation">,</span> <span class="token keyword">const</span> Type <span class="token operator">&</span>y1<span class="token punctuation">,</span> <span class="token keyword">const</span> Type <span class="token operator">&</span>y2<span class="token punctuation">,</span> <span class="token keyword">const</span> Type <span class="token operator">&</span>y3<span class="token punctuation">,</span> <span class="token keyword">float</span> pct<span class="token punctuation">,</span> <span class="token keyword">float</span> tension<span class="token punctuation">,</span> <span class="token keyword">float</span> bias</code><span class="token punctuation">)</span></code><div class="short"></div><div class="desc"></div></div><hr></section><section name="ofLerp" id="ofLerp" class="mb2"><div class="method mb2"><h3 class="f3 title">ofLerp(<code class="pink">…</code>)</h3><code><span class="token keyword">float  </span><span class="token function">ofLerp</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> start<span class="token punctuation">,</span> <span class="token keyword">float</span> stop<span class="token punctuation">,</span> <span class="token keyword">float</span> amt</code><span class="token punctuation">)</span></code><div class="short"><p>Linearly interpolate a value within a range.</p>
<p>Calculates a number between two numbers [start, stop] at a specific increment
(amt).  If we want the new number to be between start and stop numbers, amt
needs to be a number between 0 and 1, inclusive.  ofLerp() does not clamp
the values.</p>
<pre><code>		<span class="token keyword">float</span> init <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token keyword">float</span> end <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
		<span class="token keyword">float</span> increment <span class="token operator">=</span> <span class="token number">0.2</span><span class="token punctuation">;</span>
		<span class="token keyword">float</span> result <span class="token operator">=</span> <span class="token function">ofLerp</span><span class="token punctuation">(</span>init<span class="token punctuation">,</span> end<span class="token punctuation">,</span> increment<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// result = 1.2</span>
		<span class="token comment" spellcheck="true">// Values outside 0...1 work as well.</span>
		increment <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
		result <span class="token operator">=</span> <span class="token function">ofLerp</span><span class="token punctuation">(</span>init<span class="token punctuation">,</span> end<span class="token punctuation">,</span> increment<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// result = 3</span>
</code></pre>
<p><strong>See also</strong>: float ofClamp(float value, float min, float max)</p>
<p><strong>Parameters:</strong></p>
<p>start The lower bound of the range.</p>
<p>stop The upper bound of the range.</p>
<p>amt The normalized [0, 1] value within the range to return.</p>
<p><strong>Returns</strong>: A float between start and stop.</p>
</div><div class="desc"></div></div><hr></section><section name="ofLerpDegrees" id="ofLerpDegrees" class="mb2"><div class="method mb2"><h3 class="f3 title">ofLerpDegrees(<code class="pink">…</code>)</h3><code><span class="token keyword">float  </span><span class="token function">ofLerpDegrees</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> currentAngle<span class="token punctuation">,</span> <span class="token keyword">float</span> targetAngle<span class="token punctuation">,</span> <span class="token keyword">float</span> pct</code><span class="token punctuation">)</span></code><div class="short"><p>Linearly interpolate a value between two angles in degrees.</p>
<p>Calculates a number between two numbers [start, stop) at a specific
increment (amt). This does constrain the result into a single rotation,
but does not clamp the values</p>
<p><strong>Parameters:</strong></p>
<p>currentAngle The lower bound of the range in degrees.</p>
<p>targetAngle The upper bound of the range in degrees.</p>
<p>pct An amount between [0.0, 1.0] within the range to return.</p>
<p><strong>Returns</strong>: An angle in degrees between currentAngle and targetAngle.</p>
</div><div class="desc"></div></div><hr></section><section name="ofLerpRadians" id="ofLerpRadians" class="mb2"><div class="method mb2"><h3 class="f3 title">ofLerpRadians(<code class="pink">…</code>)</h3><code><span class="token keyword">float  </span><span class="token function">ofLerpRadians</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> currentAngle<span class="token punctuation">,</span> <span class="token keyword">float</span> targetAngle<span class="token punctuation">,</span> <span class="token keyword">float</span> pct</code><span class="token punctuation">)</span></code><div class="short"><p>Linearly interpolate a value between two angles in radians.</p>
<p>Calculates a number between two numbers (start, stop) at a specific
increment (amt).  This does constrain the result into a single rotation, but
does not clamp the values</p>
<p><strong>Parameters:</strong></p>
<p>currentAngle The lower bound of the range in radians.</p>
<p>targetAngle The upper bound of the range in radians.</p>
<p>pct An amount between [0.0, 1.0] within the range to return.</p>
<p><strong>Returns</strong>: An angle in radians between currentAngle and targetAngle.</p>
</div><div class="desc"></div></div><hr></section><section name="ofLineSegmentIntersection" id="ofLineSegmentIntersection" class="mb2"><div class="method mb2"><h3 class="f3 title">ofLineSegmentIntersection(<code class="pink">…</code>)</h3><code><span class="token keyword">bool  </span><span class="token function">ofLineSegmentIntersection</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> vectype <span class="token operator">&</span>line1Start<span class="token punctuation">,</span> <span class="token keyword">const</span> vectype <span class="token operator">&</span>line1End<span class="token punctuation">,</span> <span class="token keyword">const</span> vectype <span class="token operator">&</span>line2Start<span class="token punctuation">,</span> <span class="token keyword">const</span> vectype <span class="token operator">&</span>line2End<span class="token punctuation">,</span> vectype <span class="token operator">&</span>intersection</code><span class="token punctuation">)</span></code><div class="short"><p>Determine the intersection between two lines.</p>
<p><strong>Parameters:</strong></p>
<p>line1Start Starting point for first line.</p>
<p>line1End End point for first line.</p>
<p>line2Start Starting point for second line.</p>
<p>line2End End point for second line.</p>
<p>intersection glm::vec3 reference in which to store the computed intersection point.</p>
<p><strong>Returns</strong>: True if the lines intersect.</p>
</div><div class="desc"></div></div><hr></section><section name="ofMap" id="ofMap" class="mb2"><div class="method mb2"><h3 class="f3 title">ofMap(<code class="pink">…</code>)</h3><code><span class="token keyword">float  </span><span class="token function">ofMap</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> value<span class="token punctuation">,</span> <span class="token keyword">float</span> inputMin<span class="token punctuation">,</span> <span class="token keyword">float</span> inputMax<span class="token punctuation">,</span> <span class="token keyword">float</span> outputMin<span class="token punctuation">,</span> <span class="token keyword">float</span> outputMax<span class="token punctuation">,</span> <span class="token keyword">bool</span> clamp<span class="token operator">=</span><span class="token boolean">false</span></code><span class="token punctuation">)</span></code><div class="short"><p>Given a value and an input range, map the value to an output range.</p>
<p>ofMap linearly maps the given value to a new value given an input and output
range.  Thus if value is 50% of the way between inputMin and inputMax, the
output value will be 50% of the way between outpuMin and outputMax. For
an input value <em>outside</em> of the intputMin and inputMax range, negative
percentages and percentages greater than 100% will be used.  For example, if
the input value is 150 and the input range is 0 - 100 and the output range
0 - 1000, the output value will be 1500 or 150% of the total range.  The
user can avoid mapping outside of the input range by clamping the output
value.  Clamping is disabled by default and ensures that the output value
always stays in the range [outputMin, outputMax).</p>
<p>Example:</p>
<pre><code>		<span class="token keyword">float</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
		<span class="token keyword">float</span> newx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token comment" spellcheck="true">// 0 &amplt;= x &amplt; 10</span>
		newx <span class="token operator">=</span> <span class="token function">ofMap</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// newx = 21.5 a value [21, 22).</span>
</code></pre>
<p><strong>Parameters:</strong></p>
<p>value The number to be mapped.</p>
<p>inputMin The lower bound of the input range.</p>
<p>inputMax The upper bound of the input range.</p>
<p>outputMin The lower bound of the output range.</p>
<p>outputMax The upper bound of the output range.</p>
<p>clamp True if the value should be clamped to [outputMin, outputMax).
\note If the absolute difference between inputMin and inputMax is less than
FLT_EPSILON, outputMin will be returned to prevent divide by zero
errors.</p>
<p><strong>Returns</strong>: a mapped floating point number.</p>
</div><div class="desc"></div></div><hr></section><section name="ofNextPow2" id="ofNextPow2" class="mb2"><div class="method mb2"><h3 class="f3 title">ofNextPow2(<code class="pink">…</code>)</h3><code><span class="token keyword">int  </span><span class="token function">ofNextPow2</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">int</span> a</code><span class="token punctuation">)</span></code><div class="short"><p>Calculates the next larger power of 2.</p>
<p>If the input is already a power of 2, it will return itself.</p>
<p>Example:</p>
<pre><code><span class="token function">ofNextPow2</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns 64</span>
<span class="token function">ofNextPow2</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns 64</span>
<span class="token function">ofNextPow2</span><span class="token punctuation">(</span><span class="token number">401</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// returns 512</span>
</code></pre>
<p><strong>Parameters:</strong></p>
<p>a The starting point for finding the next power of 2.</p>
<p><strong>Returns</strong>: value^2.</p>
</div><div class="desc"></div></div><hr></section><section name="ofNoise" id="ofNoise" class="mb2"><div class="method mb2"><h3 class="f3 title">ofNoise(<code class="pink">…</code>)</h3><code><span class="token keyword">float  </span><span class="token function">ofNoise</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> glm<span class="token operator">::</span>vec2 <span class="token operator">&</span>p</code><span class="token punctuation">)</span></code><div class="short"><p>Calculates a two dimensional Perlin noise value between 0.0...1.0.</p>
</div><div class="desc"></div></div><hr></section><section name="ofNoise" id="ofNoise" class="mb2"><div class="method mb2"><h3 class="f3 title">ofNoise(<code class="pink">…</code>)</h3><code><span class="token keyword">float  </span><span class="token function">ofNoise</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> glm<span class="token operator">::</span>vec3 <span class="token operator">&</span>p</code><span class="token punctuation">)</span></code><div class="short"><p>Calculates a three dimensional Perlin noise value between 0.0...1.0.</p>
</div><div class="desc"></div></div><hr></section><section name="ofNoise" id="ofNoise" class="mb2"><div class="method mb2"><h3 class="f3 title">ofNoise(<code class="pink">…</code>)</h3><code><span class="token keyword">float  </span><span class="token function">ofNoise</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> glm<span class="token operator">::</span>vec4 <span class="token operator">&</span>p</code><span class="token punctuation">)</span></code><div class="short"><p>Calculates a four dimensional Perlin noise value between 0.0...1.0.</p>
</div><div class="desc"></div></div><hr></section><section name="ofNoise" id="ofNoise" class="mb2"><div class="method mb2"><h3 class="f3 title">ofNoise(<code class="pink">…</code>)</h3><code><span class="token keyword">float  </span><span class="token function">ofNoise</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> x</code><span class="token punctuation">)</span></code><div class="short"><p>Calculates a one dimensional Perlin noise value between 0.0...1.0.</p>
</div><div class="desc"></div></div><hr></section><section name="ofNoise" id="ofNoise" class="mb2"><div class="method mb2"><h3 class="f3 title">ofNoise(<code class="pink">…</code>)</h3><code><span class="token keyword">float  </span><span class="token function">ofNoise</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> x<span class="token punctuation">,</span> <span class="token keyword">float</span> y</code><span class="token punctuation">)</span></code><div class="short"><p>Calculates a two dimensional Perlin noise value between 0.0...1.0.</p>
</div><div class="desc"></div></div><hr></section><section name="ofNoise" id="ofNoise" class="mb2"><div class="method mb2"><h3 class="f3 title">ofNoise(<code class="pink">…</code>)</h3><code><span class="token keyword">float  </span><span class="token function">ofNoise</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> x<span class="token punctuation">,</span> <span class="token keyword">float</span> y<span class="token punctuation">,</span> <span class="token keyword">float</span> z</code><span class="token punctuation">)</span></code><div class="short"><p>Calculates a three dimensional Perlin noise value between 0.0...1.0.</p>
</div><div class="desc"></div></div><hr></section><section name="ofNoise" id="ofNoise" class="mb2"><div class="method mb2"><h3 class="f3 title">ofNoise(<code class="pink">…</code>)</h3><code><span class="token keyword">float  </span><span class="token function">ofNoise</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> x<span class="token punctuation">,</span> <span class="token keyword">float</span> y<span class="token punctuation">,</span> <span class="token keyword">float</span> z<span class="token punctuation">,</span> <span class="token keyword">float</span> w</code><span class="token punctuation">)</span></code><div class="short"><p>Calculates a four dimensional Perlin noise value between 0.0...1.0.</p>
</div><div class="desc"></div></div><hr></section><section name="ofNormalize" id="ofNormalize" class="mb2"><div class="method mb2"><h3 class="f3 title">ofNormalize(<code class="pink">…</code>)</h3><code><span class="token keyword">float  </span><span class="token function">ofNormalize</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> value<span class="token punctuation">,</span> <span class="token keyword">float</span> min<span class="token punctuation">,</span> <span class="token keyword">float</span> max</code><span class="token punctuation">)</span></code><div class="short"><p>Given a value and an input range, map the value to be within 0 and 1.</p>
<p>Often, you'll need to work with percentages or other methods that expect a
value between 0 and 1.  This function will take a minimum and maximum and
then finds where within that range a value sits.  If the value is outside
the range, it will be mapped to 0 or 1.</p>
<p><strong>Parameters:</strong></p>
<p>value The number to be normalized.</p>
<p>min The lower bound of the range.</p>
<p>max The upper bound of the range.</p>
<p><strong>Returns</strong>: A float between 0 and 1.</p>
</div><div class="desc"></div></div><hr></section><section name="ofRadToDeg" id="ofRadToDeg" class="mb2"><div class="method mb2"><h3 class="f3 title">ofRadToDeg(<code class="pink">…</code>)</h3><code><span class="token keyword">float  </span><span class="token function">ofRadToDeg</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> radians</code><span class="token punctuation">)</span></code><div class="short"><p>Convert radians to degrees.</p>
<p>Example:</p>
<pre><code>		<span class="token keyword">float</span> result <span class="token operator">=</span> <span class="token function">ofRadToDeg</span><span class="token punctuation">(</span>PI<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// The result will be 90.</span>
</code></pre>
<p><strong>Parameters:</strong></p>
<p>radians An angle in radians.</p>
<p><strong>Returns</strong>: the angle in degrees.</p>
</div><div class="desc"></div></div><hr></section><section name="ofRandom" id="ofRandom" class="mb2"><div class="method mb2"><h3 class="f3 title">ofRandom(<code class="pink">…</code>)</h3><code><span class="token keyword">float  </span><span class="token function">ofRandom</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> max</code><span class="token punctuation">)</span></code><div class="short"><p>Get a random floating point number between 0 and max.</p>
<p>A random number in the range [0, max) will be returned.</p>
<p>Example:
~~~~~{.cpp}
// Return a random floating point number between 0 and 20.
float randomNumber = ofRandom(20);</p>
<pre><code>

<span class="token operator">*</span><span class="token operator">*</span>Warning<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">:</span> ofRandom wraps C<span class="token operator">++</span>'s `<span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span>` which is <span class="token operator">not</span> reentrant <span class="token operator">or</span> thread safe<span class="token punctuation">.</span>


<span class="token operator">*</span><span class="token operator">*</span>Parameters<span class="token operator">:</span><span class="token operator">*</span><span class="token operator">*</span>

max The maximum value of the random number<span class="token punctuation">.</span>





</code></pre>
</div><div class="desc"></div></div><hr></section><section name="ofRandom" id="ofRandom" class="mb2"><div class="method mb2"><h3 class="f3 title">ofRandom(<code class="pink">…</code>)</h3><code><span class="token keyword">float  </span><span class="token function">ofRandom</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> val0<span class="token punctuation">,</span> <span class="token keyword">float</span> val1</code><span class="token punctuation">)</span></code><div class="short"><p>Get a random number between two values.</p>
<p>A random number in the range [min, max) will be returned.</p>
<p>Example:
~~~~~{.cpp}
// Return a random floating point number between -30 and 20.
float randomNumber = ofRandom(-30, 20);</p>
<pre><code>

<span class="token operator">*</span><span class="token operator">*</span>Warning<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">:</span> ofRandom wraps `<span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span>` which is <span class="token operator">not</span> reentrant <span class="token operator">or</span> thread safe<span class="token punctuation">.</span>


<span class="token operator">*</span><span class="token operator">*</span>Parameters<span class="token operator">:</span><span class="token operator">*</span><span class="token operator">*</span>

val0 the minimum value of the random number<span class="token punctuation">.</span>

val1 The maximum value of the random number<span class="token punctuation">.</span>

<span class="token operator">*</span><span class="token operator">*</span>Returns<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">:</span> A random floating point number between val0 <span class="token operator">and</span> val1<span class="token punctuation">.</span>





</code></pre>
</div><div class="desc"></div></div><hr></section><section name="ofRandomHeight" id="ofRandomHeight" class="mb2"><div class="method mb2"><h3 class="f3 title">ofRandomHeight(<!---->)</h3><code><span class="token keyword">float  </span><span class="token function">ofRandomHeight</span><span class="token punctuation">(</span><!----><span class="token punctuation">)</span></code><div class="short"><p>Get a random floating point number between 0 and the screen height.</p>
<p>A random number in the range [0, ofGetHeight()) will be returned.</p>
<p><strong>Warning</strong>: ofRandom wraps <code><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code> which is not reentrant or thread safe.</p>
<p><strong>Returns</strong>: a random number between 0 and ofGetHeight().</p>
</div><div class="desc"></div></div><hr></section><section name="ofRandomWidth" id="ofRandomWidth" class="mb2"><div class="method mb2"><h3 class="f3 title">ofRandomWidth(<!---->)</h3><code><span class="token keyword">float  </span><span class="token function">ofRandomWidth</span><span class="token punctuation">(</span><!----><span class="token punctuation">)</span></code><div class="short"><p>Get a random floating point number between 0 and the screen width.</p>
<p>A random number in the range [0, ofGetWidth()) will be returned.</p>
<p><strong>Warning</strong>: ofRandom wraps <code><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code> which is not reentrant or thread safe.</p>
<p><strong>Returns</strong>: a random number between 0 and ofGetWidth().</p>
</div><div class="desc"></div></div><hr></section><section name="ofRandomf" id="ofRandomf" class="mb2"><div class="method mb2"><h3 class="f3 title">ofRandomf(<!---->)</h3><code><span class="token keyword">float  </span><span class="token function">ofRandomf</span><span class="token punctuation">(</span><!----><span class="token punctuation">)</span></code><div class="short"><p>Get a random floating point number.</p>
<p><strong>Warning</strong>: ofRandom wraps <code><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code> which is not reentrant or thread safe.</p>
<p><strong>Returns</strong>: A random floating point number between -1 and 1.</p>
</div><div class="desc"></div></div><hr></section><section name="ofRandomuf" id="ofRandomuf" class="mb2"><div class="method mb2"><h3 class="f3 title">ofRandomuf(<!---->)</h3><code><span class="token keyword">float  </span><span class="token function">ofRandomuf</span><span class="token punctuation">(</span><!----><span class="token punctuation">)</span></code><div class="short"><p>Get a random unsigned floating point number.</p>
<p><strong>Warning</strong>: ofRandom wraps <code><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code> which is not reentrant or thread safe.</p>
<p><strong>Returns</strong>: A random floating point number between 0 and 1.</p>
</div><div class="desc"></div></div><hr></section><section name="ofSeedRandom" id="ofSeedRandom" class="mb2"><div class="method mb2"><h3 class="f3 title">ofSeedRandom(<!---->)</h3><code><span class="token keyword">void  </span><span class="token function">ofSeedRandom</span><span class="token punctuation">(</span><!----><span class="token punctuation">)</span></code><div class="short"><p>Seed the seeds the random number generator with a unique value.</p>
<p>This seeds the random number generator with an acceptably random value,
generated from clock time and the PID.</p>
</div><div class="desc"></div></div><hr></section><section name="ofSeedRandom" id="ofSeedRandom" class="mb2"><div class="method mb2"><h3 class="f3 title">ofSeedRandom(<code class="pink">…</code>)</h3><code><span class="token keyword">void  </span><span class="token function">ofSeedRandom</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">int</span> val</code><span class="token punctuation">)</span></code><div class="short"><p>Seed the random number generator.</p>
<p>If the user would like to repeat the same random sequence, a known random
seed can be used to initialize the random number generator during app
setup.  This can be useful for debugging and testing.</p>
<p><strong>Parameters:</strong></p>
<p>val The value with which to seed the generator.</p>
</div><div class="desc"></div></div><hr></section><section name="ofSign" id="ofSign" class="mb2"><div class="method mb2"><h3 class="f3 title">ofSign(<code class="pink">…</code>)</h3><code><span class="token keyword">int  </span><span class="token function">ofSign</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> n</code><span class="token punctuation">)</span></code><div class="short"><p>Returns the sign of a number.</p>
<p><strong>Returns</strong>: int -1 if n is negative, 1 if n is positive, and 0 is n == 0;</p>
</div><div class="desc"></div></div><hr></section><section name="ofSignedNoise" id="ofSignedNoise" class="mb2"><div class="method mb2"><h3 class="f3 title">ofSignedNoise(<code class="pink">…</code>)</h3><code><span class="token keyword">float  </span><span class="token function">ofSignedNoise</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> glm<span class="token operator">::</span>vec2 <span class="token operator">&</span>p</code><span class="token punctuation">)</span></code><div class="short"><p>Calculates a two dimensional Perlin noise value between -1.0...1.0.</p>
</div><div class="desc"></div></div><hr></section><section name="ofSignedNoise" id="ofSignedNoise" class="mb2"><div class="method mb2"><h3 class="f3 title">ofSignedNoise(<code class="pink">…</code>)</h3><code><span class="token keyword">float  </span><span class="token function">ofSignedNoise</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> glm<span class="token operator">::</span>vec3 <span class="token operator">&</span>p</code><span class="token punctuation">)</span></code><div class="short"><p>Calculates a three dimensional Perlin noise value between -1.0...1.0.</p>
</div><div class="desc"></div></div><hr></section><section name="ofSignedNoise" id="ofSignedNoise" class="mb2"><div class="method mb2"><h3 class="f3 title">ofSignedNoise(<code class="pink">…</code>)</h3><code><span class="token keyword">float  </span><span class="token function">ofSignedNoise</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> glm<span class="token operator">::</span>vec4 <span class="token operator">&</span>p</code><span class="token punctuation">)</span></code><div class="short"><p>Calculates a four dimensional Perlin noise value between -1.0...1.0.</p>
</div><div class="desc"></div></div><hr></section><section name="ofSignedNoise" id="ofSignedNoise" class="mb2"><div class="method mb2"><h3 class="f3 title">ofSignedNoise(<code class="pink">…</code>)</h3><code><span class="token keyword">float  </span><span class="token function">ofSignedNoise</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> x</code><span class="token punctuation">)</span></code><div class="short"><p>Calculates a one dimensional Perlin noise value between -1.0...1.0.</p>
</div><div class="desc"></div></div><hr></section><section name="ofSignedNoise" id="ofSignedNoise" class="mb2"><div class="method mb2"><h3 class="f3 title">ofSignedNoise(<code class="pink">…</code>)</h3><code><span class="token keyword">float  </span><span class="token function">ofSignedNoise</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> x<span class="token punctuation">,</span> <span class="token keyword">float</span> y</code><span class="token punctuation">)</span></code><div class="short"><p>Calculates a two dimensional Perlin noise value between -1.0...1.0.</p>
</div><div class="desc"></div></div><hr></section><section name="ofSignedNoise" id="ofSignedNoise" class="mb2"><div class="method mb2"><h3 class="f3 title">ofSignedNoise(<code class="pink">…</code>)</h3><code><span class="token keyword">float  </span><span class="token function">ofSignedNoise</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> x<span class="token punctuation">,</span> <span class="token keyword">float</span> y<span class="token punctuation">,</span> <span class="token keyword">float</span> z</code><span class="token punctuation">)</span></code><div class="short"><p>Calculates a three dimensional Perlin noise value between -1.0...1.0.</p>
</div><div class="desc"></div></div><hr></section><section name="ofSignedNoise" id="ofSignedNoise" class="mb2"><div class="method mb2"><h3 class="f3 title">ofSignedNoise(<code class="pink">…</code>)</h3><code><span class="token keyword">float  </span><span class="token function">ofSignedNoise</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> x<span class="token punctuation">,</span> <span class="token keyword">float</span> y<span class="token punctuation">,</span> <span class="token keyword">float</span> z<span class="token punctuation">,</span> <span class="token keyword">float</span> w</code><span class="token punctuation">)</span></code><div class="short"><p>Calculates a four dimensional Perlin noise value between -1.0...1.0.</p>
</div><div class="desc"></div></div><hr></section><section name="ofWrap" id="ofWrap" class="mb2"><div class="method mb2"><h3 class="f3 title">ofWrap(<code class="pink">…</code>)</h3><code><span class="token keyword">float  </span><span class="token function">ofWrap</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> value<span class="token punctuation">,</span> <span class="token keyword">float</span> from<span class="token punctuation">,</span> <span class="token keyword">float</span> to</code><span class="token punctuation">)</span></code><div class="short"><p>Find a value within a given range, wrapping the value if it overflows.</p>
<p>If a value is between from and to, return that value.
If a value is NOT within that range, wrap it.</p>
<p>Example:</p>
<pre><code>		<span class="token function">ofWrap</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Returns 5.</span>
		<span class="token function">ofWrap</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Also returns 5.</span>
		<span class="token function">ofWrap</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Also returns 5.</span>
</code></pre>
<p><strong>Parameters:</strong></p>
<p>value The value to map.</p>
<p>from The lower bound of the range.</p>
<p><strong>Returns</strong>: to The upper bound of the range.</p>
</div><div class="desc"></div></div><hr></section><section name="ofWrapDegrees" id="ofWrapDegrees" class="mb2"><div class="method mb2"><h3 class="f3 title">ofWrapDegrees(<code class="pink">…</code>)</h3><code><span class="token keyword">float  </span><span class="token function">ofWrapDegrees</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> angle<span class="token punctuation">,</span> <span class="token keyword">float</span> from<span class="token punctuation">,</span> <span class="token keyword">float</span> to</code><span class="token punctuation">)</span></code><div class="short"></div><div class="desc"></div></div><hr></section><section name="ofWrapRadians" id="ofWrapRadians" class="mb2"><div class="method mb2"><h3 class="f3 title">ofWrapRadians(<code class="pink">…</code>)</h3><code><span class="token keyword">float  </span><span class="token function">ofWrapRadians</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">float</span> angle<span class="token punctuation">,</span> <span class="token keyword">float</span> from<span class="token punctuation">,</span> <span class="token keyword">float</span> to</code><span class="token punctuation">)</span></code><div class="short"></div><div class="desc"></div></div><hr></section></div></div></div></div><div id="side-menu" class="markdown"><!----><div id="methods-list"><h4>Methods</h4><div class="anchor"><code><a href="#ofAngleDifferenceDegrees" class="pink">ofAngleDifferenceDegrees</a></code></div><div class="anchor"><code><a href="#ofAngleDifferenceRadians" class="pink">ofAngleDifferenceRadians</a></code></div><div class="anchor"><code><a href="#ofBezierPoint" class="pink">ofBezierPoint</a></code></div><div class="anchor"><code><a href="#ofBezierTangent" class="pink">ofBezierTangent</a></code></div><div class="anchor"><code><a href="#ofClamp" class="pink">ofClamp</a></code></div><div class="anchor"><code><a href="#ofCurvePoint" class="pink">ofCurvePoint</a></code></div><div class="anchor"><code><a href="#ofCurveTangent" class="pink">ofCurveTangent</a></code></div><div class="anchor"><code><a href="#ofDegToRad" class="pink">ofDegToRad</a></code></div><div class="anchor"><code><a href="#ofDist" class="pink">ofDist</a></code></div><div class="anchor"><code><a href="#ofDist" class="pink">ofDist</a></code></div><div class="anchor"><code><a href="#ofDistSquared" class="pink">ofDistSquared</a></code></div><div class="anchor"><code><a href="#ofDistSquared" class="pink">ofDistSquared</a></code></div><div class="anchor"><code><a href="#ofInRange" class="pink">ofInRange</a></code></div><div class="anchor"><code><a href="#ofInterpolateCatmullRom">ofInterpolateCatmullRom</a></code></div><div class="anchor"><code><a href="#ofInterpolateCosine" class="pink">ofInterpolateCosine</a></code></div><div class="anchor"><code><a href="#ofInterpolateCubic">ofInterpolateCubic</a></code></div><div class="anchor"><code><a href="#ofInterpolateHermite">ofInterpolateHermite</a></code></div><div class="anchor"><code><a href="#ofInterpolateHermite">ofInterpolateHermite</a></code></div><div class="anchor"><code><a href="#ofLerp" class="pink">ofLerp</a></code></div><div class="anchor"><code><a href="#ofLerpDegrees" class="pink">ofLerpDegrees</a></code></div><div class="anchor"><code><a href="#ofLerpRadians" class="pink">ofLerpRadians</a></code></div><div class="anchor"><code><a href="#ofLineSegmentIntersection" class="pink">ofLineSegmentIntersection</a></code></div><div class="anchor"><code><a href="#ofMap" class="pink">ofMap</a></code></div><div class="anchor"><code><a href="#ofNextPow2" class="pink">ofNextPow2</a></code></div><div class="anchor"><code><a href="#ofNoise" class="pink">ofNoise</a></code></div><div class="anchor"><code><a href="#ofNoise" class="pink">ofNoise</a></code></div><div class="anchor"><code><a href="#ofNoise" class="pink">ofNoise</a></code></div><div class="anchor"><code><a href="#ofNoise" class="pink">ofNoise</a></code></div><div class="anchor"><code><a href="#ofNoise" class="pink">ofNoise</a></code></div><div class="anchor"><code><a href="#ofNoise" class="pink">ofNoise</a></code></div><div class="anchor"><code><a href="#ofNoise" class="pink">ofNoise</a></code></div><div class="anchor"><code><a href="#ofNormalize" class="pink">ofNormalize</a></code></div><div class="anchor"><code><a href="#ofRadToDeg" class="pink">ofRadToDeg</a></code></div><div class="anchor"><code><a href="#ofRandom" class="pink">ofRandom</a></code></div><div class="anchor"><code><a href="#ofRandom" class="pink">ofRandom</a></code></div><div class="anchor"><code><a href="#ofRandomHeight" class="pink">ofRandomHeight</a></code></div><div class="anchor"><code><a href="#ofRandomWidth" class="pink">ofRandomWidth</a></code></div><div class="anchor"><code><a href="#ofRandomf" class="pink">ofRandomf</a></code></div><div class="anchor"><code><a href="#ofRandomuf" class="pink">ofRandomuf</a></code></div><div class="anchor"><code><a href="#ofSeedRandom" class="pink">ofSeedRandom</a></code></div><div class="anchor"><code><a href="#ofSeedRandom" class="pink">ofSeedRandom</a></code></div><div class="anchor"><code><a href="#ofSign" class="pink">ofSign</a></code></div><div class="anchor"><code><a href="#ofSignedNoise" class="pink">ofSignedNoise</a></code></div><div class="anchor"><code><a href="#ofSignedNoise" class="pink">ofSignedNoise</a></code></div><div class="anchor"><code><a href="#ofSignedNoise" class="pink">ofSignedNoise</a></code></div><div class="anchor"><code><a href="#ofSignedNoise" class="pink">ofSignedNoise</a></code></div><div class="anchor"><code><a href="#ofSignedNoise" class="pink">ofSignedNoise</a></code></div><div class="anchor"><code><a href="#ofSignedNoise" class="pink">ofSignedNoise</a></code></div><div class="anchor"><code><a href="#ofSignedNoise" class="pink">ofSignedNoise</a></code></div><div class="anchor"><code><a href="#ofWrap" class="pink">ofWrap</a></code></div><div class="anchor"><code><a href="#ofWrapDegrees">ofWrapDegrees</a></code></div><div class="anchor"><code><a href="#ofWrapRadians">ofWrapRadians</a></code></div></div><div id="see-also" filename="ofMath_functions.markdown" absolute="/Users/gilbertsinnott/Code/openFrameworks/ofSite/documentation/math/ofMath_functions.markdown" route="/documentation/math/ofMath_functions.markdown" dir="../ofSite/documentation/math" ext="markdown" type="page" parent="2123" breadcrumbs="2123,1718" siblings="" translations="[object Object]" class="see-also"><h4>See also</h4><div class="also"><a href="/documentation/math/ofMath"><span class="origin">documentation</span><span class="name">ofMath</span></a></div></div></div></div></div><textarea rows="0" class="markdown-editor" style="display:none">#functions


&lt;!--
_visible: True_
_advanced: False_
-->

##Description






&lt;!----------------------------------------------------------------------------->

###float ofAngleDifferenceDegrees(currentAngle, targetAngle)

&lt;!--
_syntax: ofAngleDifferenceDegrees(currentAngle, targetAngle)_
_name: ofAngleDifferenceDegrees_
_returns: float_
_returns_description: _
_parameters: float currentAngle, float targetAngle_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Calculates the difference between two angles in degrees.

This will calculate the actual difference, taking into account multiple
revolutions. For example:

~~~~{.cpp}
		ofAngleDifferenceDegrees(0, 90); // Returns 90.
		ofAngleDifferenceDegrees(0, 450); // Also returns 90.
~~~~


**Parameters:**

currentAngle The current angle in degrees.

targetAngle the angle to be compared to in degrees.

**Returns**: The difference between two angles in degrees.





_description: _







&lt;!----------------------------------------------------------------------------->

###float ofAngleDifferenceRadians(currentAngle, targetAngle)

&lt;!--
_syntax: ofAngleDifferenceRadians(currentAngle, targetAngle)_
_name: ofAngleDifferenceRadians_
_returns: float_
_returns_description: _
_parameters: float currentAngle, float targetAngle_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Calculates the difference between two angles in radians.

This will calculate the actual difference, taking into account multiple
revolutions. For example:

~~~~{.cpp}
		ofAngleDifferenceRadians(0, PI); // Returns -PI.
		ofAngleDifferenceRadians(0, 3*PI); // Also returns -PI.
~~~~


**Parameters:**

currentAngle The current angle in radians.

targetAngle the angle to be compared to in radians.

**Returns**: The difference between two angles in radians.





_description: _







&lt;!----------------------------------------------------------------------------->

###vectype ofBezierPoint(&a, &b, &c, &d, t)

&lt;!--
_syntax: ofBezierPoint(&a, &b, &c, &d, t)_
_name: ofBezierPoint_
_returns: vectype_
_returns_description: _
_parameters: const vectype &a, const vectype &b, const vectype &c, const vectype &d, float t_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Given the four points that determine a bezier curve, return an interpolated point on the curve.

**Parameters:**

a The beginning point of the curve.

b The first control point.

c The second control point.

d The end point of the curve.

t an offset along the curve, normalized between 0 and 1.

**Returns**: A glm::vec3 on the curve.





_description: _







&lt;!----------------------------------------------------------------------------->

###vectype ofBezierTangent(&a, &b, &c, &d, t)

&lt;!--
_syntax: ofBezierTangent(&a, &b, &c, &d, t)_
_name: ofBezierTangent_
_returns: vectype_
_returns_description: _
_parameters: const vectype &a, const vectype &b, const vectype &c, const vectype &d, float t_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Given the four points that determine a bezier curve and an offset along the curve, return an tangent vector to a point on the curve.
Currently this is not a normalized point, and will need to be normalized.

**Parameters:**

a The beginning point of the curve.

b The first control point.

c The second control point.

d The end point of the curve.

t an offset along the curve, normalized between 0 and 1.

**Returns**: A glm::vec3 on the curve.





_description: _







&lt;!----------------------------------------------------------------------------->

###float ofClamp(value,min,max) 

&lt;!--
_syntax: ofClamp(value,min,max) _
_name: ofClamp_
_returns: float_
_returns_description: _
_parameters: float value, float min, float max_
_version_started: 006_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Clamp a value between min and max.

Restricts a value to be within a specified range defined by values min and
max. If the value is min &lt;= value &lt;= max, returns value.  If the value is
greater than max, return max; if the value is less than min, return min.
Otherwise, return the value unchanged.

~~~~{.cpp}
		float val = 10;
		float newVal = 0;
		newval = ofClamp(val, 30, 40); // newval = 30
		newval = ofClamp(val, 0, 5);   // newval = 5
		newval = ofClamp(val, 0, 20);  // newval = 10
~~~~


**Parameters:**

value The number to be clamped.

min The lower bound of the range.

max The upper bound of the range.

**Returns**: a floating point number in the range [min, max].





_description: _







&lt;!----------------------------------------------------------------------------->

###vectype ofCurvePoint(&a, &b, &c, &d, t)

&lt;!--
_syntax: ofCurvePoint(&a, &b, &c, &d, t)_
_name: ofCurvePoint_
_returns: vectype_
_returns_description: _
_parameters: const vectype &a, const vectype &b, const vectype &c, const vectype &d, float t_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Given the four points that determine a Catmull Rom curve, return an interpolated point on the curve.

**Parameters:**

a The first control point.

b The beginning point of the curve.

c The end point of the curve.

d The second control point.

t an offset along the curve, normalized between 0 and 1.

**Returns**: A glm::vec3 on the curve.





_description: _







&lt;!----------------------------------------------------------------------------->

###vectype ofCurveTangent(&a, &b, &c, &d, t)

&lt;!--
_syntax: ofCurveTangent(&a, &b, &c, &d, t)_
_name: ofCurveTangent_
_returns: vectype_
_returns_description: _
_parameters: const vectype &a, const vectype &b, const vectype &c, const vectype &d, float t_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Return a tangent point for an offset along a Catmull Rom curve.

**Parameters:**

a The first control point.

b The beginning point of the curve.

c The end point of the curve.

d The second control point.

t an offset along the curve, normalized between 0 and 1.

**Returns**: A glm::vec3 on the curve.





_description: _







&lt;!----------------------------------------------------------------------------->

###float ofDegToRad(degrees)

&lt;!--
_syntax: ofDegToRad(degrees)_
_name: ofDegToRad_
_returns: float_
_returns_description: _
_parameters: float degrees_
_version_started: 006_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Convert degrees to radians.

Example:
~~~~{.cpp}
		float result = ofDegToRad(90); // The result will be PI/2.
~~~~


**Parameters:**

degrees An angle in degrees.

**Returns**: the angle in radians.





_description: _







&lt;!----------------------------------------------------------------------------->

###float ofDist(x1, y1, x2, y2)

&lt;!--
_syntax: ofDist(x1, y1, x2, y2)_
_name: ofDist_
_returns: float_
_returns_description: _
_parameters: float x1, float y1, float x2, float y2_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Calculates the 2D distance between two points.

Uses the [Pythagorean theorem](http://en.wikipedia.org/wiki/Pythagorean_theorem).


**Parameters:**

x1 X position of first point.

y1 Y position of first point.

x2 X position of second point.

y2 Y position of second point.

**Returns**: float Distance between points.





_description: _







&lt;!----------------------------------------------------------------------------->

###float ofDist(x1, y1, z1, x2, y2, z2)

&lt;!--
_syntax: ofDist(x1, y1, z1, x2, y2, z2)_
_name: ofDist_
_returns: float_
_returns_description: _
_parameters: float x1, float y1, float z1, float x2, float y2, float z2_
_version_started: 006_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Calculates the 3D distance between two points.

Uses the [Pythagorean theorem](http://en.wikipedia.org/wiki/Pythagorean_theorem).


**Parameters:**

x1 X position of first point.

y1 Y position of first point.

z1 Z position of first point.

x2 X position of second point.

y2 Y position of second point.

z2 Z position of second point.

**Returns**: float Distance between points.





_description: _







&lt;!----------------------------------------------------------------------------->

###float ofDistSquared(x1, y1, x2, y2)

&lt;!--
_syntax: ofDistSquared(x1, y1, x2, y2)_
_name: ofDistSquared_
_returns: float_
_returns_description: _
_parameters: float x1, float y1, float x2, float y2_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Calculates the squared 2D distance between two points.

Same as ofDist() but doesn't take the square root sqrt() of the result,
which is a faster operation if you need to calculate and compare multiple
distances.


**Parameters:**

x1 X position of first point.

y1 Y position of first point.

x2 X position of second point.

y2 Y position of second point.

**Returns**: distance-squared between two points.





_description: _







&lt;!----------------------------------------------------------------------------->

###float ofDistSquared(x1, y1, z1, x2, y2, z2)

&lt;!--
_syntax: ofDistSquared(x1, y1, z1, x2, y2, z2)_
_name: ofDistSquared_
_returns: float_
_returns_description: _
_parameters: float x1, float y1, float z1, float x2, float y2, float z2_
_version_started: 006_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Calculates the squared 3D distance between two points.

Same as ofDist() but doesn't take the square root sqrt() of the result,
which is a faster operation if you need to calculate and compare multiple
distances.


**Parameters:**

x1 X position of first point.

y1 Y position of first point.

z1 Z position of first point.

x2 X position of second point.

y2 Y position of second point.

z2 Z position of second point.

**Returns**: distance-squared between two points.





_description: _







&lt;!----------------------------------------------------------------------------->

###bool ofInRange(t,min,max)

&lt;!--
_syntax: ofInRange(t,min,max)_
_name: ofInRange_
_returns: bool_
_returns_description: _
_parameters: float t, float min, float max_
_version_started: 006_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Determine if a number is inside of a giv(float)(en range.

**Parameters:**

t The value to test.

min The lower bound of the range.

max The upper bound of the range.

**Returns**: true if the number t is the range of [min, max].





_description: _







&lt;!----------------------------------------------------------------------------->

###Type ofInterpolateCatmullRom(&y0, &y1, &y2, &y3, pct)

&lt;!--
_syntax: ofInterpolateCatmullRom(&y0, &y1, &y2, &y3, pct)_
_name: ofInterpolateCatmullRom_
_returns: Type_
_returns_description: _
_parameters: const Type &y0, const Type &y1, const Type &y2, const Type &y3, float pct_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

###Type ofInterpolateCosine(&y1, &y2, pct)

&lt;!--
_syntax: ofInterpolateCosine(&y1, &y2, pct)_
_name: ofInterpolateCosine_
_returns: Type_
_returns_description: _
_parameters: const Type &y1, const Type &y2, float pct_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

\}





_description: _







&lt;!----------------------------------------------------------------------------->

###Type ofInterpolateCubic(&y0, &y1, &y2, &y3, pct)

&lt;!--
_syntax: ofInterpolateCubic(&y0, &y1, &y2, &y3, pct)_
_name: ofInterpolateCubic_
_returns: Type_
_returns_description: _
_parameters: const Type &y0, const Type &y1, const Type &y2, const Type &y3, float pct_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

###Type ofInterpolateHermite(&y0, &y1, &y2, &y3, pct)

&lt;!--
_syntax: ofInterpolateHermite(&y0, &y1, &y2, &y3, pct)_
_name: ofInterpolateHermite_
_returns: Type_
_returns_description: _
_parameters: const Type &y0, const Type &y1, const Type &y2, const Type &y3, float pct_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

###Type ofInterpolateHermite(&y0, &y1, &y2, &y3, pct, tension, bias)

&lt;!--
_syntax: ofInterpolateHermite(&y0, &y1, &y2, &y3, pct, tension, bias)_
_name: ofInterpolateHermite_
_returns: Type_
_returns_description: _
_parameters: const Type &y0, const Type &y1, const Type &y2, const Type &y3, float pct, float tension, float bias_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

###typename enable_if&lt;is_floating_point&lt; Type>::value, bool >::type ofIsFloatEqual(&a, &b)

&lt;!--
_syntax: ofIsFloatEqual(&a, &b)_
_name: ofIsFloatEqual_
_returns: typename enable_if&lt;is_floating_point&lt; Type>::value, bool >::type_
_returns_description: _
_parameters: const Type &a, const Type &b_
_version_started: 0.10.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Compare two floating point types for equality.

From C++ FAQ:

Floating point arithmetic is different from real number arithmetic.
Never use `==` to compare two floating point numbers.

This solution is not completely symmetric, meaning it is possible for
`ofIsFloatEqual(x, y) != ofIsFloatEqual(y, x)`. From a practical
standpoint, this does not usually occur when the magnitudes of x and y are
significantly larger than epsilon, but your mileage may vary.


**See also**: https://isocpp.org/wiki/faq/newbie#floating-point-arith

**See also**: https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
\tparam The floating point data type.

**Parameters:**

a The first floating point type variable to compare.

b The second floating point type variable to compare.

**Returns**: True if `std::abs(x - y) &lt;= std::numeric_limits&lt;Type>::epsilon() * std::abs(x)`.





_description: _







&lt;!----------------------------------------------------------------------------->

###float ofLerp(start,stop,amt)

&lt;!--
_syntax: ofLerp(start,stop,amt)_
_name: ofLerp_
_returns: float_
_returns_description: _
_parameters: float start, float stop, float amt_
_version_started: 006_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Linearly interpolate a value within a range.

Calculates a number between two numbers [start, stop] at a specific increment
(amt).  If we want the new number to be between start and stop numbers, amt
needs to be a number between 0 and 1, inclusive.  ofLerp() does not clamp
the values.

~~~~{.cpp}
		float init = 1;
		float end = 2;
		float increment = 0.2;
		float result = ofLerp(init, end, increment); // result = 1.2
		// Values outside 0...1 work as well.
		increment = 2;
		result = ofLerp(init, end, increment); // result = 3
~~~~


**See also**: float ofClamp(float value, float min, float max)

**Parameters:**

start The lower bound of the range.

stop The upper bound of the range.

amt The normalized [0, 1] value within the range to return.

**Returns**: A float between start and stop.





_description: _







&lt;!----------------------------------------------------------------------------->

###float ofLerpDegrees(currentAngle, targetAngle, pct)

&lt;!--
_syntax: ofLerpDegrees(currentAngle, targetAngle, pct)_
_name: ofLerpDegrees_
_returns: float_
_returns_description: _
_parameters: float currentAngle, float targetAngle, float pct_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Linearly interpolate a value between two angles in degrees.

Calculates a number between two numbers [start, stop) at a specific
increment (amt). This does constrain the result into a single rotation,
but does not clamp the values


**Parameters:**

currentAngle The lower bound of the range in degrees.

targetAngle The upper bound of the range in degrees.

pct An amount between [0.0, 1.0] within the range to return.

**Returns**: An angle in degrees between currentAngle and targetAngle.





_description: _







&lt;!----------------------------------------------------------------------------->

###float ofLerpRadians(currentAngle, targetAngle, pct)

&lt;!--
_syntax: ofLerpRadians(currentAngle, targetAngle, pct)_
_name: ofLerpRadians_
_returns: float_
_returns_description: _
_parameters: float currentAngle, float targetAngle, float pct_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Linearly interpolate a value between two angles in radians.

Calculates a number between two numbers (start, stop) at a specific
increment (amt).  This does constrain the result into a single rotation, but
does not clamp the values


**Parameters:**

currentAngle The lower bound of the range in radians.

targetAngle The upper bound of the range in radians.

pct An amount between [0.0, 1.0] within the range to return.

**Returns**: An angle in radians between currentAngle and targetAngle.





_description: _







&lt;!----------------------------------------------------------------------------->

###bool ofLineSegmentIntersection(&line1Start, &line1End, &line2Start, &line2End, &intersection)

&lt;!--
_syntax: ofLineSegmentIntersection(&line1Start, &line1End, &line2Start, &line2End, &intersection)_
_name: ofLineSegmentIntersection_
_returns: bool_
_returns_description: _
_parameters: const vectype &line1Start, const vectype &line1End, const vectype &line2Start, const vectype &line2End, vectype &intersection_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Determine the intersection between two lines.

**Parameters:**

line1Start Starting point for first line.

line1End End point for first line.

line2Start Starting point for second line.

line2End End point for second line.

intersection glm::vec3 reference in which to store the computed intersection point.

**Returns**: True if the lines intersect.





_description: _







&lt;!----------------------------------------------------------------------------->

###float ofMap(value, inputMin, inputMax, outputMin, outputMax, clamp = false)

&lt;!--
_syntax: ofMap(value, inputMin, inputMax, outputMin, outputMax, clamp = false)_
_name: ofMap_
_returns: float_
_returns_description: _
_parameters: float value, float inputMin, float inputMax, float outputMin, float outputMax, bool clamp=false_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Given a value and an input range, map the value to an output range.

ofMap linearly maps the given value to a new value given an input and output
range.  Thus if value is 50% of the way between inputMin and inputMax, the
output value will be 50% of the way between outpuMin and outputMax. For
an input value _outside_ of the intputMin and inputMax range, negative
percentages and percentages greater than 100% will be used.  For example, if
the input value is 150 and the input range is 0 - 100 and the output range
0 - 1000, the output value will be 1500 or 150% of the total range.  The
user can avoid mapping outside of the input range by clamping the output
value.  Clamping is disabled by default and ensures that the output value
always stays in the range [outputMin, outputMax).

Example:
~~~~~{.cpp}
		float x = 5;
		float newx = 0;
		// 0 &lt;= x &lt; 10
		newx = ofMap(x, 0, 10, 21, 22); // newx = 21.5 a value [21, 22).
~~~~~


**Parameters:**

value The number to be mapped.

inputMin The lower bound of the input range.

inputMax The upper bound of the input range.

outputMin The lower bound of the output range.

outputMax The upper bound of the output range.

clamp True if the value should be clamped to [outputMin, outputMax).
\note If the absolute difference between inputMin and inputMax is less than
		  FLT_EPSILON, outputMin will be returned to prevent divide by zero
		  errors.

**Returns**: a mapped floating point number.





_description: _







&lt;!----------------------------------------------------------------------------->

###int ofNextPow2(input)

&lt;!--
_syntax: ofNextPow2(input)_
_name: ofNextPow2_
_returns: int_
_returns_description: _
_parameters: int a_
_version_started: 006_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Calculates the next larger power of 2.

If the input is already a power of 2, it will return itself.

Example:
~~~~{.cpp}
ofNextPow2(50); // returns 64
ofNextPow2(64); // returns 64
ofNextPow2(401); // returns 512
~~~~


**Parameters:**

a The starting point for finding the next power of 2.

**Returns**: value^2.





_description: _







&lt;!----------------------------------------------------------------------------->

###float ofNoise(&p)

&lt;!--
_syntax: ofNoise(&p)_
_name: ofNoise_
_returns: float_
_returns_description: _
_parameters: const glm::vec2 &p_
_version_started: 0.9.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Calculates a two dimensional Perlin noise value between 0.0...1.0.





_description: _







&lt;!----------------------------------------------------------------------------->

###float ofNoise(&p)

&lt;!--
_syntax: ofNoise(&p)_
_name: ofNoise_
_returns: float_
_returns_description: _
_parameters: const glm::vec3 &p_
_version_started: 0.10.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Calculates a three dimensional Perlin noise value between 0.0...1.0.





_description: _







&lt;!----------------------------------------------------------------------------->

###float ofNoise(&p)

&lt;!--
_syntax: ofNoise(&p)_
_name: ofNoise_
_returns: float_
_returns_description: _
_parameters: const glm::vec4 &p_
_version_started: 0.10.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Calculates a four dimensional Perlin noise value between 0.0...1.0.





_description: _







&lt;!----------------------------------------------------------------------------->

###float ofNoise(x)

&lt;!--
_syntax: ofNoise(x)_
_name: ofNoise_
_returns: float_
_returns_description: _
_parameters: float x_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Calculates a one dimensional Perlin noise value between 0.0...1.0.





_description: _







&lt;!----------------------------------------------------------------------------->

###float ofNoise(x, y)

&lt;!--
_syntax: ofNoise(x, y)_
_name: ofNoise_
_returns: float_
_returns_description: _
_parameters: float x, float y_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Calculates a two dimensional Perlin noise value between 0.0...1.0.





_description: _







&lt;!----------------------------------------------------------------------------->

###float ofNoise(x, y, z)

&lt;!--
_syntax: ofNoise(x, y, z)_
_name: ofNoise_
_returns: float_
_returns_description: _
_parameters: float x, float y, float z_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Calculates a three dimensional Perlin noise value between 0.0...1.0.





_description: _







&lt;!----------------------------------------------------------------------------->

###float ofNoise(x, y, z, w)

&lt;!--
_syntax: ofNoise(x, y, z, w)_
_name: ofNoise_
_returns: float_
_returns_description: _
_parameters: float x, float y, float z, float w_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Calculates a four dimensional Perlin noise value between 0.0...1.0.





_description: _







&lt;!----------------------------------------------------------------------------->

###float ofNormalize(float value, float min, float max)

&lt;!--
_syntax: ofNormalize(float value, float min, float max)_
_name: ofNormalize_
_returns: float_
_returns_description: _
_parameters: float value, float min, float max_
_version_started: 006_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Given a value and an input range, map the value to be within 0 and 1.

Often, you'll need to work with percentages or other methods that expect a
value between 0 and 1.  This function will take a minimum and maximum and
then finds where within that range a value sits.  If the value is outside
the range, it will be mapped to 0 or 1.


**Parameters:**

value The number to be normalized.

min The lower bound of the range.

max The upper bound of the range.

**Returns**: A float between 0 and 1.





_description: _







&lt;!----------------------------------------------------------------------------->

###float ofRadToDeg(radians)

&lt;!--
_syntax: ofRadToDeg(radians)_
_name: ofRadToDeg_
_returns: float_
_returns_description: _
_parameters: float radians_
_version_started: 006_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Convert radians to degrees.

Example:
~~~~{.cpp}
		float result = ofRadToDeg(PI/2); // The result will be 90.
~~~~


**Parameters:**

radians An angle in radians.

**Returns**: the angle in degrees.





_description: _







&lt;!----------------------------------------------------------------------------->

###float ofRandom(max)

&lt;!--
_syntax: ofRandom(max)_
_name: ofRandom_
_returns: float_
_returns_description: _
_parameters: float max_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Get a random floating point number between 0 and max.

A random number in the range [0, max) will be returned.

Example:
	~~~~~{.cpp}
// Return a random floating point number between 0 and 20.
float randomNumber = ofRandom(20);
~~~~~


**Warning**: ofRandom wraps C++'s `rand()` which is not reentrant or thread safe.


**Parameters:**

max The maximum value of the random number.





_description: _







&lt;!----------------------------------------------------------------------------->

###float ofRandom(val0,val1)

&lt;!--
_syntax: ofRandom(val0,val1)_
_name: ofRandom_
_returns: float_
_returns_description: _
_parameters: float val0, float val1_
_version_started: 006_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Get a random number between two values.

A random number in the range [min, max) will be returned.

Example:
	~~~~~{.cpp}
// Return a random floating point number between -30 and 20.
float randomNumber = ofRandom(-30, 20);
~~~~~


**Warning**: ofRandom wraps `rand()` which is not reentrant or thread safe.


**Parameters:**

val0 the minimum value of the random number.

val1 The maximum value of the random number.

**Returns**: A random floating point number between val0 and val1.





_description: _







&lt;!----------------------------------------------------------------------------->

###float ofRandomHeight()

&lt;!--
_syntax: ofRandomHeight()_
_name: ofRandomHeight_
_returns: float_
_returns_description: _
_parameters: _
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Get a random floating point number between 0 and the screen height.

A random number in the range [0, ofGetHeight()) will be returned.


**Warning**: ofRandom wraps `rand()` which is not reentrant or thread safe.


**Returns**: a random number between 0 and ofGetHeight().





_description: _







&lt;!----------------------------------------------------------------------------->

###float ofRandomWidth()

&lt;!--
_syntax: ofRandomWidth()_
_name: ofRandomWidth_
_returns: float_
_returns_description: _
_parameters: _
_version_started: 006_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Get a random floating point number between 0 and the screen width.

A random number in the range [0, ofGetWidth()) will be returned.


**Warning**: ofRandom wraps `rand()` which is not reentrant or thread safe.


**Returns**: a random number between 0 and ofGetWidth().





_description: _







&lt;!----------------------------------------------------------------------------->

###float ofRandomf()

&lt;!--
_syntax: ofRandomf()_
_name: ofRandomf_
_returns: float_
_returns_description: _
_parameters: _
_version_started: 006_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Get a random floating point number.


**Warning**: ofRandom wraps `rand()` which is not reentrant or thread safe.


**Returns**: A random floating point number between -1 and 1.





_description: _







&lt;!----------------------------------------------------------------------------->

###float ofRandomuf()

&lt;!--
_syntax: ofRandomuf()_
_name: ofRandomuf_
_returns: float_
_returns_description: _
_parameters: _
_version_started: 006_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Get a random unsigned floating point number.


**Warning**: ofRandom wraps `rand()` which is not reentrant or thread safe.


**Returns**: A random floating point number between 0 and 1.





_description: _







&lt;!----------------------------------------------------------------------------->

###void ofSeedRandom()

&lt;!--
_syntax: ofSeedRandom()_
_name: ofSeedRandom_
_returns: void_
_returns_description: _
_parameters: _
_version_started: 006_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Seed the seeds the random number generator with a unique value.

This seeds the random number generator with an acceptably random value,
generated from clock time and the PID.





_description: _







&lt;!----------------------------------------------------------------------------->

###void ofSeedRandom(val)

&lt;!--
_syntax: ofSeedRandom(val)_
_name: ofSeedRandom_
_returns: void_
_returns_description: _
_parameters: int val_
_version_started: 006_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Seed the random number generator.

If the user would like to repeat the same random sequence, a known random
seed can be used to initialize the random number generator during app
setup.  This can be useful for debugging and testing.


**Parameters:**

val The value with which to seed the generator.





_description: _







&lt;!----------------------------------------------------------------------------->

###int ofSign(n)

&lt;!--
_syntax: ofSign(n)_
_name: ofSign_
_returns: int_
_returns_description: _
_parameters: float n_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Returns the sign of a number.

**Returns**: int -1 if n is negative, 1 if n is positive, and 0 is n == 0;





_description: _







&lt;!----------------------------------------------------------------------------->

###float ofSignedNoise(&p)

&lt;!--
_syntax: ofSignedNoise(&p)_
_name: ofSignedNoise_
_returns: float_
_returns_description: _
_parameters: const glm::vec2 &p_
_version_started: 0.9.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Calculates a two dimensional Perlin noise value between -1.0...1.0.





_description: _







&lt;!----------------------------------------------------------------------------->

###float ofSignedNoise(&p)

&lt;!--
_syntax: ofSignedNoise(&p)_
_name: ofSignedNoise_
_returns: float_
_returns_description: _
_parameters: const glm::vec3 &p_
_version_started: 0.10.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Calculates a three dimensional Perlin noise value between -1.0...1.0.





_description: _







&lt;!----------------------------------------------------------------------------->

###float ofSignedNoise(&p)

&lt;!--
_syntax: ofSignedNoise(&p)_
_name: ofSignedNoise_
_returns: float_
_returns_description: _
_parameters: const glm::vec4 &p_
_version_started: 0.10.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Calculates a four dimensional Perlin noise value between -1.0...1.0.





_description: _







&lt;!----------------------------------------------------------------------------->

###float ofSignedNoise(x)

&lt;!--
_syntax: ofSignedNoise(x)_
_name: ofSignedNoise_
_returns: float_
_returns_description: _
_parameters: float x_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Calculates a one dimensional Perlin noise value between -1.0...1.0.





_description: _







&lt;!----------------------------------------------------------------------------->

###float ofSignedNoise(x, y)

&lt;!--
_syntax: ofSignedNoise(x, y)_
_name: ofSignedNoise_
_returns: float_
_returns_description: _
_parameters: float x, float y_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Calculates a two dimensional Perlin noise value between -1.0...1.0.





_description: _







&lt;!----------------------------------------------------------------------------->

###float ofSignedNoise(x, y, z)

&lt;!--
_syntax: ofSignedNoise(x, y, z)_
_name: ofSignedNoise_
_returns: float_
_returns_description: _
_parameters: float x, float y, float z_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Calculates a three dimensional Perlin noise value between -1.0...1.0.





_description: _







&lt;!----------------------------------------------------------------------------->

###float ofSignedNoise(x, y, z, w)

&lt;!--
_syntax: ofSignedNoise(x, y, z, w)_
_name: ofSignedNoise_
_returns: float_
_returns_description: _
_parameters: float x, float y, float z, float w_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Calculates a four dimensional Perlin noise value between -1.0...1.0.





_description: _







&lt;!----------------------------------------------------------------------------->

###float ofWrap(value, from, to)

&lt;!--
_syntax: ofWrap(value, from, to)_
_name: ofWrap_
_returns: float_
_returns_description: _
_parameters: float value, float from, float to_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Find a value within a given range, wrapping the value if it overflows.

If a value is between from and to, return that value.
If a value is NOT within that range, wrap it.

Example:
~~~~{.cpp}
		ofWrap(5, 0, 10); // Returns 5.
		ofWrap(15, 0, 10); // Also returns 5.
		ofWrap(-5, 0, 10); // Also returns 5.
~~~~


**Parameters:**

value The value to map.

from The lower bound of the range.

**Returns**: to The upper bound of the range.





_description: _







&lt;!----------------------------------------------------------------------------->

###float ofWrapDegrees(angle, from = -180, to = +180)

&lt;!--
_syntax: ofWrapDegrees(angle, from = -180, to = +180)_
_name: ofWrapDegrees_
_returns: float_
_returns_description: _
_parameters: float angle, float from, float to_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

###float ofWrapRadians(angle, from = -PI, to = +PI)

&lt;!--
_syntax: ofWrapRadians(angle, from = -PI, to = +PI)_
_name: ofWrapRadians_
_returns: float_
_returns_description: _
_parameters: float angle, float from, float to_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

</textarea></div></div></div></div></div></div><script defer src="/_nuxt/payloads/1584626286009/documentation/math/ofMath_functions/payload.js"></script><script src="/_nuxt/3213b67383225fc2f59b.js" defer></script><script src="/_nuxt/d1291586b31fa28ca9d5.js" defer></script><script src="/_nuxt/5fe5bba000836bc4a25f.js" defer></script><script src="/_nuxt/f8d94d1c92ade1d8a6da.js" defer></script><script src="/_nuxt/9a7e20c23e9625feab77.js" defer></script>
  </body>
</html>
