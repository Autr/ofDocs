<!doctype html>
<html data-n-head-ssr>
  <head>
    <title>ofThread | documentation | ofDocs</title><meta data-n-head="ssr" data-hid="description" name="description" content="openFrameworks documentation and examples browser"><meta data-n-head="ssr" data-hid="keyword" name="keyword" content=""><meta data-n-head="ssr" property="og:description" content="openFrameworks documentation and examples browser" vmid="og:description"><meta data-n-head="ssr" property="og:title" content="ofThread | documentation | ofDocs" vmid="og:title"><meta data-n-head="ssr" property="og:image" content="/files/images/ofw-logo.png" vmid="og:image"><link rel="preload" href="/_nuxt/5f71eaca0bd2f1a0f939.js" as="script"><link rel="preload" href="/_nuxt/906a3ca0fb13ed3c6651.js" as="script"><link rel="preload" href="/_nuxt/fe12c0cb7395fa1032f4.css" as="style"><link rel="preload" href="/_nuxt/b673915e8a08acf593e8.js" as="script"><link rel="preload" href="/_nuxt/46e8fcacdadb233d9fb6.css" as="style"><link rel="preload" href="/_nuxt/bf355f21967a23c26c07.js" as="script"><link rel="preload" href="/_nuxt/35a90d914f539af1362f.js" as="script"><link rel="stylesheet" href="/_nuxt/fe12c0cb7395fa1032f4.css"><link rel="stylesheet" href="/_nuxt/46e8fcacdadb233d9fb6.css">
  </head>
  <body>
    <div data-server-rendered="true" id="__nuxt"><!----><div id="__layout"><div id="app"><div id="menu"><div class="menu-inner"><div id="settings"></div><h1 class="of"><div class="inner"><span><a href="/" class="nuxt-link-active"><svg version="1.1" viewbox="0 0 110 58" width="110px" height="58px" enable-background="0 0 110 58" xml:space="preserve" class="logo"><g><path d="M58,29 C58,13 45,0 29,0 C13,0 0,13 0,29 C0,45 13,58 29,58 C45,58 58,45 58,29 Z"></path><rect x="59" y="0" width="25" height="58"></rect><rect x="85" y="26" width="15" height="15"></rect><path d="M85,0 L110,0 L85,25 L85,0 Z"></path></g></svg><div class="txt"><span class="docs f7 questrial">Docs </span><span class="version">0.11.0</span></div></a></span></div></h1><div id="search"><div class="inner"><div class="field text"><div class="field-inner"><svg viewbox="0 0 36 36" enable-background="new 0 0 36 36" xml:space="preserve"><path d="M35.525,31.228l-8.88-8.882c1.444-2.238,2.298-4.895,2.298-7.752c0-7.909-6.438-14.343-14.346-14.343							c-7.911,0-14.343,6.434-14.343,14.343c0,7.911,6.433,14.344,14.343,14.344c2.856,0,5.513-0.849,7.752-2.294l8.88,8.88							c0.295,0.297,0.782,0.297,1.076,0l3.22-3.221C35.824,32.008,35.824,31.523,35.525,31.228z M4.81,14.593							c0-5.396,4.391-9.788,9.788-9.788c5.398,0,9.787,4.392,9.787,9.788c0,5.398-4.389,9.789-9.787,9.789							C9.2,24.382,4.81,19.991,4.81,14.593z"></path></svg><!----><div class="text-wrapper"><input id="search_field" name="search_field" placeholder="Search (Alt+F)" autocomplete="off" tabindex="0"></div><!----><!----></div></div></div><!----></div><div id="lists" class="menu-inner mt1 mb2"><div class="inner"></div></div></div><div class="menu-bottom"><div class="inner"><button class="button"><!----><span><span class="ico">nights_stay</span></span></button></div></div></div><div id="document"><div id="renderer" class="main page"><div absolute="/Users/Gilbert/Code/openFrameworks/ofSite/documentation/utils/ofThread.markdown" route="/documentation/utils/ofThread.markdown" dir="../ofSite/documentation/utils" ext="markdown" type="page" id="2473" parent="2446" siblings="" translations="[object Object]" class="doc-header"><div class="doc-header-inner"><div class="inner"><span class="breadcrumbs"><span class="crumb"><a href="/" class="pink nuxt-link-active">ofDocs</a><span class="chevron right"></span></span><span class="crumb"><a href="/documentation/" class="pink nuxt-link-active">documentation </a><!----><span class="chevron right"></span></span><span class="crumb"><a href="/documentation/utils/" class="pink nuxt-link-active">utils </a><!----><span class="chevron right"></span></span><span class="crumb"><!----><span class="link selector"><span class="name">ofThread</span><span class="chevron bottom"></span><select><option value="/documentation/utils/ExtensionComparator">ExtensionComparator</option><option value="/documentation/utils/ofBuffer::Line">ofBuffer::Line</option><option value="/documentation/utils/ofBuffer::Lines">ofBuffer::Lines</option><option value="/documentation/utils/ofBuffer::RLine">ofBuffer::RLine</option><option value="/documentation/utils/ofBuffer::RLines">ofBuffer::RLines</option><option value="/documentation/utils/ofBuffer">ofBuffer</option><option value="/documentation/utils/ofConsoleLoggerChannel">ofConsoleLoggerChannel</option><option value="/documentation/utils/ofDirectory">ofDirectory</option><option value="/documentation/utils/ofFile">ofFile</option><option value="/documentation/utils/ofFileDialogResult">ofFileDialogResult</option><option value="/documentation/utils/ofFileLoggerChannel">ofFileLoggerChannel</option><option value="/documentation/utils/ofFilePath">ofFilePath</option><option value="/documentation/utils/ofFileUtils_functions">ofFileUtils (functions)</option><option value="/documentation/utils/ofFpsCounter">ofFpsCounter</option><option value="/documentation/utils/ofHttpRequest">ofHttpRequest</option><option value="/documentation/utils/ofHttpResponse">ofHttpResponse</option><option value="/documentation/utils/ofLog_functions">ofLog (functions)</option><option value="/documentation/utils/ofLog">ofLog</option><option value="/documentation/utils/ofLogError">ofLogError</option><option value="/documentation/utils/ofLogFatalError">ofLogFatalError</option><option value="/documentation/utils/ofLogNotice">ofLogNotice</option><option value="/documentation/utils/ofLogVerbose">ofLogVerbose</option><option value="/documentation/utils/ofLogWarning">ofLogWarning</option><option value="/documentation/utils/ofMatrixStack">ofMatrixStack</option><option value="/documentation/utils/ofSystemUtils_functions">ofSystemUtils (functions)</option><option value="/documentation/utils/ofThread">ofThread</option><option value="/documentation/utils/ofThreadChannel">ofThreadChannel</option><option value="/documentation/utils/ofTime">ofTime</option><option value="/documentation/utils/ofTimer">ofTimer</option><option value="/documentation/utils/ofURLFileLoader_functions">ofURLFileLoader (functions)</option><option value="/documentation/utils/ofURLFileLoader">ofURLFileLoader</option><option value="/documentation/utils/ofUTF8Iterator">ofUTF8Iterator</option><option value="/documentation/utils/ofUtils_functions">ofUtils (functions)</option><option value="/documentation/utils/ofXml_functions">ofXml (functions)</option><option value="/documentation/utils/ofXml::Attribute">ofXml::Attribute</option><option value="/documentation/utils/ofXml::Range">ofXml::Range</option><option value="/documentation/utils/ofXml::Search">ofXml::Search</option><option value="/documentation/utils/ofXml">ofXml</option><option value="/documentation/utils/ofXmlIterator">ofXmlIterator</option><option value="/documentation/utils/ofXmlSearchIterator">ofXmlSearchIterator</option></select></span><!----></span></span></div></div></div><div class="editable-wrapper"><div class="header inner"><h1 class="page-title questrial"><span class="f7"><!----><span>ofThread</span></span><span class="f3"></span></h1><div class="actions"><a href="/ofdocs/contribute/" class="button"><i class="ico">edit</i><span>Edit</span></a></div></div><div class="rendered"><div id="documentation-page" static="true"><div id="offset-page"><div id="doc-body" class="markdown"><div class="inner"><div id="description"><div class="full-description"><div class="html"><p>ofThread is a thread base class with a built in mutex. A <a href="http://en.wikipedia.org/wiki/Thread_(computing)">thread</a> is essentially a mini processing object you can run in parallel to your main application loop and is useful for running time intensive operations without slowing down your app.</p>
<p>####Implementing a Thread</p>
<p>For instance, you have to grab from a camera and waiting for an image slows down your app. You can offload this wait to a thread which tells the main app when an image is ready. To do this, you create a class that inherits from the ofThread class and implement the threadedFunction() function.</p>
<p>Declaration in a .h file:</p>
<pre><code class="language-{.cpp}">
<span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token operator">:</span> <span class="token keyword">public</span> ofThread <span class="token punctuation">{</span>

	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

	<span class="token comment" spellcheck="true">// the thread function</span>
	<span class="token keyword">void</span> MyThread<span class="token operator">::</span><span class="token function">threadedFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	
		<span class="token comment" spellcheck="true">// start</span>
	
		<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">isThreadRunning</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	
			cam<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>cam<span class="token punctuation">.</span><span class="token function">isFrameNew</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		
				<span class="token comment" spellcheck="true">// load the image</span>
				image<span class="token punctuation">.</span><span class="token function">setFromPixels</span><span class="token punctuation">(</span>cam<span class="token punctuation">.</span><span class="token function">getPixels</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	
		<span class="token comment" spellcheck="true">// done</span>
	<span class="token punctuation">}</span>
	
	ofVideoGrabber cam<span class="token punctuation">;</span>	<span class="token comment" spellcheck="true">// the cam</span>
	ofImage image<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre>
<p>In the application .h inside the ofApp class declare an object of type MyThread like:</p>
<pre><code class="language-{.cpp}"><span class="token comment" spellcheck="true">// create object</span>
MyThread thread<span class="token punctuation">;</span>
</code></pre>
<p>then in the .cpp file:</p>
<pre><code class="language-{.cpp}">
<span class="token keyword">void</span> ofApp<span class="token operator">::</span><span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

	<span class="token comment" spellcheck="true">// start the thread</span>
	thread<span class="token punctuation">.</span><span class="token function">startThread</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment" spellcheck="true">// blocking</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> ofApp<span class="token operator">::</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	
	<span class="token comment" spellcheck="true">// do something with the thread is running</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> ofApp<span class="token operator">::</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

	<span class="token comment" spellcheck="true">// stop the thread</span>
	thread<span class="token punctuation">.</span><span class="token function">stopThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre>
<p>####Shared Resources</p>
<p>With this great power, however, comes great responsibility. If both the thread and your main app loop try to access the image at the same time, bad things happen inside your computer and the app will crash. The image is a considered a "shared resource" and you need to make sure to lock access to it so that only 1 thread can access it a time. You can do this using a <a href="http://en.wikipedia.org/wiki/Mutex">"mutal exclusion" object</a> by called lock() when you want to access the resource, then unlock() when you are done.</p>
<p>Declaration in a .h file:</p>
<pre><code class="language-{.cpp}">
<span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token operator">:</span> <span class="token keyword">public</span> ofThread <span class="token punctuation">{</span>

	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

	<span class="token comment" spellcheck="true">// the thread function</span>
	<span class="token keyword">void</span> MyThread<span class="token operator">::</span><span class="token function">threadedFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	
		<span class="token comment" spellcheck="true">// start</span>
	
		<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">isThreadRunning</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	
			cam<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>cam<span class="token punctuation">.</span><span class="token function">isFrameNew</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	
				<span class="token comment" spellcheck="true">// lock access to the resource</span>
				<span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				
				<span class="token comment" spellcheck="true">// load the image</span>
				image<span class="token punctuation">.</span><span class="token function">setFromPixels</span><span class="token punctuation">(</span>cam<span class="token punctuation">.</span><span class="token function">getPixels</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	
				<span class="token comment" spellcheck="true">// done with the resource</span>
				<span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>	
		<span class="token punctuation">}</span>
	
		<span class="token comment" spellcheck="true">// done</span>
	<span class="token punctuation">}</span>

	ofVideoGrabber cam<span class="token punctuation">;</span>	<span class="token comment" spellcheck="true">// the cam</span>
	ofImage image<span class="token punctuation">;</span>		<span class="token comment" spellcheck="true">// the shared resource</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre>
<p>In the .cpp file:</p>
<pre><code class="language-{.cpp}">
<span class="token keyword">void</span> ofApp<span class="token operator">::</span><span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	
	<span class="token comment" spellcheck="true">// start the thread</span>
	thread<span class="token punctuation">.</span><span class="token function">startThread</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment" spellcheck="true">// blocking, non verbose</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> ofApp<span class="token operator">::</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	
	<span class="token comment" spellcheck="true">// lock access to the resource</span>
	thread<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment" spellcheck="true">// copy image</span>
	myImage <span class="token operator">=</span> thread<span class="token punctuation">.</span>image<span class="token punctuation">;</span>
	
	<span class="token comment" spellcheck="true">// done with the resource</span>
	thread<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> ofApp<span class="token operator">::</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

	<span class="token comment" spellcheck="true">// stop the thread</span>
	thread<span class="token punctuation">.</span><span class="token function">stopThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre>
<p>####Exiting Nicely</p>
<p>As a thread is running in parallel with your application main loop, it's important to remember to tell it to stop before exiting the app. If you don't, you'll get weird errors or hangs because you aren't being nice to your threads. Depending on how you started your thread (blocking or non-blocking mode), you will either stop it for wait for it to finish. See the stopThread() & waitForThread() functions.</p>
<p>####Debugging</p>
<p>Thread errors are <em>notoriously</em> difficult to debug sometimes. You will probably see a "Bad Access" runtime error or something similar if multiple threads are trying to access a shared resource simultaneously. Other times, nothing will happen as the thread may be stuck in an infinite loop and you can't stop it. Wee! We assume if you've read this far, you probably accept the difficulties in order to reap the thread speed rewards.</p>
<p>A useful tool in debugging thread timing and access is the ofThread verbose mode which prints thread events such as starting, stopping, and mutex locking/unlocking. Simply set verbose=true when calling startThread(). Another trick is to use an ofSleepMillis() inside the thread to slow it down so you can see the timing better while debugging it.</p>
<p>####HOO RAH</p>
<p>Ok soldier, lock and load ... good luck!</p>
<h1></h1>
</div></div></div><div id="methods"><hr><section name="getNativeThread" id="getNativeThread" class="mb2"><div class="method mb2"><h3 class="f3 title">getNativeThread( <!----> )</h3><code><span class="token keyword">thread &  </span><span class="token function">getNativeThread</span><span class="token punctuation">(</span><!----><span class="token punctuation">)</span></code><div class="short"><p>Get a reference to the underlying Poco thread.</p>
<p>Poco::Thread provides a clean cross-platform wrapper for
threads.  On occasion, it may be useful to interact with the
underlying Poco::Thread directly.</p>
<p><strong>Returns</strong>: A reference to the backing Poco thread.</p>
</div><div class="desc"></div></div><hr></section><section name="getNativeThread" id="getNativeThread" class="mb2"><div class="method mb2"><h3 class="f3 title">getNativeThread( <!----> )</h3><code><span class="token keyword">const thread &  </span><span class="token function">getNativeThread</span><span class="token punctuation">(</span><!----><span class="token punctuation">)</span></code><div class="short"><p>Get a const reference to the underlying Poco thread.</p>
<p>Poco::Thread provides a clean cross-platform wrapper for
threads.  On occasion, it may be useful to interact with the
underlying Poco::Thread directly.</p>
<p><strong>Returns</strong>: A reference to the backing Poco thread.</p>
</div><div class="desc"></div></div><hr></section><section name="getThreadId" id="getThreadId" class="mb2"><div class="method mb2"><h3 class="f3 title">getThreadId( <!----> )</h3><code><span class="token keyword">thread::id  </span><span class="token function">getThreadId</span><span class="token punctuation">(</span><!----><span class="token punctuation">)</span></code><div class="short"><p>Get the unique thread id.
\note This is NOT the the same as the operating thread id!</p>
</div><div class="desc"></div></div><hr></section><section name="getThreadName" id="getThreadName" class="mb2"><div class="method mb2"><h3 class="f3 title">getThreadName( <!----> )</h3><code><span class="token keyword">string  </span><span class="token function">getThreadName</span><span class="token punctuation">(</span><!----><span class="token punctuation">)</span></code><div class="short"><p>Get the unique thread name, in the form of "Thread id#"</p>
<p><strong>Returns</strong>: the Thread ID string.</p>
</div><div class="desc"></div></div><hr></section><section name="isCurrentThread" id="isCurrentThread" class="mb2"><div class="method mb2"><h3 class="f3 title">isCurrentThread( <!----> )</h3><code><span class="token keyword">bool  </span><span class="token function">isCurrentThread</span><span class="token punctuation">(</span><!----><span class="token punctuation">)</span></code><div class="short"><p>Query whether the current thread is active.</p>
<p>In multithreaded situations, it can be useful to know which
thread is currently running some code in order to make sure
only certain threads can do certain things.  For example,
OpenGL can only run in the main execution thread.  Thus,
situations where a thread is responsible for interacting
with graphics resources may need to prevent graphics updates
unless the main thread is accessing or updating resources
shared with this ofThread (or its subclass).</p>
<pre><code>if(myThread.isCurrentThread())
{
    // do some myThread things,
    // but keep your hands off my resources!
}
else if(ofThread::isMainThread())
{
    // pheew! ok, update those graphics resources
}
</code></pre>
<p>By way of another example, a subclass of ofThread may have
an update() method that is called from ofBaseApp during the
execution of the main application thread.  In these cases,
the ofThread subclass might want to ask itself whether it
can, for instance, call update() on an ofImage, in order to
send copy some ofPixels to an ofTexture on the graphics
card.</p>
<p><strong>Returns</strong>: True iff this ofThread the currently active thread.</p>
</div><div class="desc"></div></div><hr></section><section name="isThreadRunning" id="isThreadRunning" class="mb2"><div class="method mb2"><h3 class="f3 title">isThreadRunning( <!----> )</h3><code><span class="token keyword">bool  </span><span class="token function">isThreadRunning</span><span class="token punctuation">(</span><!----><span class="token punctuation">)</span></code><div class="short"><p>Check the running status of the thread.</p>
<p><strong>Returns</strong>: true iff the thread is currently running.</p>
</div><div class="desc"><p>Returns true if the thread is currently running. This is especially useful inside the thread's threadedFunction() when you want it to loop continuously until it's told to exit:</p>
<pre><code class="language-{.cpp}">
<span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token operator">:</span> <span class="token keyword">public</span> ofThread <span class="token punctuation">{</span>

	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

	<span class="token comment" spellcheck="true">// the thread function</span>
	<span class="token keyword">void</span> MyThread<span class="token operator">::</span><span class="token function">threadedFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	
		<span class="token comment" spellcheck="true">// start</span>
	
		<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">isThreadRunning</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	
			<span class="token comment" spellcheck="true">// do stuff</span>
		<span class="token punctuation">}</span>
	
		<span class="token comment" spellcheck="true">// done</span>
	<span class="token punctuation">}</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre>
</div></div><hr></section><section name="lock" id="lock" class="mb2"><div class="method mb2"><h3 class="f3 title">lock( <!----> )</h3><code><span class="token keyword">bool  </span><span class="token function">lock</span><span class="token punctuation">(</span><!----><span class="token punctuation">)</span></code><div class="short"><p>Lock the mutex.</p>
<p>If the thread was started startThread(true), then this call will wait
until the mutex is available and return true.  If the thread was started
startThread(false), this call will return true iff the mutex is
was successfully acquired.</p>
<p><strong>Returns</strong>: true if the lock was successfully acquired.</p>
</div><div class="desc"><p>Try to lock the mutex.</p>
<p>If the thread was started in blocking mode in startThread(), any thread (including your app main loop) will wait until the mutex is unlocked.</p>
<p>If the thread is non-blocking, this call will immediately return a true or false if the mutex is available. It is up to you to make sure the resource is not being used when accessing it. See the <a href="http://en.wikipedia.org/wiki/Non-blocking_algorithm">Wikipedia article on Non-blocking</a> for reasons as to why using a non-blocking thread might be more advantageous.</p>
</div></div><hr></section><section name="ofThread" id="ofThread" class="mb2"><div class="method mb2"><h3 class="f3 title">ofThread( <!----> )</h3><code><!----><span class="token function">ofThread</span><span class="token punctuation">(</span><!----><span class="token punctuation">)</span></code><div class="short"><p>Create an ofThread.</p>
</div><div class="desc"></div></div><hr></section><section name="run" id="run" class="mb2"><div class="method mb2"><h3 class="f3 title">run( <!----> )</h3><code><span class="token keyword">void  </span><span class="token function">run</span><span class="token punctuation">(</span><!----><span class="token punctuation">)</span></code><div class="short"></div><div class="desc"></div></div><hr></section><section name="setThreadName" id="setThreadName" class="mb2"><div class="method mb2"><h3 class="f3 title">setThreadName( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">setThreadName</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">const</span> string <span class="token operator">&</span>name</code><span class="token punctuation">)</span></code><div class="short"></div><div class="desc"></div></div><hr></section><section name="sleep" id="sleep" class="mb2"><div class="method mb2"><h3 class="f3 title">sleep( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">sleep</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">long</span> milliseconds</code><span class="token punctuation">)</span></code><div class="short"><p>Tell the thread to sleep for a certain amount of milliseconds.</p>
<p>This is useful inside the threadedFunction() when a thread is waiting
for input to process:</p>
<pre><code>void MyThreadedClass::threadedFunction()
{
	    // start
	    while(isThreadRunning())
    {
        // bReadyToProcess can be set from outside the threadedFuntion.
        // perhaps by another thread that downloads data, or loads
        // some media, etc.

	    	if(bReadyToProcess == true)
        {
	    		// do some time intensive processing
	    		bReadyToProcess = false;
	    	}
        else
        {
	    		// sleep the thread to give up some cpu
	    		sleep(20);
	    	}
	    }
	    // done
}
</code></pre>
<p>If the user does not give the thread a chance to sleep, the
thread may take 100% of the CPU core while it's looping as it
waits for something to do.  This may lead to poor application
performance.</p>
<p><strong>Parameters:</strong></p>
<p>milliseconds The number of milliseconds to sleep.</p>
</div><div class="desc"></div></div><hr></section><section name="startThread" id="startThread" class="mb2"><div class="method mb2"><h3 class="f3 title">startThread( <!----> )</h3><code><span class="token keyword">void  </span><span class="token function">startThread</span><span class="token punctuation">(</span><!----><span class="token punctuation">)</span></code><div class="short"><p>Start the thread.
\note Subclasses can directly access the mutex and employ thier
own locking strategy.</p>
</div><div class="desc"></div></div><hr></section><section name="stopThread" id="stopThread" class="mb2"><div class="method mb2"><h3 class="f3 title">stopThread( <!----> )</h3><code><span class="token keyword">void  </span><span class="token function">stopThread</span><span class="token punctuation">(</span><!----><span class="token punctuation">)</span></code><div class="short"><p>Stop the thread.</p>
<p>This does immediately stop the thread from processing, but
will only set a flag that must be checked from within your
threadedFunction() by calling isThreadRunning().  If the user wants
to both stop the thread AND wait for the thread to finish
processing, the user should call waitForThread(true, ...).</p>
</div><div class="desc"></div></div><hr></section><section name="threadedFunction" id="threadedFunction" class="mb2"><div class="method mb2"><h3 class="f3 title">threadedFunction( <!----> )</h3><code><span class="token keyword">void  </span><span class="token function">threadedFunction</span><span class="token punctuation">(</span><!----><span class="token punctuation">)</span></code><div class="short"><p>The thread's run function.</p>
<p>Users must overide this in your their derived class
and then implement their threaded activity inside the loop.
If the the users's threadedFunction does not have a loop,
the contents of the threadedFunction will be executed once
and the thread will then exit.</p>
<p>For tasks that must be repeated, the user can use a while
loop that will run repeatedly until the thread's
threadRunning is set to false via the stopThread() method.</p>
<pre><code>void MyThreadedClass::threadedFunction()
{
    // Start the loop and continue until
    // isThreadRunning() returns false.
    while(isThreadRunning())
    {
        // Do activity repeatedly here:

        // int j = 1 + 1;

        // This while loop will run as fast as it possibly
        // can, consuming as much processor speed as it can.
        // To help the processor stay cool, users are
        // encouraged to let the while loop sleep via the
        // sleep() method, or call the yield() method to let
        // other threads have a turn.  See the sleep() and
        // yield() methods for more information.

        // sleep(100);
    }
}
</code></pre>
</div><div class="desc"><p>This is the thread run function, the heart of your thread.</p>
<p>You need to override this in your derived class and implement your thread stuff inside. If you do not have a loop inside this function, it will run once then exit. If you want the thread to run until you signal it to stop, use a while loop inside that checks if the thread is should keep running.</p>
<p>Declaration in a .h file:</p>
<pre><code class="language-{.cpp}">
<span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token operator">:</span> <span class="token keyword">public</span> ofThread <span class="token punctuation">{</span>

	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

	<span class="token comment" spellcheck="true">// the thread function</span>
	<span class="token keyword">void</span> MyThread<span class="token operator">::</span><span class="token function">threadedFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	
		<span class="token comment" spellcheck="true">// start</span>
	
		<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">isThreadRunning</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	
			<span class="token comment" spellcheck="true">// do stuff</span>
		<span class="token punctuation">}</span>
	
		<span class="token comment" spellcheck="true">// done</span>
	<span class="token punctuation">}</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre>
<p>In the .cpp file:</p>
<pre><code class="language-{.cpp}">
<span class="token keyword">void</span> ofApp<span class="token operator">::</span><span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

	<span class="token comment" spellcheck="true">// create object</span>
	MyThread thread<span class="token punctuation">;</span>
	
	<span class="token comment" spellcheck="true">// start the thread</span>
	thread<span class="token punctuation">.</span><span class="token function">startThread</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment" spellcheck="true">// blocking, non verbose</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> ofApp<span class="token operator">::</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

	<span class="token comment" spellcheck="true">// do something else while the thread is running</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> ofApp<span class="token operator">::</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	
	<span class="token comment" spellcheck="true">// stop the thread</span>
	thread<span class="token punctuation">.</span><span class="token function">stopThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre>
</div></div><hr></section><section name="tryLock" id="tryLock" class="mb2"><div class="method mb2"><h3 class="f3 title">tryLock( <!----> )</h3><code><span class="token keyword">bool  </span><span class="token function">tryLock</span><span class="token punctuation">(</span><!----><span class="token punctuation">)</span></code><div class="short"><p>Tries to lock the mutex.</p>
<p>If the thread was started startThread(true), then this call will wait
until the mutex is available and return true.  If the thread was started
startThread(false), this call will return true iff the mutex is
was successfully acquired.</p>
<p><strong>Returns</strong>: true if the lock was successfully acquired.</p>
</div><div class="desc"></div></div><hr></section><section name="unlock" id="unlock" class="mb2"><div class="method mb2"><h3 class="f3 title">unlock( <!----> )</h3><code><span class="token keyword">void  </span><span class="token function">unlock</span><span class="token punctuation">(</span><!----><span class="token punctuation">)</span></code><div class="short"><p>Unlock the mutex.</p>
<p>This will only unlocks the mutex if it was previously by the same
calling thread.</p>
</div><div class="desc"><p>Unlock the mutex.</p>
<p>This only unlocks the mutex if the calling thread had previously locked it, otherwise the functions does nothing and does not block.</p>
</div></div><hr></section><section name="waitForThread" id="waitForThread" class="mb2"><div class="method mb2"><h3 class="f3 title">waitForThread( <code class="pink">...</code> )</h3><code><span class="token keyword">void  </span><span class="token function">waitForThread</span><span class="token punctuation">(</span><code class="token boolean"><span class="token keyword">bool</span> callStopThread<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token keyword">long</span> milliseconds</code><span class="token punctuation">)</span></code><div class="short"><p>Wait for the thread to exit (aka "joining" the thread).</p>
<p>This method waits for a thread will "block" and wait for the
thread (aka "join" the thread) before it returns.  This allows the
user to be sure that the thread is properly cleaned up.  An example
of when this might be particularly important is if the
threadedFunction() is opening a set of network sockets, or
downloading data from the web.  Destroying an ofThread subclass
without releasing those sockets (or other resources), may result in
segmentation faults, error signals or other undefined behaviors.</p>
<p><strong>Parameters:</strong></p>
<p>callStopThread Set stop to true if you want to signal the thread
to exit before waiting.  This is the equivalent to calling
stopThread(). If you your threadedFunction uses a while-loop that
depends on isThreadRunning() and you do not call stopThread() or set
stop == true, waitForThread will hang indefinitely.  Set stop ==
false ONLY if you have already called stopThread() and you simply
need to be sure your thread has finished its tasks.</p>
<p>milliseconds If millseconds is set to INFINITE_JOIN_TIMEOUT, the
waitForThread will wait indefinitely for the thread to complete.  If
milliseconds is set to a lower number (e.g. 10000 for 10 seconds),
waitForThread will wait for 10000 milliseconds and if the thread has
not yet stopped it will return and log an error message.  Users are
encouraged to use the default INFINITE_JOIN_TIMEOUT.  If the user is
unhappy with the amount of time it takes to join a thread, the user
is encouraged to seek more expedient ways of signalling their desire
for a thread to complete via other signalling methods such as
Poco::Event, Poco::Condition, or Poco::Semaphore.</p>
<p><strong>See also</strong>: http://pocoproject.org/slides/090-NotificationsEvents.pdf</p>
<p><strong>See also</strong>: http://pocoproject.org/docs/Poco.Condition.html</p>
<p><strong>See also</strong>: http://pocoproject.org/docs/Poco.Event.html</p>
<p><strong>See also</strong>: http://pocoproject.org/docs/Poco.Semaphore.html</p>
</div><div class="desc"></div></div><hr></section><section name="yield" id="yield" class="mb2"><div class="method mb2"><h3 class="f3 title">yield( <!----> )</h3><code><span class="token keyword">void  </span><span class="token function">yield</span><span class="token punctuation">(</span><!----><span class="token punctuation">)</span></code><div class="short"><p>Tell the thread to give up its CPU time other threads.</p>
<p>This method is similar to sleep() and can often be used in
the same way.  The main difference is that 1 millisecond
(the minimum sleep time available with sleep()) is a very
long time on modern processors and yield() simply gives up
processing time to the next thread, instead of waiting for
number of milliseconds. In some cases, this behavior will
be preferred.</p>
</div><div class="desc"></div></div><hr></section></div></div></div></div><div id="side-menu"><div id="params"><h4 class="f3">Variables</h4><code><div class="functions"></div><div class="variable"><div class="title"><span class="token keyword">condition_variable </span><span>condition</span><span class="token comment"></span></div><div class="desc"></div></div></code><code><div class="functions"></div><div class="variable"><div class="title"><span class="token keyword">ofMutex </span><span>mutex</span><span class="token comment"></span></div><div class="desc"><p>This is the internal <a href="http://en.wikipedia.org/wiki/Mutex">mutex</a> called through lock() & unlock(). You can use it manually inside your derived class.</p>
</div></div></code><code><div class="functions"></div><div class="variable"><div class="title"><span class="token keyword">string </span><span>name</span><span class="token comment"></span></div><div class="desc"></div></div></code><code><div class="functions"></div><div class="variable"><div class="title"><span class="token keyword">Poco </span><span>thread</span><span class="token comment">The Poco::Thread that runs the Poco::Runnable.
</span></div><div class="desc"></div></div></code></div><div id="methods-list"><h4 class="f3">Methods</h4><div class="anchor"><code><a href="#getNativeThread" class="pink"><span>getNativeThread</span><span>(2)</span></a></code></div><div class="anchor"><code><a href="#getThreadId" class="pink"><span>getThreadId</span><!----></a></code></div><div class="anchor"><code><a href="#getThreadName" class="pink"><span>getThreadName</span><!----></a></code></div><div class="anchor"><code><a href="#isCurrentThread" class="pink"><span>isCurrentThread</span><!----></a></code></div><div class="anchor"><code><a href="#isThreadRunning" class="pink"><span>isThreadRunning</span><!----></a></code></div><div class="anchor"><code><a href="#lock" class="pink"><span>lock</span><!----></a></code></div><div class="anchor"><code><a href="#ofThread" class="pink"><span>ofThread</span><!----></a></code></div><div class="anchor"><code><a href="#run"><span>run</span><!----></a></code></div><div class="anchor"><code><a href="#setThreadName"><span>setThreadName</span><!----></a></code></div><div class="anchor"><code><a href="#sleep" class="pink"><span>sleep</span><!----></a></code></div><div class="anchor"><code><a href="#startThread" class="pink"><span>startThread</span><!----></a></code></div><div class="anchor"><code><a href="#stopThread" class="pink"><span>stopThread</span><!----></a></code></div><div class="anchor"><code><a href="#threadedFunction" class="pink"><span>threadedFunction</span><!----></a></code></div><div class="anchor"><code><a href="#tryLock" class="pink"><span>tryLock</span><!----></a></code></div><div class="anchor"><code><a href="#unlock" class="pink"><span>unlock</span><!----></a></code></div><div class="anchor"><code><a href="#waitForThread" class="pink"><span>waitForThread</span><!----></a></code></div><div class="anchor"><code><a href="#yield" class="pink"><span>yield</span><!----></a></code></div></div><div id="see-also" filename="ofThread.markdown" absolute="/Users/Gilbert/Code/openFrameworks/ofSite/documentation/utils/ofThread.markdown" route="/documentation/utils/ofThread.markdown" dir="../ofSite/documentation/utils" ext="markdown" type="page" parent="2446" breadcrumbs="2446,1968" siblings="" translations="[object Object]" class="see-also"><h4 class="f3">See also</h4><div class="also"><a href="/documentation/utils/ofThreadChannel"><span class="origin">documentation</span><span class="name">ofThreadChannel</span></a></div><div class="also"><a href="/openframeworks/utils/ofThreadChannel_h"><span class="origin">openframeworks</span><span class="name">ofThreadChannel.h</span></a></div><div class="also"><a href="/openframeworks/utils/ofThread_h"><span class="origin">openframeworks</span><span class="name">ofThread.h</span></a></div><div class="also"><a href="/openframeworks/utils/ofThread_cpp"><span class="origin">openframeworks</span><span class="name">ofThread.cpp</span></a></div></div></div></div></div><textarea rows="0" class="markdown-editor" style="display:none">#class ofThread


&lt;!--
_visible: True_
_advanced: False_
_istemplated: False_
_extends: _
-->

##InlineDescription


A threaded base class with a built in mutex for convenience.

Users can extend this base class by public inheritance like this:

    class MyThreadedClass: public ofThread
    {
        public:
        ...
        void threadedFunction()
        {
            while(isThreadRunning())
            {
                Threaded function here.
            }
        }
    };

ofThread is a convenient wrapper for Poco::Thread, Poco::Runnable and
Poco::Mutex.  It represents a simplified (sometimes overly simplified -
or simplified in ways that might not make sense for your project)
pathway for quickly writing threaded classes.  Poco::Runnable represents
a class that can be "run" via its void run() method.  Poco::Thread is
able to spawn a thread and "run" the contents of a class that extends
the Poco::Runnable interface (which ofThread does).  Poco::FastMutex,
(aka ofMutex) is a "mutual exclusion" object that prevents two threads
from accessing the same data at the same time.  It is important to know
that Poco::FastMutex (aka ofMutex) is not "recursive" while Poco::Mutex
is. This means that if the same thread attempts to lock a thread while
it ALREADY has a lock on the mutex, the program will lock up and go
nowhere.  Thus, it is important that ofThread subclasses carefully
their use of the mutex.  Currently ofThread does not lock its own mutex
at any point (e.g. ofThread's internal variables are not thread safe).
This is a somewhat dangerous convenience that is (theoretically)
supposed to make it easier for subclasses to avoid the recursive mutex
"problem". The situation that arises from two threads simultanously
reading or writing from the same shared data (shared data
occupies the same physical location in memory) leads to something
called a "race condition", which can lead to deadlocks.
A deadlock is as bad as it sounds.  It means your program
just stops.  ofMutex prevents race conditions, deadlocks and crashes by
permitting only one thread access to shared data at a time.  When using
mutexes to protect data, the trick is to always be sure to unlock the
mutex when finished.  This problem can often be avoided by using
an Poco::FastMutex::ScopedLock (aka ofScopedLock).  See the
the documentation for more information.  Finally, there are many cases
where it might make more sense to use Poco::Thread, Poco::Runnable and
Poco::FastMutex directly rather than using ofThread.  Further, cross
platform thread management will be alleviated with the std::thread
support library included with C++11.

Uncaught Exceptions throw from within ofThread will cause the thread to stop
and the Exception will be delivered to the default ofBaseThreadErrorHandler.
The ofBaseThreadErrorHandler will print the exception details, if available.
The ofBaseThreadErrorHandler offers no opportunity to take corrective action
and only allows the user to receive more valuable debugging information
about the uncaught exception.  Users should design ofThread subclasses to
catch and respond to all anticipated exceptions.





##Description

ofThread is a thread base class with a built in mutex. A [thread](http://en.wikipedia.org/wiki/Thread_(computing)) is essentially a mini processing object you can run in parallel to your main application loop and is useful for running time intensive operations without slowing down your app.

####Implementing a Thread

For instance, you have to grab from a camera and waiting for an image slows down your app. You can offload this wait to a thread which tells the main app when an image is ready. To do this, you create a class that inherits from the ofThread class and implement the threadedFunction() function.

Declaration in a .h file:

~~~~{.cpp}

class MyThread : public ofThread {

	...

	// the thread function
	void MyThread::threadedFunction() {
	
		// start
	
		while(isThreadRunning()) {
	
			cam.update();
			if(cam.isFrameNew()) {
		
				// load the image
				image.setFromPixels(cam.getPixels());
			}
		}
	
		// done
	}
	
	ofVideoGrabber cam;	// the cam
	ofImage image;
};

~~~~

In the application .h inside the ofApp class declare an object of type MyThread like:

~~~~{.cpp}
// create object
MyThread thread;
~~~~

then in the .cpp file:

~~~~{.cpp}

void ofApp::setup() {

	// start the thread
	thread.startThread(true);	// blocking
}

void ofApp::update() {
	
	// do something with the thread is running
}

void ofApp::exit() {

	// stop the thread
	thread.stopThread();
}

~~~~

####Shared Resources

With this great power, however, comes great responsibility. If both the thread and your main app loop try to access the image at the same time, bad things happen inside your computer and the app will crash. The image is a considered a "shared resource" and you need to make sure to lock access to it so that only 1 thread can access it a time. You can do this using a ["mutal exclusion" object](http://en.wikipedia.org/wiki/Mutex) by called lock() when you want to access the resource, then unlock() when you are done.

Declaration in a .h file:

~~~~{.cpp}

class MyThread : public ofThread {

	...

	// the thread function
	void MyThread::threadedFunction() {
	
		// start
	
		while(isThreadRunning()) {
	
			cam.update();
			if(cam.isFrameNew()) {
	
				// lock access to the resource
				lock();
				
				// load the image
				image.setFromPixels(cam.getPixels());	
				// done with the resource
				unlock();
			}	
		}
	
		// done
	}

	ofVideoGrabber cam;	// the cam
	ofImage image;		// the shared resource
};

~~~~

In the .cpp file:

~~~~{.cpp}

void ofApp::setup() {
	
	// start the thread
	thread.startThread(true, false);	// blocking, non verbose
}

void ofApp::update() {
	
	// lock access to the resource
	thread.lock();
	
	// copy image
	myImage = thread.image;
	
	// done with the resource
	thread.unlock();
}

void ofApp::exit() {

	// stop the thread
	thread.stopThread();
}

~~~~

####Exiting Nicely

As a thread is running in parallel with your application main loop, it's important to remember to tell it to stop before exiting the app. If you don't, you'll get weird errors or hangs because you aren't being nice to your threads. Depending on how you started your thread (blocking or non-blocking mode), you will either stop it for wait for it to finish. See the stopThread() & waitForThread() functions.

####Debugging

Thread errors are *notoriously* difficult to debug sometimes. You will probably see a "Bad Access" runtime error or something similar if multiple threads are trying to access a shared resource simultaneously. Other times, nothing will happen as the thread may be stuck in an infinite loop and you can't stop it. Wee! We assume if you've read this far, you probably accept the difficulties in order to reap the thread speed rewards. 

A useful tool in debugging thread timing and access is the ofThread verbose mode which prints thread events such as starting, stopping, and mutex locking/unlocking. Simply set verbose=true when calling startThread(). Another trick is to use an ofSleepMillis() inside the thread to slow it down so you can see the timing better while debugging it.

####HOO RAH

Ok soldier, lock and load ... good luck!





##Methods



###thread & getNativeThread()

&lt;!--
_syntax: getNativeThread()_
_name: getNativeThread_
_returns: thread &_
_returns_description: _
_parameters: _
_access: public_
_version_started: 0.10.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Get a reference to the underlying Poco thread.

Poco::Thread provides a clean cross-platform wrapper for
threads.  On occasion, it may be useful to interact with the
underlying Poco::Thread directly.


**Returns**: A reference to the backing Poco thread.





_description: _







&lt;!----------------------------------------------------------------------------->

###const thread & getNativeThread()

&lt;!--
_syntax: getNativeThread()_
_name: getNativeThread_
_returns: const thread &_
_returns_description: _
_parameters: _
_access: public_
_version_started: 0.10.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Get a const reference to the underlying Poco thread.

Poco::Thread provides a clean cross-platform wrapper for
threads.  On occasion, it may be useful to interact with the
underlying Poco::Thread directly.


**Returns**: A reference to the backing Poco thread.





_description: _







&lt;!----------------------------------------------------------------------------->

###thread::id getThreadId()

&lt;!--
_syntax: getThreadId()_
_name: getThreadId_
_returns: thread::id_
_returns_description: _
_parameters: _
_access: public_
_version_started: 0071_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Get the unique thread id.
\note This is NOT the the same as the operating thread id!





_description: _







&lt;!----------------------------------------------------------------------------->

###string getThreadName()

&lt;!--
_syntax: getThreadName()_
_name: getThreadName_
_returns: string_
_returns_description: _
_parameters: _
_access: public_
_version_started: 0.8.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Get the unique thread name, in the form of "Thread id#"

**Returns**: the Thread ID string.





_description: _







&lt;!----------------------------------------------------------------------------->

###bool isCurrentThread()

&lt;!--
_syntax: isCurrentThread()_
_name: isCurrentThread_
_returns: bool_
_returns_description: _
_parameters: _
_access: public_
_version_started: 0071_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Query whether the current thread is active.

In multithreaded situations, it can be useful to know which
thread is currently running some code in order to make sure
only certain threads can do certain things.  For example,
OpenGL can only run in the main execution thread.  Thus,
situations where a thread is responsible for interacting
with graphics resources may need to prevent graphics updates
unless the main thread is accessing or updating resources
shared with this ofThread (or its subclass).

    if(myThread.isCurrentThread())
    {
        // do some myThread things,
        // but keep your hands off my resources!
    }
    else if(ofThread::isMainThread())
    {
        // pheew! ok, update those graphics resources
    }

By way of another example, a subclass of ofThread may have
an update() method that is called from ofBaseApp during the
execution of the main application thread.  In these cases,
the ofThread subclass might want to ask itself whether it
can, for instance, call update() on an ofImage, in order to
send copy some ofPixels to an ofTexture on the graphics
card.


**Returns**: True iff this ofThread the currently active thread.





_description: _







&lt;!----------------------------------------------------------------------------->

###bool isThreadRunning()

&lt;!--
_syntax: isThreadRunning()_
_name: isThreadRunning_
_returns: bool_
_returns_description: _
_parameters: _
_access: public_
_version_started: 007_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Check the running status of the thread.

**Returns**: true iff the thread is currently running.





_description: _

Returns true if the thread is currently running. This is especially useful inside the thread's threadedFunction() when you want it to loop continuously until it's told to exit:

~~~~{.cpp}

class MyThread : public ofThread {

	...

	// the thread function
	void MyThread::threadedFunction() {
	
		// start
	
		while(isThreadRunning()) {
	
			// do stuff
		}
	
		// done
	}

};

~~~~





&lt;!----------------------------------------------------------------------------->

###bool lock()

&lt;!--
_syntax: lock()_
_name: lock_
_returns: bool_
_returns_description: _
_parameters: _
_access: public_
_version_started: 007_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Lock the mutex.

If the thread was started startThread(true), then this call will wait
until the mutex is available and return true.  If the thread was started
startThread(false), this call will return true iff the mutex is
was successfully acquired.


**Returns**: true if the lock was successfully acquired.





_description: _

Try to lock the mutex.

If the thread was started in blocking mode in startThread(), any thread (including your app main loop) will wait until the mutex is unlocked.

If the thread is non-blocking, this call will immediately return a true or false if the mutex is available. It is up to you to make sure the resource is not being used when accessing it. See the [Wikipedia article on Non-blocking](http://en.wikipedia.org/wiki/Non-blocking_algorithm) for reasons as to why using a non-blocking thread might be more advantageous.





&lt;!----------------------------------------------------------------------------->

### ofThread()

&lt;!--
_syntax: ofThread()_
_name: ofThread_
_returns: _
_returns_description: _
_parameters: _
_access: public_
_version_started: 007_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: False_
_advanced: False_
-->

_inlined_description: _

Create an ofThread.





_description: _







&lt;!----------------------------------------------------------------------------->

###void run()

&lt;!--
_syntax: run()_
_name: run_
_returns: void_
_returns_description: _
_parameters: _
_access: private_
_version_started: 0071_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

###void setThreadName(&name)

&lt;!--
_syntax: setThreadName(&name)_
_name: setThreadName_
_returns: void_
_returns_description: _
_parameters: const string &name_
_access: public_
_version_started: 0.10.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

###void sleep(milliseconds)

&lt;!--
_syntax: sleep(milliseconds)_
_name: sleep_
_returns: void_
_returns_description: _
_parameters: long milliseconds_
_access: public_
_version_started: 0.8.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Tell the thread to sleep for a certain amount of milliseconds.

This is useful inside the threadedFunction() when a thread is waiting
for input to process:

    void MyThreadedClass::threadedFunction()
    {
		    // start
		    while(isThreadRunning())
        {
            // bReadyToProcess can be set from outside the threadedFuntion.
            // perhaps by another thread that downloads data, or loads
            // some media, etc.

		    	if(bReadyToProcess == true)
            {
		    		// do some time intensive processing
		    		bReadyToProcess = false;
		    	}
            else
            {
		    		// sleep the thread to give up some cpu
		    		sleep(20);
		    	}
		    }
		    // done
    }

If the user does not give the thread a chance to sleep, the
thread may take 100% of the CPU core while it's looping as it
waits for something to do.  This may lead to poor application
performance.


**Parameters:**

milliseconds The number of milliseconds to sleep.





_description: _







&lt;!----------------------------------------------------------------------------->

###void startThread()

&lt;!--
_syntax: startThread()_
_name: startThread_
_returns: void_
_returns_description: _
_parameters: _
_access: public_
_version_started: 0.8.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Start the thread.
\note Subclasses can directly access the mutex and employ thier
      own locking strategy.





_description: _







&lt;!----------------------------------------------------------------------------->

###void stopThread()

&lt;!--
_syntax: stopThread()_
_name: stopThread_
_returns: void_
_returns_description: _
_parameters: _
_access: public_
_version_started: 0072_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Stop the thread.

This does immediately stop the thread from processing, but
will only set a flag that must be checked from within your
threadedFunction() by calling isThreadRunning().  If the user wants
to both stop the thread AND wait for the thread to finish
processing, the user should call waitForThread(true, ...).





_description: _







&lt;!----------------------------------------------------------------------------->

###void threadedFunction()

&lt;!--
_syntax: threadedFunction()_
_name: threadedFunction_
_returns: void_
_returns_description: _
_parameters: _
_access: protected_
_version_started: 007_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

The thread's run function.

Users must overide this in your their derived class
and then implement their threaded activity inside the loop.
If the the users's threadedFunction does not have a loop,
the contents of the threadedFunction will be executed once
and the thread will then exit.

For tasks that must be repeated, the user can use a while
loop that will run repeatedly until the thread's
threadRunning is set to false via the stopThread() method.

    void MyThreadedClass::threadedFunction()
    {
        // Start the loop and continue until
        // isThreadRunning() returns false.
        while(isThreadRunning())
        {
            // Do activity repeatedly here:

            // int j = 1 + 1;

            // This while loop will run as fast as it possibly
            // can, consuming as much processor speed as it can.
            // To help the processor stay cool, users are
            // encouraged to let the while loop sleep via the
            // sleep() method, or call the yield() method to let
            // other threads have a turn.  See the sleep() and
            // yield() methods for more information.

            // sleep(100);
        }
    }





_description: _

This is the thread run function, the heart of your thread.

You need to override this in your derived class and implement your thread stuff inside. If you do not have a loop inside this function, it will run once then exit. If you want the thread to run until you signal it to stop, use a while loop inside that checks if the thread is should keep running.

Declaration in a .h file:

~~~~{.cpp}

class MyThread : public ofThread {

	...

	// the thread function
	void MyThread::threadedFunction() {
	
		// start
	
		while(isThreadRunning()) {
	
			// do stuff
		}
	
		// done
	}

};

~~~~

In the .cpp file:

~~~~{.cpp}

void ofApp::setup() {

	// create object
	MyThread thread;
	
	// start the thread
	thread.startThread(true, false);	// blocking, non verbose
}

void ofApp::update() {

	// do something else while the thread is running
}

void ofApp::exit() {
	
	// stop the thread
	thread.stopThread();
}

~~~~





&lt;!----------------------------------------------------------------------------->

###bool tryLock()

&lt;!--
_syntax: tryLock()_
_name: tryLock_
_returns: bool_
_returns_description: _
_parameters: _
_access: public_
_version_started: 0.10.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Tries to lock the mutex.

If the thread was started startThread(true), then this call will wait
until the mutex is available and return true.  If the thread was started
startThread(false), this call will return true iff the mutex is
was successfully acquired.


**Returns**: true if the lock was successfully acquired.





_description: _







&lt;!----------------------------------------------------------------------------->

###void unlock()

&lt;!--
_syntax: unlock()_
_name: unlock_
_returns: void_
_returns_description: _
_parameters: _
_access: public_
_version_started: 007_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Unlock the mutex.

This will only unlocks the mutex if it was previously by the same
calling thread.





_description: _

Unlock the mutex.

This only unlocks the mutex if the calling thread had previously locked it, otherwise the functions does nothing and does not block.





&lt;!----------------------------------------------------------------------------->

###void waitForThread(callStopThread = true, milliseconds)

&lt;!--
_syntax: waitForThread(callStopThread = true, milliseconds)_
_name: waitForThread_
_returns: void_
_returns_description: _
_parameters: bool callStopThread=true, long milliseconds_
_access: public_
_version_started: 0.8.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Wait for the thread to exit (aka "joining" the thread).

This method waits for a thread will "block" and wait for the
thread (aka "join" the thread) before it returns.  This allows the
user to be sure that the thread is properly cleaned up.  An example
of when this might be particularly important is if the
threadedFunction() is opening a set of network sockets, or
downloading data from the web.  Destroying an ofThread subclass
without releasing those sockets (or other resources), may result in
segmentation faults, error signals or other undefined behaviors.


**Parameters:**

callStopThread Set stop to true if you want to signal the thread
    to exit before waiting.  This is the equivalent to calling
    stopThread(). If you your threadedFunction uses a while-loop that
    depends on isThreadRunning() and you do not call stopThread() or set
    stop == true, waitForThread will hang indefinitely.  Set stop ==
    false ONLY if you have already called stopThread() and you simply
    need to be sure your thread has finished its tasks.


milliseconds If millseconds is set to INFINITE_JOIN_TIMEOUT, the
    waitForThread will wait indefinitely for the thread to complete.  If
    milliseconds is set to a lower number (e.g. 10000 for 10 seconds),
    waitForThread will wait for 10000 milliseconds and if the thread has
    not yet stopped it will return and log an error message.  Users are
    encouraged to use the default INFINITE_JOIN_TIMEOUT.  If the user is
    unhappy with the amount of time it takes to join a thread, the user
    is encouraged to seek more expedient ways of signalling their desire
    for a thread to complete via other signalling methods such as
    Poco::Event, Poco::Condition, or Poco::Semaphore.

**See also**: http://pocoproject.org/slides/090-NotificationsEvents.pdf

**See also**: http://pocoproject.org/docs/Poco.Condition.html

**See also**: http://pocoproject.org/docs/Poco.Event.html

**See also**: http://pocoproject.org/docs/Poco.Semaphore.html





_description: _







&lt;!----------------------------------------------------------------------------->

###void yield()

&lt;!--
_syntax: yield()_
_name: yield_
_returns: void_
_returns_description: _
_parameters: _
_access: public_
_version_started: 0071_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

Tell the thread to give up its CPU time other threads.

This method is similar to sleep() and can often be used in
the same way.  The main difference is that 1 millisecond
(the minimum sleep time available with sleep()) is a very
long time on modern processors and yield() simply gives up
processing time to the next thread, instead of waiting for
number of milliseconds. In some cases, this behavior will
be preferred.





_description: _







&lt;!----------------------------------------------------------------------------->

##Variables



###condition_variable condition

&lt;!--
_name: condition_
_type: condition_variable_
_access: private_
_version_started: 0.10.0_
_version_deprecated: _
_summary: _
_visible: True_
_constant: False_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

###ofMutex mutex

&lt;!--
_name: mutex_
_type: ofMutex_
_access: protected_
_version_started: 007_
_version_deprecated: _
_summary: _
_visible: True_
_constant: True_
_advanced: False_
-->

_inlined_description: _

The internal mutex called through lock() & unlock().

This mutext can also be used with std::unique_lock or lock_guard
within the threaded function by calling:

    std::unique_lock&lt;std::mutex> lock(mutex);





_description: _

This is the internal [mutex](http://en.wikipedia.org/wiki/Mutex) called through lock() & unlock(). You can use it manually inside your derived class.





&lt;!----------------------------------------------------------------------------->

###atomic&lt; bool > mutexBlocks

&lt;!--
_name: mutexBlocks_
_type: atomic&lt; bool >_
_access: private_
_version_started: 0.10.0_
_version_deprecated: _
_summary: _
_visible: True_
_constant: False_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

###string name

&lt;!--
_name: name_
_type: string_
_access: private_
_version_started: 0.10.0_
_version_deprecated: _
_summary: _
_visible: True_
_constant: False_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

###Poco thread

&lt;!--
_name: thread_
_type: Poco_
_access: private_
_version_started: 0071_
_version_deprecated: _
_summary: _
_visible: True_
_constant: True_
_advanced: False_
-->

_inlined_description: _

The Poco::Thread that runs the Poco::Runnable.





_description: _







&lt;!----------------------------------------------------------------------------->

###atomic&lt; bool > threadDone

&lt;!--
_name: threadDone_
_type: atomic&lt; bool >_
_access: private_
_version_started: 0.10.0_
_version_deprecated: _
_summary: _
_visible: True_
_constant: False_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

###atomic&lt; bool > threadRunning

&lt;!--
_name: threadRunning_
_type: atomic&lt; bool >_
_access: private_
_version_started: 0.10.0_
_version_deprecated: _
_summary: _
_visible: True_
_constant: False_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

</textarea></div></div></div></div></div></div><script defer src="/_nuxt/payloads/1586012716389/documentation/utils/ofThread/payload.js"></script><script src="/_nuxt/5f71eaca0bd2f1a0f939.js" defer></script><script src="/_nuxt/35a90d914f539af1362f.js" defer></script><script src="/_nuxt/906a3ca0fb13ed3c6651.js" defer></script><script src="/_nuxt/b673915e8a08acf593e8.js" defer></script><script src="/_nuxt/bf355f21967a23c26c07.js" defer></script>
  </body>
</html>
