<!doctype html>
<html data-n-head-ssr>
  <head>
    <title>ofEventUtils_functions | documentation | ofDocs</title><meta data-n-head="ssr" data-hid="description" name="description" content="openFrameworks documentation and examples browser"><meta data-n-head="ssr" data-hid="keyword" name="keyword" content=""><meta data-n-head="ssr" property="og:description" content="openFrameworks documentation and examples browser" vmid="og:description"><meta data-n-head="ssr" property="og:title" content="ofEventUtils_functions | documentation | ofDocs" vmid="og:title"><meta data-n-head="ssr" property="og:image" content="/files/images/ofw-logo.png" vmid="og:image"><link rel="preload" href="/_nuxt/3213b67383225fc2f59b.js" as="script"><link rel="preload" href="/_nuxt/5fe5bba000836bc4a25f.js" as="script"><link rel="preload" href="/_nuxt/fe12c0cb7395fa1032f4.css" as="style"><link rel="preload" href="/_nuxt/f8d94d1c92ade1d8a6da.js" as="script"><link rel="preload" href="/_nuxt/a24b354526a25539cceb.css" as="style"><link rel="preload" href="/_nuxt/9a7e20c23e9625feab77.js" as="script"><link rel="preload" href="/_nuxt/21c4d0f9583096394838.css" as="style"><link rel="preload" href="/_nuxt/d1291586b31fa28ca9d5.js" as="script"><link rel="stylesheet" href="/_nuxt/fe12c0cb7395fa1032f4.css"><link rel="stylesheet" href="/_nuxt/a24b354526a25539cceb.css"><link rel="stylesheet" href="/_nuxt/21c4d0f9583096394838.css">
  </head>
  <body>
    <div data-server-rendered="true" id="__nuxt"><!----><div id="__layout"><div id="app" class="unknown"><div id="menu"><h1 class="of"><div class="inner"><span><a href="/" class="nuxt-link-active"><div class="txt"><span class="docs f7 questrial">ofDocs </span><span class="version">0.11.0</span></div></a></span></div></h1><div id="search"><div class="inner"><div class="field text"><div class="field-inner"><svg viewbox="0 0 36 36" x="0px" y="0px" enable-background="new 0 0 36 36" xml:space="preserve"><path d="M35.525,31.228l-8.88-8.882c1.444-2.238,2.298-4.895,2.298-7.752c0-7.909-6.438-14.343-14.346-14.343						c-7.911,0-14.343,6.434-14.343,14.343c0,7.911,6.433,14.344,14.343,14.344c2.856,0,5.513-0.849,7.752-2.294l8.88,8.88						c0.295,0.297,0.782,0.297,1.076,0l3.22-3.221C35.824,32.008,35.824,31.523,35.525,31.228z M4.81,14.593						c0-5.396,4.391-9.788,9.788-9.788c5.398,0,9.787,4.392,9.787,9.788c0,5.398-4.389,9.789-9.787,9.789						C9.2,24.382,4.81,19.991,4.81,14.593z"></path></svg><!----><div class="text-wrapper"><input id="search_field" name="search_field" placeholder="Search (Alt+F)" autocomplete="off" tabindex="0"></div><!----><!----></div></div></div><div id="results" class="mt1"></div></div><div id="lists" class="menu-inner mt1"><div class="inner"><div class="item documentation"><a href="/documentation/" title="/documentation/" class="nuxt-link-active"><i class="ico" style="display:none"></i><span>documentation</span><span style="display:none">documentation</span></a><div class="list"><div class="item 3d"><a href="/documentation/3d/" title="/documentation/3d/"><i class="ico" style="display:none"></i><span style="display:none"></span><span>3d</span></a><!----></div><div class="item addons"><a href="/documentation/addons/" title="/documentation/addons/"><i class="ico" style="display:none">extension</i><span style="display:none"></span><span>addons</span></a><!----></div><div class="item application"><a href="/documentation/application/" title="/documentation/application/"><i class="ico" style="display:none">web</i><span style="display:none"></span><span>application</span></a><!----></div><div class="item communication"><a href="/documentation/communication/" title="/documentation/communication/"><i class="ico" style="display:none">language</i><span style="display:none"></span><span>communication</span></a><!----></div><div class="item events"><a href="/documentation/events/" title="/documentation/events/" class="nuxt-link-active"><i class="ico" style="display:none">question_answer</i><span style="display:none"></span><span>events</span></a><div class="list"><div class="item ofBaseEvent"><a href="/documentation/events/ofBaseEvent" title="/documentation/events/ofBaseEvent.markdown"><i class="ico" style="display:none"></i><span style="display:none"></span><span>ofBaseEvent</span></a><!----></div><div class="item ofCoreEvents"><a href="/documentation/events/ofCoreEvents" title="/documentation/events/ofCoreEvents.markdown"><i class="ico" style="display:none"></i><span style="display:none"></span><span>ofCoreEvents</span></a><!----></div><div class="item ofDragInfo"><a href="/documentation/events/ofDragInfo" title="/documentation/events/ofDragInfo.markdown"><i class="ico" style="display:none"></i><span style="display:none"></span><span>ofDragInfo</span></a><!----></div><div class="item ofEntryEventArgs"><a href="/documentation/events/ofEntryEventArgs" title="/documentation/events/ofEntryEventArgs.markdown"><i class="ico" style="display:none"></i><span style="display:none"></span><span>ofEntryEventArgs</span></a><!----></div><div class="item ofEvent"><a href="/documentation/events/ofEvent" title="/documentation/events/ofEvent.markdown"><i class="ico" style="display:none"></i><span style="display:none"></span><span>ofEvent</span></a><div class="list"></div></div><div class="item ofEventArgs"><a href="/documentation/events/ofEventArgs" title="/documentation/events/ofEventArgs.markdown"><i class="ico" style="display:none"></i><span style="display:none"></span><span>ofEventArgs</span></a><!----></div><div class="item ofEventAttendedException"><a href="/documentation/events/ofEventAttendedException" title="/documentation/events/ofEventAttendedException.markdown"><i class="ico" style="display:none"></i><span style="display:none"></span><span>ofEventAttendedException</span></a><!----></div><div class="item ofEventListener"><a href="/documentation/events/ofEventListener" title="/documentation/events/ofEventListener.markdown"><i class="ico" style="display:none"></i><span style="display:none"></span><span>ofEventListener</span></a><!----></div><div class="item ofEventListeners"><a href="/documentation/events/ofEventListeners" title="/documentation/events/ofEventListeners.markdown"><i class="ico" style="display:none"></i><span style="display:none"></span><span>ofEventListeners</span></a><!----></div><div class="item ofEvents_functions"><a href="/documentation/events/ofEvents_functions" title="/documentation/events/ofEvents_functions.markdown"><i class="ico" style="display:none"></i><span style="display:none"></span><span>ofEvents_functions</span></a><!----></div><div class="item ofEventUtils_functions"><a href="/documentation/events/ofEventUtils_functions" title="/documentation/events/ofEventUtils_functions.markdown" class="nuxt-link-exact-active nuxt-link-active"><i class="ico" style="display:none"></i><span style="display:none"></span><span>ofEventUtils_functions</span></a><div class="list"></div></div><div class="item ofFastEvent"><a href="/documentation/events/ofFastEvent" title="/documentation/events/ofFastEvent.markdown"><i class="ico" style="display:none"></i><span style="display:none"></span><span>ofFastEvent</span></a><!----></div><div class="item ofKeyEventArgs"><a href="/documentation/events/ofKeyEventArgs" title="/documentation/events/ofKeyEventArgs.markdown"><i class="ico" style="display:none"></i><span style="display:none"></span><span>ofKeyEventArgs</span></a><!----></div><div class="item ofMessage"><a href="/documentation/events/ofMessage" title="/documentation/events/ofMessage.markdown"><i class="ico" style="display:none"></i><span style="display:none"></span><span>ofMessage</span></a><!----></div><div class="item ofMouseEventArgs"><a href="/documentation/events/ofMouseEventArgs" title="/documentation/events/ofMouseEventArgs.markdown"><i class="ico" style="display:none"></i><span style="display:none"></span><span>ofMouseEventArgs</span></a><!----></div><div class="item ofResizeEventArgs"><a href="/documentation/events/ofResizeEventArgs" title="/documentation/events/ofResizeEventArgs.markdown"><i class="ico" style="display:none"></i><span style="display:none"></span><span>ofResizeEventArgs</span></a><!----></div><div class="item ofTouchEventArgs"><a href="/documentation/events/ofTouchEventArgs" title="/documentation/events/ofTouchEventArgs.markdown"><i class="ico" style="display:none"></i><span style="display:none"></span><span>ofTouchEventArgs</span></a><!----></div><div class="item ofWindowPosEventArgs"><a href="/documentation/events/ofWindowPosEventArgs" title="/documentation/events/ofWindowPosEventArgs.markdown"><i class="ico" style="display:none"></i><span style="display:none"></span><span>ofWindowPosEventArgs</span></a><!----></div></div></div><div class="item gl"><a href="/documentation/gl/" title="/documentation/gl/"><i class="ico" style="display:none"></i><span style="display:none"></span><span>gl</span></a><!----></div><div class="item glm"><a href="/documentation/glm/" title="/documentation/glm/"><i class="ico" style="display:none"></i><span style="display:none"></span><span>glm</span></a><!----></div><div class="item graphics"><a href="/documentation/graphics/" title="/documentation/graphics/"><i class="ico" style="display:none">category</i><span style="display:none"></span><span>graphics</span></a><!----></div><div class="item math"><a href="/documentation/math/" title="/documentation/math/"><i class="ico" style="display:none">border_clear</i><span style="display:none"></span><span>math</span></a><!----></div><div class="item sound"><a href="/documentation/sound/" title="/documentation/sound/"><i class="ico" style="display:none">volume_up</i><span style="display:none"></span><span>sound</span></a><!----></div><div class="item types"><a href="/documentation/types/" title="/documentation/types/"><i class="ico" style="display:none">ring_volume</i><span style="display:none"></span><span>types</span></a><!----></div><div class="item utils"><a href="/documentation/utils/" title="/documentation/utils/"><i class="ico" style="display:none">build</i><span style="display:none"></span><span>utils</span></a><!----></div><div class="item video"><a href="/documentation/video/" title="/documentation/video/"><i class="ico" style="display:none">videocam</i><span style="display:none"></span><span>video</span></a><!----></div></div></div><div class="item examples"><a href="/examples/" title="/examples/"><i class="ico" style="display:none"></i><span>examples</span><span style="display:none">examples</span></a><!----></div><div class="item openframeworks"><a href="/openframeworks/" title="/openframeworks/"><i class="ico" style="display:none"></i><span>openFrameworks</span><span style="display:none">openframeworks</span></a><!----></div><div class="item addons"><a href="/addons/" title="/addons/"><i class="ico" style="display:none">extension</i><span>addons</span><span style="display:none">addons</span></a><!----></div><div class="item guides"><a href="/guides/" title="/guides/"><i class="ico" style="display:none"></i><span>guides</span><span style="display:none">guides</span></a><!----></div></div></div></div><div id="document"><div id="renderer" class="main"><div absolute="/Users/gilbertsinnott/Code/openFrameworks/ofSite/documentation/events/ofEventUtils_functions.markdown" route="/documentation/events/ofEventUtils_functions.markdown" dir="../ofSite/documentation/events" ext="markdown" type="page" id="1934" parent="1922" siblings="" translations="[object Object]" class="doc-header"><div class="doc-header-inner"><div class="inner"><div class="mt2 mb2"><span class="breadcrumbs"><span class="crumb"><a href="/" class="pink nuxt-link-active">ofDocs</a><span class="chevron right"></span></span><span class="crumb"><a href="/documentation/" class="pink nuxt-link-active">documentation </a><!----><span class="chevron right"></span></span><span class="crumb"><a href="/documentation/events/" class="pink nuxt-link-active">events </a><!----><span class="chevron right"></span></span><span class="crumb"><!----><span class="link selector"><span>ofEventUtils_functions </span><span class="chevron bottom"></span><select><option value="/documentation/events/ofBaseEvent">ofBaseEvent</option><option value="/documentation/events/ofCoreEvents">ofCoreEvents</option><option value="/documentation/events/ofDragInfo">ofDragInfo</option><option value="/documentation/events/ofEntryEventArgs">ofEntryEventArgs</option><option value="/documentation/events/ofEvent">ofEvent</option><option value="/documentation/events/ofEventArgs">ofEventArgs</option><option value="/documentation/events/ofEventAttendedException">ofEventAttendedException</option><option value="/documentation/events/ofEventListener">ofEventListener</option><option value="/documentation/events/ofEventListeners">ofEventListeners</option><option value="/documentation/events/ofEvents_functions">ofEvents_functions</option><option value="/documentation/events/ofEventUtils_functions">ofEventUtils_functions</option><option value="/documentation/events/ofFastEvent">ofFastEvent</option><option value="/documentation/events/ofKeyEventArgs">ofKeyEventArgs</option><option value="/documentation/events/ofMessage">ofMessage</option><option value="/documentation/events/ofMouseEventArgs">ofMouseEventArgs</option><option value="/documentation/events/ofResizeEventArgs">ofResizeEventArgs</option><option value="/documentation/events/ofTouchEventArgs">ofTouchEventArgs</option><option value="/documentation/events/ofWindowPosEventArgs">ofWindowPosEventArgs</option></select></span><!----></span></span></div></div></div></div><div class="editable-wrapper"><div class="header inner"><h1 class="page-title mb4 questrial"><span class="f7"><!----><span>ofEventUtils_functions </span></span><span class="f3"></span></h1><div class="actions"><a href="/about/contribute/" class="button"><i class="ico">edit</i><span>Edit</span></a></div></div><div class="rendered"><div id="documentation-page" static="true"><div id="offset-page"><div id="doc-body" class="markdown"><div class="inner"><div id="description"><!----></div><div id="methods"><hr><section name="ofAddListener" id="ofAddListener" class="mb2"><div class="method mb2"><h3 class="f3 title">ofAddListener(<code class="pink">…</code>)</h3><code><span class="token keyword">void  </span><span class="token function">ofAddListener</span><span class="token punctuation">(</span><code class="token boolean">EventType <span class="token operator">&</span>event<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">,</span> ArgumentsType <span class="token operator">&</span><span class="token punctuation">)</span> listenerFunction<span class="token punctuation">,</span> <span class="token keyword">int</span> prio</code><span class="token punctuation">)</span></code><div class="short"></div><div class="desc"></div></div><hr></section><section name="ofAddListener" id="ofAddListener" class="mb2"><div class="method mb2"><h3 class="f3 title">ofAddListener(<code class="pink">…</code>)</h3><code><span class="token keyword">void  </span><span class="token function">ofAddListener</span><span class="token punctuation">(</span><code class="token boolean">EventType <span class="token operator">&</span>event<span class="token punctuation">,</span> <span class="token keyword">bool</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">,</span> ArgumentsType <span class="token operator">&</span><span class="token punctuation">)</span> listenerFunction<span class="token punctuation">,</span> <span class="token keyword">int</span> prio</code><span class="token punctuation">)</span></code><div class="short"></div><div class="desc"></div></div><hr></section><section name="ofAddListener" id="ofAddListener" class="mb2"><div class="method mb2"><h3 class="f3 title">ofAddListener(<code class="pink">…</code>)</h3><code><span class="token keyword">void  </span><span class="token function">ofAddListener</span><span class="token punctuation">(</span><code class="token boolean">EventType <span class="token operator">&</span>event<span class="token punctuation">,</span> ListenerClass <span class="token operator">*</span>listener<span class="token punctuation">,</span> <span class="token keyword">bool</span> <span class="token punctuation">(</span>ListenerClass<span class="token operator">::</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">,</span> ArgumentsType <span class="token operator">&</span><span class="token punctuation">)</span> listenerMethod<span class="token punctuation">,</span> <span class="token keyword">int</span> prio</code><span class="token punctuation">)</span></code><div class="short"></div><div class="desc"><p>Allows you to add a listener method to an event, use it whenever you want a class to be notified about an event.</p>
<p>This is a templated function so the types of the parameters are not predefined types but can be any type as long as the method is one of the listener class' and it has a particular signature.</p>
<p>The signature of the listener method depends on the event type. Every event is defined as:</p>
<pre><code>ofEvent<span class="token operator">&</span>lt<span class="token punctuation">;</span>type</code></pre>
</div></div><hr></section><section name="ofAddListener" id="ofAddListener" class="mb2"><div class="method mb2"><h3 class="f3 title">ofAddListener(<code class="pink">…</code>)</h3><code><span class="token keyword">void  </span><span class="token function">ofAddListener</span><span class="token punctuation">(</span><code class="token boolean">EventType <span class="token operator">&</span>event<span class="token punctuation">,</span> ListenerClass <span class="token operator">*</span>listener<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span>ListenerClass<span class="token operator">::</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">,</span> ArgumentsType <span class="token operator">&</span><span class="token punctuation">)</span> listenerMethod<span class="token punctuation">,</span> <span class="token keyword">int</span> prio</code><span class="token punctuation">)</span></code><div class="short"><p>register any method of any class to an event.</p>
<p>the method must provide one of the following
signatures:
void method(ArgumentsType & args)
void method(const void * sender, ArgumentsType &args)
ie:
ofAddListener(addon.newIntEvent, this, &Class::method)</p>
</div><div class="desc"><p>Allows you to add a listener method to an event, use it whenever you want a class to be notified about an event.</p>
<p>This is a templated function so the types of the parameters are not predefined types but can be any type as long as the method is one of the listener class' and it has a particular signature.</p>
<p>The signature of the listener method depends on the event type. Every event is defined as:</p>
<pre><code>ofEvent<span class="token operator">&</span>lt<span class="token punctuation">;</span>type</code></pre>
</div></div><hr></section><section name="ofAddListener" id="ofAddListener" class="mb2"><div class="method mb2"><h3 class="f3 title">ofAddListener(<code class="pink">…</code>)</h3><code><span class="token keyword">void  </span><span class="token function">ofAddListener</span><span class="token punctuation">(</span><code class="token boolean">EventType <span class="token operator">&</span>event<span class="token punctuation">,</span> ListenerClass <span class="token operator">*</span>listener<span class="token punctuation">,</span> <span class="token keyword">bool</span> <span class="token punctuation">(</span>ListenerClass<span class="token operator">::</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ArgumentsType <span class="token operator">&</span><span class="token punctuation">)</span> listenerMethod<span class="token punctuation">,</span> <span class="token keyword">int</span> prio</code><span class="token punctuation">)</span></code><div class="short"></div><div class="desc"><p>Allows you to add a listener method to an event, use it whenever you want a class to be notified about an event.</p>
<p>This is a templated function so the types of the parameters are not predefined types but can be any type as long as the method is one of the listener class' and it has a particular signature.</p>
<p>The signature of the listener method depends on the event type. Every event is defined as:</p>
<pre><code>ofEvent<span class="token operator">&</span>lt<span class="token punctuation">;</span>type</code></pre>
</div></div><hr></section><section name="ofAddListener" id="ofAddListener" class="mb2"><div class="method mb2"><h3 class="f3 title">ofAddListener(<code class="pink">…</code>)</h3><code><span class="token keyword">void  </span><span class="token function">ofAddListener</span><span class="token punctuation">(</span><code class="token boolean">EventType <span class="token operator">&</span>event<span class="token punctuation">,</span> ListenerClass <span class="token operator">*</span>listener<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span>ListenerClass<span class="token operator">::</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ArgumentsType <span class="token operator">&</span><span class="token punctuation">)</span> listenerMethod<span class="token punctuation">,</span> <span class="token keyword">int</span> prio</code><span class="token punctuation">)</span></code><div class="short"></div><div class="desc"><p>Allows you to add a listener method to an event, use it whenever you want a class to be notified about an event.</p>
<p>This is a templated function so the types of the parameters are not predefined types but can be any type as long as the method is one of the listener class' and it has a particular signature.</p>
<p>The signature of the listener method depends on the event type. Every event is defined as:</p>
<pre><code>ofEvent<span class="token operator">&</span>lt<span class="token punctuation">;</span>type</code></pre>
</div></div><hr></section><section name="ofAddListener" id="ofAddListener" class="mb2"><div class="method mb2"><h3 class="f3 title">ofAddListener(<code class="pink">…</code>)</h3><code><span class="token keyword">void  </span><span class="token function">ofAddListener</span><span class="token punctuation">(</span><code class="token boolean">EventType <span class="token operator">&</span>event<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ArgumentsType <span class="token operator">&</span><span class="token punctuation">)</span> listenerFunction<span class="token punctuation">,</span> <span class="token keyword">int</span> prio</code><span class="token punctuation">)</span></code><div class="short"></div><div class="desc"></div></div><hr></section><section name="ofAddListener" id="ofAddListener" class="mb2"><div class="method mb2"><h3 class="f3 title">ofAddListener(<code class="pink">…</code>)</h3><code><span class="token keyword">void  </span><span class="token function">ofAddListener</span><span class="token punctuation">(</span><code class="token boolean">EventType <span class="token operator">&</span>event<span class="token punctuation">,</span> <span class="token keyword">bool</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ArgumentsType <span class="token operator">&</span><span class="token punctuation">)</span> listenerFunction<span class="token punctuation">,</span> <span class="token keyword">int</span> prio</code><span class="token punctuation">)</span></code><div class="short"></div><div class="desc"></div></div><hr></section><section name="ofNotifyEvent" id="ofNotifyEvent" class="mb2"><div class="method mb2"><h3 class="f3 title">ofNotifyEvent(<code class="pink">…</code>)</h3><code><span class="token keyword">bool  </span><span class="token function">ofNotifyEvent</span><span class="token punctuation">(</span><code class="token boolean">EventType <span class="token operator">&</span>event<span class="token punctuation">,</span> <span class="token keyword">const</span> ArgumentsType <span class="token operator">&</span>args</code><span class="token punctuation">)</span></code><div class="short"></div><div class="desc"><p>Notifies an event, what makes all it's registered method listeners to be called with the same argument.</p>
<p>This is a templated function so the type of the parameters is not predefined and can be anything as long as the listener methods use the same type for the parameter.</p>
<p>The arguments are passed to the listeners by reference so they can modify them.</p>
<p>The listener methods are called in the same order they were registered using ofAddListener.</p>
<p>With this version the listeners also receive a pointer to the notifying class in case the listener method specifies that parameter.</p>
<p>For instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:</p>
<pre><code>
<span class="token keyword">class</span> <span class="token class-name">SimpleEventNotifier</span> <span class="token punctuation">{</span>
	ofEvent<span class="token operator">&</span>lt<span class="token punctuation">;</span><span class="token keyword">float</span></code></pre>
</div></div><hr></section><section name="ofNotifyEvent" id="ofNotifyEvent" class="mb2"><div class="method mb2"><h3 class="f3 title">ofNotifyEvent(<code class="pink">…</code>)</h3><code><span class="token keyword">bool  </span><span class="token function">ofNotifyEvent</span><span class="token punctuation">(</span><code class="token boolean">EventType <span class="token operator">&</span>event<span class="token punctuation">,</span> ArgumentsType <span class="token operator">&</span>args</code><span class="token punctuation">)</span></code><div class="short"></div><div class="desc"><p>Notifies an event, what makes all it's registered method listeners to be called with the same argument.</p>
<p>This is a templated function so the type of the parameters is not predefined and can be anything as long as the listener methods use the same type for the parameter.</p>
<p>The arguments are passed to the listeners by reference so they can modify them.</p>
<p>The listener methods are called in the same order they were registered using ofAddListener.</p>
<p>With this version the listeners also receive a pointer to the notifying class in case the listener method specifies that parameter.</p>
<p>For instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:</p>
<pre><code>
<span class="token keyword">class</span> <span class="token class-name">SimpleEventNotifier</span> <span class="token punctuation">{</span>
	ofEvent<span class="token operator">&</span>lt<span class="token punctuation">;</span><span class="token keyword">float</span></code></pre>
</div></div><hr></section><section name="ofNotifyEvent" id="ofNotifyEvent" class="mb2"><div class="method mb2"><h3 class="f3 title">ofNotifyEvent(<code class="pink">…</code>)</h3><code><span class="token keyword">bool  </span><span class="token function">ofNotifyEvent</span><span class="token punctuation">(</span><code class="token boolean">EventType <span class="token operator">&</span>event<span class="token punctuation">,</span> <span class="token keyword">const</span> ArgumentsType <span class="token operator">&</span>args<span class="token punctuation">,</span> SenderType <span class="token operator">*</span>sender</code><span class="token punctuation">)</span></code><div class="short"></div><div class="desc"><p>Notifies an event, what makes all it's registered method listeners to be called with the same argument.</p>
<p>This is a templated function so the type of the parameters is not predefined and can be anything as long as the listener methods use the same type for the parameter.</p>
<p>The arguments are passed to the listeners by reference so they can modify them.</p>
<p>The listener methods are called in the same order they were registered using ofAddListener.</p>
<p>With this version the listeners also receive an event args object that can be used to send additional data to the listening class.</p>
<p>For instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:</p>
<pre><code>
<span class="token keyword">class</span> <span class="token class-name">SimpleEventNotifier</span> <span class="token punctuation">{</span>
	ofEvent<span class="token operator">&</span>lt<span class="token punctuation">;</span><span class="token keyword">float</span></code></pre>
</div></div><hr></section><section name="ofNotifyEvent" id="ofNotifyEvent" class="mb2"><div class="method mb2"><h3 class="f3 title">ofNotifyEvent(<code class="pink">…</code>)</h3><code><span class="token keyword">bool  </span><span class="token function">ofNotifyEvent</span><span class="token punctuation">(</span><code class="token boolean">EventType <span class="token operator">&</span>event<span class="token punctuation">,</span> ArgumentsType <span class="token operator">&</span>args<span class="token punctuation">,</span> SenderType <span class="token operator">*</span>sender</code><span class="token punctuation">)</span></code><div class="short"><p>notifies an event so all the registered listeners
get called</p>
<p>ie:
ofNotifyEvent(addon.newIntEvent, intArgument, this)</p>
<p>or in case there's no sender:
ofNotifyEvent(addon.newIntEvent, intArgument)</p>
<p>@returns: true in case any listener attended the event</p>
</div><div class="desc"><p>Notifies an event, what makes all it's registered method listeners to be called with the same argument.</p>
<p>This is a templated function so the type of the parameters is not predefined and can be anything as long as the listener methods use the same type for the parameter.</p>
<p>The arguments are passed to the listeners by reference so they can modify them.</p>
<p>The listener methods are called in the same order they were registered using ofAddListener.</p>
<p>For instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:</p>
<pre><code>
<span class="token keyword">class</span> <span class="token class-name">SimpleEventNotifier</span> <span class="token punctuation">{</span>
	ofEvent notify<span class="token punctuation">;</span>	<span class="token comment" spellcheck="true">// will send an event with no data</span>

	<span class="token keyword">void</span> <span class="token function">sendEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">ofNotifyEvent</span><span class="token punctuation">(</span>notify<span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token punctuation">}</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre>
<p>We can listen for that in our ofApp:</p>
<pre><code>SimpleEventNotifier notifier<span class="token punctuation">;</span>
<span class="token keyword">void</span> ofApp<span class="token operator">::</span><span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">ofAddListener</span><span class="token punctuation">(</span>notifier<span class="token punctuation">.</span>notify<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">&</span>amp<span class="token punctuation">;</span>ofApp<span class="token operator">::</span>haveBeenNotified<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> ofApp<span class="token operator">::</span><span class="token function">haveBeenNotified</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">ofLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&</span>lt<span class="token punctuation">;</span><span class="token operator">&</span>lt<span class="token punctuation">;</span> <span class="token operator">&</span>quot<span class="token punctuation">;</span> event at <span class="token operator">&</span>quot<span class="token punctuation">;</span> <span class="token operator">&</span>lt<span class="token punctuation">;</span><span class="token operator">&</span>lt<span class="token punctuation">;</span> <span class="token function">ofGetElapsedTimef</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&</span>lt<span class="token punctuation">;</span><span class="token operator">&</span>lt<span class="token punctuation">;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre>
</div></div><hr></section><section name="ofRemoveListener" id="ofRemoveListener" class="mb2"><div class="method mb2"><h3 class="f3 title">ofRemoveListener(<code class="pink">…</code>)</h3><code><span class="token keyword">void  </span><span class="token function">ofRemoveListener</span><span class="token punctuation">(</span><code class="token boolean">EventType <span class="token operator">&</span>event<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">,</span> ArgumentsType <span class="token operator">&</span><span class="token punctuation">)</span> listenerFunction<span class="token punctuation">,</span> <span class="token keyword">int</span> prio</code><span class="token punctuation">)</span></code><div class="short"></div><div class="desc"></div></div><hr></section><section name="ofRemoveListener" id="ofRemoveListener" class="mb2"><div class="method mb2"><h3 class="f3 title">ofRemoveListener(<code class="pink">…</code>)</h3><code><span class="token keyword">void  </span><span class="token function">ofRemoveListener</span><span class="token punctuation">(</span><code class="token boolean">EventType <span class="token operator">&</span>event<span class="token punctuation">,</span> <span class="token keyword">bool</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">,</span> ArgumentsType <span class="token operator">&</span><span class="token punctuation">)</span> listenerFunction<span class="token punctuation">,</span> <span class="token keyword">int</span> prio</code><span class="token punctuation">)</span></code><div class="short"></div><div class="desc"></div></div><hr></section><section name="ofRemoveListener" id="ofRemoveListener" class="mb2"><div class="method mb2"><h3 class="f3 title">ofRemoveListener(<code class="pink">…</code>)</h3><code><span class="token keyword">void  </span><span class="token function">ofRemoveListener</span><span class="token punctuation">(</span><code class="token boolean">EventType <span class="token operator">&</span>event<span class="token punctuation">,</span> ListenerClass <span class="token operator">*</span>listener<span class="token punctuation">,</span> <span class="token keyword">bool</span> <span class="token punctuation">(</span>ListenerClass<span class="token operator">::</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">,</span> ArgumentsType <span class="token operator">&</span><span class="token punctuation">)</span> listenerMethod<span class="token punctuation">,</span> <span class="token keyword">int</span> prio</code><span class="token punctuation">)</span></code><div class="short"></div><div class="desc"><p>Removes a listener method from an event. Use it whenever you want a class to stop being notified about an event after having registered it to the method with ofAddListener.</p>
<p>Don't forget to call this before deleting any instance that is listening to an event, if not the event will try to notify a non existent instance and the application will crash.</p>
<p>The syntax is just the same as that of ofAddListener.</p>
</div></div><hr></section><section name="ofRemoveListener" id="ofRemoveListener" class="mb2"><div class="method mb2"><h3 class="f3 title">ofRemoveListener(<code class="pink">…</code>)</h3><code><span class="token keyword">void  </span><span class="token function">ofRemoveListener</span><span class="token punctuation">(</span><code class="token boolean">EventType <span class="token operator">&</span>event<span class="token punctuation">,</span> ListenerClass <span class="token operator">*</span>listener<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span>ListenerClass<span class="token operator">::</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">,</span> ArgumentsType <span class="token operator">&</span><span class="token punctuation">)</span> listenerMethod<span class="token punctuation">,</span> <span class="token keyword">int</span> prio</code><span class="token punctuation">)</span></code><div class="short"><p>unregister any method of any class to an event.</p>
<p>the method must provide one the following
signatures:
void method(ArgumentsType & args)
void method(const void * sender, ArgumentsType &args)
ie:
ofAddListener(addon.newIntEvent, this, &Class::method)</p>
</div><div class="desc"><p>Removes a listener method from an event. Use it whenever you want a class to stop being notified about an event after having registered it to the method with ofAddListener.</p>
<p>Don't forget to call this before deleting any instance that is listening to an event, if not the event will try to notify a non existent instance and the application will crash.</p>
<p>The syntax is just the same as that of ofAddListener.</p>
</div></div><hr></section><section name="ofRemoveListener" id="ofRemoveListener" class="mb2"><div class="method mb2"><h3 class="f3 title">ofRemoveListener(<code class="pink">…</code>)</h3><code><span class="token keyword">void  </span><span class="token function">ofRemoveListener</span><span class="token punctuation">(</span><code class="token boolean">EventType <span class="token operator">&</span>event<span class="token punctuation">,</span> ListenerClass <span class="token operator">*</span>listener<span class="token punctuation">,</span> <span class="token keyword">bool</span> <span class="token punctuation">(</span>ListenerClass<span class="token operator">::</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ArgumentsType <span class="token operator">&</span><span class="token punctuation">)</span> listenerMethod<span class="token punctuation">,</span> <span class="token keyword">int</span> prio</code><span class="token punctuation">)</span></code><div class="short"></div><div class="desc"><p>Removes a listener method from an event. Use it whenever you want a class to stop being notified about an event after having registered it to the method with ofAddListener.</p>
<p>Don't forget to call this before deleting any instance that is listening to an event, if not the event will try to notify a non existent instance and the application will crash.</p>
<p>The syntax is just the same as that of ofAddListener.</p>
</div></div><hr></section><section name="ofRemoveListener" id="ofRemoveListener" class="mb2"><div class="method mb2"><h3 class="f3 title">ofRemoveListener(<code class="pink">…</code>)</h3><code><span class="token keyword">void  </span><span class="token function">ofRemoveListener</span><span class="token punctuation">(</span><code class="token boolean">EventType <span class="token operator">&</span>event<span class="token punctuation">,</span> ListenerClass <span class="token operator">*</span>listener<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span>ListenerClass<span class="token operator">::</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ArgumentsType <span class="token operator">&</span><span class="token punctuation">)</span> listenerMethod<span class="token punctuation">,</span> <span class="token keyword">int</span> prio</code><span class="token punctuation">)</span></code><div class="short"></div><div class="desc"><p>Removes a listener method from an event. Use it whenever you want a class to stop being notified about an event after having registered it to the method with ofAddListener.</p>
<p>Don't forget to call this before deleting any instance that is listening to an event, if not the event will try to notify a non existent instance and the application will crash.</p>
<p>The syntax is just the same as that of ofAddListener.</p>
</div></div><hr></section><section name="ofRemoveListener" id="ofRemoveListener" class="mb2"><div class="method mb2"><h3 class="f3 title">ofRemoveListener(<code class="pink">…</code>)</h3><code><span class="token keyword">void  </span><span class="token function">ofRemoveListener</span><span class="token punctuation">(</span><code class="token boolean">EventType <span class="token operator">&</span>event<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ArgumentsType <span class="token operator">&</span><span class="token punctuation">)</span> listenerFunction<span class="token punctuation">,</span> <span class="token keyword">int</span> prio</code><span class="token punctuation">)</span></code><div class="short"></div><div class="desc"></div></div><hr></section><section name="ofRemoveListener" id="ofRemoveListener" class="mb2"><div class="method mb2"><h3 class="f3 title">ofRemoveListener(<code class="pink">…</code>)</h3><code><span class="token keyword">void  </span><span class="token function">ofRemoveListener</span><span class="token punctuation">(</span><code class="token boolean">EventType <span class="token operator">&</span>event<span class="token punctuation">,</span> <span class="token keyword">bool</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ArgumentsType <span class="token operator">&</span><span class="token punctuation">)</span> listenerFunction<span class="token punctuation">,</span> <span class="token keyword">int</span> prio</code><span class="token punctuation">)</span></code><div class="short"></div><div class="desc"></div></div><hr></section></div></div></div></div><div id="side-menu" class="markdown"><!----><div id="methods-list"><h4>Methods</h4><div class="anchor"><code><a href="#ofAddListener">ofAddListener</a></code></div><div class="anchor"><code><a href="#ofAddListener">ofAddListener</a></code></div><div class="anchor"><code><a href="#ofAddListener" class="pink">ofAddListener</a></code></div><div class="anchor"><code><a href="#ofAddListener" class="pink">ofAddListener</a></code></div><div class="anchor"><code><a href="#ofAddListener" class="pink">ofAddListener</a></code></div><div class="anchor"><code><a href="#ofAddListener" class="pink">ofAddListener</a></code></div><div class="anchor"><code><a href="#ofAddListener">ofAddListener</a></code></div><div class="anchor"><code><a href="#ofAddListener">ofAddListener</a></code></div><div class="anchor"><code><a href="#ofNotifyEvent" class="pink">ofNotifyEvent</a></code></div><div class="anchor"><code><a href="#ofNotifyEvent" class="pink">ofNotifyEvent</a></code></div><div class="anchor"><code><a href="#ofNotifyEvent" class="pink">ofNotifyEvent</a></code></div><div class="anchor"><code><a href="#ofNotifyEvent" class="pink">ofNotifyEvent</a></code></div><div class="anchor"><code><a href="#ofRemoveListener">ofRemoveListener</a></code></div><div class="anchor"><code><a href="#ofRemoveListener">ofRemoveListener</a></code></div><div class="anchor"><code><a href="#ofRemoveListener" class="pink">ofRemoveListener</a></code></div><div class="anchor"><code><a href="#ofRemoveListener" class="pink">ofRemoveListener</a></code></div><div class="anchor"><code><a href="#ofRemoveListener" class="pink">ofRemoveListener</a></code></div><div class="anchor"><code><a href="#ofRemoveListener" class="pink">ofRemoveListener</a></code></div><div class="anchor"><code><a href="#ofRemoveListener">ofRemoveListener</a></code></div><div class="anchor"><code><a href="#ofRemoveListener">ofRemoveListener</a></code></div></div><div id="see-also" filename="ofEventUtils_functions.markdown" absolute="/Users/gilbertsinnott/Code/openFrameworks/ofSite/documentation/events/ofEventUtils_functions.markdown" route="/documentation/events/ofEventUtils_functions.markdown" dir="../ofSite/documentation/events" ext="markdown" type="page" parent="1922" breadcrumbs="1922,1718" siblings="" translations="[object Object]" class="see-also"><h4>See also</h4><div class="also"><a href="/documentation/events/ofEvent"><span class="origin">documentation</span><span class="name">ofEvent</span></a></div></div></div></div></div><textarea rows="0" class="markdown-editor" style="display:none">#functions


&lt;!--
_visible: True_
_advanced: False_
-->

##Description






&lt;!----------------------------------------------------------------------------->

###void ofAddListener(&event, *, listenerFunction, prio)

&lt;!--
_syntax: ofAddListener(&event, *, listenerFunction, prio)_
_name: ofAddListener_
_returns: void_
_returns_description: _
_parameters: EventType &event, void (*)(const void *, ArgumentsType &) listenerFunction, int prio_
_version_started: 0.9.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

###void ofAddListener(&event, *, listenerFunction, prio)

&lt;!--
_syntax: ofAddListener(&event, *, listenerFunction, prio)_
_name: ofAddListener_
_returns: void_
_returns_description: _
_parameters: EventType &event, bool (*)(const void *, ArgumentsType &) listenerFunction, int prio_
_version_started: 0.9.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

###void ofAddListener(&event, *listener, *, listenerMethod, prio)

&lt;!--
_syntax: ofAddListener(&event, *listener, *, listenerMethod, prio)_
_name: ofAddListener_
_returns: void_
_returns_description: _
_parameters: EventType &event, ListenerClass *listener, bool (ListenerClass::*)(const void *, ArgumentsType &) listenerMethod, int prio_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _

Allows you to add a listener method to an event, use it whenever you want a class to be notified about an event.

This is a templated function so the types of the parameters are not predefined types but can be any type as long as the method is one of the listener class' and it has a particular signature.

The signature of the listener method depends on the event type. Every event is defined as:

~~~~{.cpp}
ofEvent&lt;type> event;
~~~~

where type is the type of the parameter that is going to be passed when the event is notified. The listener method can have one of this two signatures:

~~~~{.cpp}
void listenerMethod(type & parameter);
~~~~

~~~~{.cpp}
void listenerMethod(const void * sender, type parameter);
~~~~

Where type must be the same as that of the event it listens to, and sender will be a pointer to the notifying class.

For instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:

~~~~{.cpp}

class SimpleEventNotifier {
	ofEvent&lt;float> notify;	// will send an event with a float

	void sendEvent() {
		ofNotifyEvent(notify, ofGetElapsedTimef(), this); 
	}

};

~~~~

We can listen for that in our ofApp:

~~~~{.cpp}
SimpleEventNotifier notifier;
void ofApp::setup() {
	ofAddListener(notifier.notify, this, &ofApp::haveBeenNotified);
}

void ofApp::haveBeenNotified(float &f){
    ofLog() &lt;&lt; " event at " &lt;&lt; f &lt;&lt; endl;
}

~~~~

The general pattern is:

A notifying class that will notify defines an ofEvent.
A listening class that will listen for that ofEvent calls ofAddListener() using the name of the event, the "this" keyword to refer to itself, and a pointer to the method that you want called when the event occurs
The notifying class calls ofNotifyEvent() when it's time to send the event.
The listening class has its notification method called with the parameters of the ofEvent passed to it.

This version of the method allows you to use the prio to set whether the event should be called before the application events (mouse and key events, for example) with OF_EVENT_ORDER_BEFORE_APP or after with OF_EVENT_ORDER_AFTER_APP.





&lt;!----------------------------------------------------------------------------->

###void ofAddListener(&event, *listener, *, listenerMethod, prio)

&lt;!--
_syntax: ofAddListener(&event, *listener, *, listenerMethod, prio)_
_name: ofAddListener_
_returns: void_
_returns_description: _
_parameters: EventType &event, ListenerClass *listener, void (ListenerClass::*)(const void *, ArgumentsType &) listenerMethod, int prio_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

register any method of any class to an event.

the method must provide one of the following
signatures:
    void method(ArgumentsType & args)
    void method(const void * sender, ArgumentsType &args)
ie:
    ofAddListener(addon.newIntEvent, this, &Class::method)





_description: _

Allows you to add a listener method to an event, use it whenever you want a class to be notified about an event.

This is a templated function so the types of the parameters are not predefined types but can be any type as long as the method is one of the listener class' and it has a particular signature.

The signature of the listener method depends on the event type. Every event is defined as:

~~~~{.cpp}
ofEvent&lt;type> event;
~~~~

where type is the type of the parameter that is going to be passed when the event is notified. The listener method can have one of this two signatures:

~~~~{.cpp}
void listenerMethod(type & parameter);
~~~~

~~~~{.cpp}
void listenerMethod(const void * sender, type parameter);
~~~~

Where type must be the same as that of the event it listens to, and sender will be a pointer to the notifying class.

For instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:

~~~~{.cpp}

class SimpleEventNotifier {
	ofEvent&lt;float> notify;	// will send an event with a float

	void sendEvent() {
		ofNotifyEvent(notify, ofGetElapsedTimef(), this); 
	}

};

~~~~

We can listen for that in our ofApp:

~~~~{.cpp}
SimpleEventNotifier notifier;
void ofApp::setup() {
	ofAddListener(notifier.notify, this, &ofApp::haveBeenNotified);
}

void ofApp::haveBeenNotified(float &f){
    ofLog() &lt;&lt; " event at " &lt;&lt; f &lt;&lt; endl;
}

~~~~

The general pattern is:

A notifying class that will notify defines an ofEvent.
A listening class that will listen for that ofEvent calls ofAddListener() using the name of the event, the "this" keyword to refer to itself, and a pointer to the method that you want called when the event occurs
The notifying class calls ofNotifyEvent() when it's time to send the event.
The listening class has its notification method called with the parameters of the ofEvent passed to it.

This version of the method allows you to use the prio to set whether the event should be called before the application events (mouse and key events, for example) with OF_EVENT_ORDER_BEFORE_APP or after with OF_EVENT_ORDER_AFTER_APP.





&lt;!----------------------------------------------------------------------------->

###void ofAddListener(&event, *listener, listenerMethod, prio)

&lt;!--
_syntax: ofAddListener(&event, *listener, listenerMethod, prio)_
_name: ofAddListener_
_returns: void_
_returns_description: _
_parameters: ofEvent&lt; void > &event, ListenerClass *listener, bool (ListenerClass::*)() listenerMethod, int prio_
_version_started: 0.06_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _

Allows you to add a listener method to an event, use it whenever you want a class to be notified about an event.

This is a templated function so the types of the parameters are not predefined types but can be any type as long as the method is one of the listener class' and it has a particular signature.

The signature of the listener method depends on the event type. Every event is defined as:

~~~~{.cpp}
ofEvent&lt;type> event;
~~~~

where type is the type of the parameter that is going to be passed when the event is notified. The listener method can have one of this two signatures:

~~~~{.cpp}
void listenerMethod(type & parameter);
~~~~

~~~~{.cpp}
void listenerMethod(const void * sender, type parameter);
~~~~

Where type must be the same as that of the event it listens to, and sender will be a pointer to the notifying class.

For instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:

~~~~{.cpp}

class SimpleEventNotifier {
	ofEvent&lt;float> notify;	// will send an event with a float

	void sendEvent() {
		ofNotifyEvent(notify, ofGetElapsedTimef(), this); 
	}

};

~~~~

We can listen for that in our ofApp:

~~~~{.cpp}
SimpleEventNotifier notifier;
void ofApp::setup() {
	ofAddListener(notifier.notify, this, &ofApp::haveBeenNotified);
}

void ofApp::haveBeenNotified(float &f){
    ofLog() &lt;&lt; " event at " &lt;&lt; f &lt;&lt; endl;
}

~~~~

The general pattern is:

A notifying class that will notify defines an ofEvent.
A listening class that will listen for that ofEvent calls ofAddListener() using the name of the event, the "this" keyword to refer to itself, and a pointer to the method that you want called when the event occurs
The notifying class calls ofNotifyEvent() when it's time to send the event.
The listening class has its notification method called with the parameters of the ofEvent passed to it.





&lt;!----------------------------------------------------------------------------->

###void ofAddListener(&event, *listener, listenerMethod, prio)

&lt;!--
_syntax: ofAddListener(&event, *listener, listenerMethod, prio)_
_name: ofAddListener_
_returns: void_
_returns_description: _
_parameters: ofEvent&lt; void > &event, ListenerClass *listener, bool (ListenerClass::*)(const void *) listenerMethod, int prio_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _

Allows you to add a listener method to an event, use it whenever you want a class to be notified about an event.

This is a templated function so the types of the parameters are not predefined types but can be any type as long as the method is one of the listener class' and it has a particular signature.

The signature of the listener method depends on the event type. Every event is defined as:

~~~~{.cpp}
ofEvent&lt;type> event;
~~~~

where type is the type of the parameter that is going to be passed when the event is notified. The listener method can have one of this two signatures:

~~~~{.cpp}
void listenerMethod(type & parameter);
~~~~

~~~~{.cpp}
void listenerMethod(const void * sender, type parameter);
~~~~

Where type must be the same as that of the event it listens to, and sender will be a pointer to the notifying class.

For instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:

~~~~{.cpp}

class SimpleEventNotifier {
	ofEvent&lt;float> notify;	// will send an event with a float

	void sendEvent() {
		ofNotifyEvent(notify, ofGetElapsedTimef(), this); 
	}

};

~~~~

We can listen for that in our ofApp:

~~~~{.cpp}
SimpleEventNotifier notifier;
void ofApp::setup() {
	ofAddListener(notifier.notify, this, &ofApp::haveBeenNotified);
}

void ofApp::haveBeenNotified(float &f){
    ofLog() &lt;&lt; " event at " &lt;&lt; f &lt;&lt; endl;
}

~~~~

The general pattern is:

A notifying class that will notify defines an ofEvent.
A listening class that will listen for that ofEvent calls ofAddListener() using the name of the event, the "this" keyword to refer to itself, and a pointer to the method that you want called when the event occurs
The notifying class calls ofNotifyEvent() when it's time to send the event.
The listening class has its notification method called with the parameters of the ofEvent passed to it.

Note that the event is a reference, which means it needs to a member of your class that will not go away in the lifetime of the object.

This version of the method allows you to use the prio to set whether the event should be called before the application events (mouse and key events, for example) with OF_EVENT_ORDER_BEFORE_APP or after with OF_EVENT_ORDER_AFTER_APP.





&lt;!----------------------------------------------------------------------------->

###void ofAddListener(&event, *listener, listenerMethod, prio)

&lt;!--
_syntax: ofAddListener(&event, *listener, listenerMethod, prio)_
_name: ofAddListener_
_returns: void_
_returns_description: _
_parameters: EventType &event, ListenerClass *listener, bool (ListenerClass::*)(ArgumentsType &) listenerMethod, int prio_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _

Allows you to add a listener method to an event, use it whenever you want a class to be notified about an event.

This is a templated function so the types of the parameters are not predefined types but can be any type as long as the method is one of the listener class' and it has a particular signature.

The signature of the listener method depends on the event type. Every event is defined as:

~~~~{.cpp}
ofEvent&lt;type> event;
~~~~

where type is the type of the parameter that is going to be passed when the event is notified. The listener method can have one of this two signatures:

~~~~{.cpp}
void listenerMethod(type & parameter);
~~~~

~~~~{.cpp}
void listenerMethod(const void * sender, type parameter);
~~~~

Where type must be the same as that of the event it listens to, and sender will be a pointer to the notifying class.

For instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:

~~~~{.cpp}

class SimpleEventNotifier {
	ofEvent&lt;float> notify;	// will send an event with a float

	void sendEvent() {
		ofNotifyEvent(notify, ofGetElapsedTimef(), this); 
	}

};

~~~~

We can listen for that in our ofApp:

~~~~{.cpp}
SimpleEventNotifier notifier;
void ofApp::setup() {
	ofAddListener(notifier.notify, this, &ofApp::haveBeenNotified);
}

void ofApp::haveBeenNotified(float &f){
    ofLog() &lt;&lt; " event at " &lt;&lt; f &lt;&lt; endl;
}

~~~~

The general pattern is:

A notifying class that will notify defines an ofEvent.
A listening class that will listen for that ofEvent calls ofAddListener() using the name of the event, the "this" keyword to refer to itself, and a pointer to the method that you want called when the event occurs
The notifying class calls ofNotifyEvent() when it's time to send the event.
The listening class has its notification method called with the parameters of the ofEvent passed to it.

This version of the method allows you to use the prio to set whether the event should be called before the application events (mouse and key events, for example) with OF_EVENT_ORDER_BEFORE_APP or after with OF_EVENT_ORDER_AFTER_APP.





&lt;!----------------------------------------------------------------------------->

###void ofAddListener(&event, *listener, listenerMethod, prio)

&lt;!--
_syntax: ofAddListener(&event, *listener, listenerMethod, prio)_
_name: ofAddListener_
_returns: void_
_returns_description: _
_parameters: ofEvent&lt; void > &event, ListenerClass *listener, void (ListenerClass::*)() listenerMethod, int prio_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _

Allows you to add a listener method to an event, use it whenever you want a class to be notified about an event.

This is a templated function so the types of the parameters are not predefined types but can be any type as long as the method is one of the listener class' and it has a particular signature.

The signature of the listener method depends on the event type. Every event is defined as:

~~~~{.cpp}
ofEvent&lt;type> event;
~~~~

where type is the type of the parameter that is going to be passed when the event is notified. The listener method can have one of this two signatures:

~~~~{.cpp}
void listenerMethod(type & parameter);
~~~~

~~~~{.cpp}
void listenerMethod(const void * sender, type parameter);
~~~~

Where type must be the same as that of the event it listens to, and sender will be a pointer to the notifying class.

For instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:

~~~~{.cpp}

class SimpleEventNotifier {
	ofEvent&lt;float> notify;	// will send an event with a float

	void sendEvent() {
		ofNotifyEvent(notify, ofGetElapsedTimef(), this); 
	}

};

~~~~

We can listen for that in our ofApp:

~~~~{.cpp}
SimpleEventNotifier notifier;
void ofApp::setup() {
	ofAddListener(notifier.notify, this, &ofApp::haveBeenNotified);
}

void ofApp::haveBeenNotified(float &f){
    ofLog() &lt;&lt; " event at " &lt;&lt; f &lt;&lt; endl;
}

~~~~

The general pattern is:

A notifying class that will notify defines an ofEvent.
A listening class that will listen for that ofEvent calls ofAddListener() using the name of the event, the "this" keyword to refer to itself, and a pointer to the method that you want called when the event occurs
The notifying class calls ofNotifyEvent() when it's time to send the event.
The listening class has its notification method called with the parameters of the ofEvent passed to it.

This version of the method allows you to use the prio to set whether the event should be called before the application events (mouse and key events, for example) with OF_EVENT_ORDER_BEFORE_APP or after with OF_EVENT_ORDER_AFTER_APP.





&lt;!----------------------------------------------------------------------------->

###void ofAddListener(&event, *listener, listenerMethod, prio)

&lt;!--
_syntax: ofAddListener(&event, *listener, listenerMethod, prio)_
_name: ofAddListener_
_returns: void_
_returns_description: _
_parameters: ofEvent&lt; void > &event, ListenerClass *listener, void (ListenerClass::*)(const void *) listenerMethod, int prio_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _

Allows you to add a listener method to an event, use it whenever you want a class to be notified about an event.

This is a templated function so the types of the parameters are not predefined types but can be any type as long as the method is one of the listener class' and it has a particular signature.

The signature of the listener method depends on the event type. Every event is defined as:

~~~~{.cpp}
ofEvent&lt;type> event;
~~~~

where type is the type of the parameter that is going to be passed when the event is notified. The listener method can have one of this two signatures:

~~~~{.cpp}
void listenerMethod(type & parameter);
~~~~

~~~~{.cpp}
void listenerMethod(const void * sender, type parameter);
~~~~

Where type must be the same as that of the event it listens to, and sender will be a pointer to the notifying class.

For instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:

~~~~{.cpp}

class SimpleEventNotifier {
	ofEvent&lt;float> notify;	// will send an event with a float

	void sendEvent() {
		ofNotifyEvent(notify, ofGetElapsedTimef(), this); 
	}

};

~~~~

We can listen for that in our ofApp:

~~~~{.cpp}
SimpleEventNotifier notifier;
void ofApp::setup() {
	ofAddListener(notifier.notify, this, &ofApp::haveBeenNotified);
}

void ofApp::haveBeenNotified(float &f){
    ofLog() &lt;&lt; " event at " &lt;&lt; f &lt;&lt; endl;
}

~~~~

The general pattern is:

A notifying class that will notify defines an ofEvent.
A listening class that will listen for that ofEvent calls ofAddListener() using the name of the event, the "this" keyword to refer to itself, and a pointer to the method that you want called when the event occurs
The notifying class calls ofNotifyEvent() when it's time to send the event.
The listening class has its notification method called with the parameters of the ofEvent passed to it.

This version of the method allows you to use the prio to set whether the event should be called before the application events (mouse and key events, for example) with OF_EVENT_ORDER_BEFORE_APP or after with OF_EVENT_ORDER_AFTER_APP.





&lt;!----------------------------------------------------------------------------->

###void ofAddListener(&event, *listener, listenerMethod, prio)

&lt;!--
_syntax: ofAddListener(&event, *listener, listenerMethod, prio)_
_name: ofAddListener_
_returns: void_
_returns_description: _
_parameters: EventType &event, ListenerClass *listener, void (ListenerClass::*)(ArgumentsType &) listenerMethod, int prio_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _

Allows you to add a listener method to an event, use it whenever you want a class to be notified about an event.

This is a templated function so the types of the parameters are not predefined types but can be any type as long as the method is one of the listener class' and it has a particular signature.

The signature of the listener method depends on the event type. Every event is defined as:

~~~~{.cpp}
ofEvent&lt;type> event;
~~~~

where type is the type of the parameter that is going to be passed when the event is notified. The listener method can have one of this two signatures:

~~~~{.cpp}
void listenerMethod(type & parameter);
~~~~

~~~~{.cpp}
void listenerMethod(const void * sender, type parameter);
~~~~

Where type must be the same as that of the event it listens to, and sender will be a pointer to the notifying class.

For instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:

~~~~{.cpp}

class SimpleEventNotifier {
	ofEvent&lt;float> notify;	// will send an event with a float

	void sendEvent() {
		ofNotifyEvent(notify, ofGetElapsedTimef(), this); 
	}

};

~~~~

We can listen for that in our ofApp:

~~~~{.cpp}
SimpleEventNotifier notifier;
void ofApp::setup() {
	ofAddListener(notifier.notify, this, &ofApp::haveBeenNotified);
}

void ofApp::haveBeenNotified(float &f){
    ofLog() &lt;&lt; " event at " &lt;&lt; f &lt;&lt; endl;
}

~~~~

The general pattern is:

A notifying class that will notify defines an ofEvent.
A listening class that will listen for that ofEvent calls ofAddListener() using the name of the event, the "this" keyword to refer to itself, and a pointer to the method that you want called when the event occurs
The notifying class calls ofNotifyEvent() when it's time to send the event.
The listening class has its notification method called with the parameters of the ofEvent passed to it.

This version of the method allows you to use the prio to set whether the event should be called before the application events (mouse and key events, for example) with OF_EVENT_ORDER_BEFORE_APP or after with OF_EVENT_ORDER_AFTER_APP.





&lt;!----------------------------------------------------------------------------->

###void ofAddListener(&event, listenerFunction, prio)

&lt;!--
_syntax: ofAddListener(&event, listenerFunction, prio)_
_name: ofAddListener_
_returns: void_
_returns_description: _
_parameters: EventType &event, void (*)(ArgumentsType &) listenerFunction, int prio_
_version_started: 0.9.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

###void ofAddListener(&event, listenerFunction, prio)

&lt;!--
_syntax: ofAddListener(&event, listenerFunction, prio)_
_name: ofAddListener_
_returns: void_
_returns_description: _
_parameters: ofEvent&lt; void > &event, void (*)(const void *) listenerFunction, int prio_
_version_started: 0.9.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

###void ofAddListener(&event, listenerFunction, prio)

&lt;!--
_syntax: ofAddListener(&event, listenerFunction, prio)_
_name: ofAddListener_
_returns: void_
_returns_description: _
_parameters: ofEvent&lt; void > &event, void (*)() listenerFunction, int prio_
_version_started: 0.9.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

###void ofAddListener(&event, listenerFunction, prio)

&lt;!--
_syntax: ofAddListener(&event, listenerFunction, prio)_
_name: ofAddListener_
_returns: void_
_returns_description: _
_parameters: EventType &event, bool (*)(ArgumentsType &) listenerFunction, int prio_
_version_started: 0.9.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

###void ofAddListener(&event, listenerFunction, prio)

&lt;!--
_syntax: ofAddListener(&event, listenerFunction, prio)_
_name: ofAddListener_
_returns: void_
_returns_description: _
_parameters: ofEvent&lt; void > &event, bool (*)(const void *) listenerFunction, int prio_
_version_started: 0.9.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

###void ofAddListener(&event, listenerFunction, prio)

&lt;!--
_syntax: ofAddListener(&event, listenerFunction, prio)_
_name: ofAddListener_
_returns: void_
_returns_description: _
_parameters: ofEvent&lt; void > &event, bool (*)() listenerFunction, int prio_
_version_started: 0.9.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

###bool ofNotifyEvent(&event)

&lt;!--
_syntax: ofNotifyEvent(&event)_
_name: ofNotifyEvent_
_returns: bool_
_returns_description: _
_parameters: ofEvent&lt; void > &event_
_version_started: 0.06_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _

Notifies an event, what makes all it's registered method listeners to be called with the same argument.

This is a templated function so the type of the parameters is not predefined and can be anything as long as the listener methods use the same type for the parameter.

The arguments are passed to the listeners by reference so they can modify them. 

The listener methods are called in the same order they were registered using ofAddListener.

For instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:

~~~~{.cpp}

class SimpleEventNotifier {
	ofEvent&lt;float> notify;	// will send an event with a float

	void sendEvent() {
		ofNotifyEvent(notify, ofGetElapsedTimef(), this); 
	}

};

~~~~

We can listen for that in our ofApp:

~~~~{.cpp}
SimpleEventNotifier notifier;
void ofApp::setup() {
	ofAddListener(notifier.notify, this, &ofApp::haveBeenNotified);
}

void ofApp::haveBeenNotified(float &f){
    ofLog() &lt;&lt; " event at " &lt;&lt; f &lt;&lt; endl;
}

~~~~





&lt;!----------------------------------------------------------------------------->

###bool ofNotifyEvent(&event, &args)

&lt;!--
_syntax: ofNotifyEvent(&event, &args)_
_name: ofNotifyEvent_
_returns: bool_
_returns_description: _
_parameters: EventType &event, const ArgumentsType &args_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _

Notifies an event, what makes all it's registered method listeners to be called with the same argument.

This is a templated function so the type of the parameters is not predefined and can be anything as long as the listener methods use the same type for the parameter.

The arguments are passed to the listeners by reference so they can modify them.

The listener methods are called in the same order they were registered using ofAddListener.

With this version the listeners also receive a pointer to the notifying class in case the listener method specifies that parameter.

For instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:

~~~~{.cpp}

class SimpleEventNotifier {
	ofEvent&lt;float> notify;	// will send an event with a float

	void sendEvent() {
		ofNotifyEvent(notify, ofGetElapsedTimef(), this); 
	}

};

~~~~

We can listen for that in our ofApp:

~~~~{.cpp}
SimpleEventNotifier notifier;
void ofApp::setup() {
	ofAddListener(notifier.notify, this, &ofApp::haveBeenNotified);
}

void ofApp::haveBeenNotified(float &f){
    ofLog() &lt;&lt; " event at " &lt;&lt; f &lt;&lt; endl;
}

~~~~





&lt;!----------------------------------------------------------------------------->

###bool ofNotifyEvent(&event, &args)

&lt;!--
_syntax: ofNotifyEvent(&event, &args)_
_name: ofNotifyEvent_
_returns: bool_
_returns_description: _
_parameters: EventType &event, ArgumentsType &args_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _

Notifies an event, what makes all it's registered method listeners to be called with the same argument.

This is a templated function so the type of the parameters is not predefined and can be anything as long as the listener methods use the same type for the parameter.

The arguments are passed to the listeners by reference so they can modify them.

The listener methods are called in the same order they were registered using ofAddListener.

With this version the listeners also receive a pointer to the notifying class in case the listener method specifies that parameter.

For instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:

~~~~{.cpp}

class SimpleEventNotifier {
	ofEvent&lt;float> notify;	// will send an event with a float

	void sendEvent() {
		ofNotifyEvent(notify, ofGetElapsedTimef(), this); 
	}

};

~~~~

We can listen for that in our ofApp:

~~~~{.cpp}
SimpleEventNotifier notifier;
void ofApp::setup() {
	ofAddListener(notifier.notify, this, &ofApp::haveBeenNotified);
}

void ofApp::haveBeenNotified(float &f){
    ofLog() &lt;&lt; " event at " &lt;&lt; f &lt;&lt; endl;
}

~~~~





&lt;!----------------------------------------------------------------------------->

###bool ofNotifyEvent(&event, &args, *sender)

&lt;!--
_syntax: ofNotifyEvent(&event, &args, *sender)_
_name: ofNotifyEvent_
_returns: bool_
_returns_description: _
_parameters: EventType &event, const ArgumentsType &args, SenderType *sender_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _

Notifies an event, what makes all it's registered method listeners to be called with the same argument.

This is a templated function so the type of the parameters is not predefined and can be anything as long as the listener methods use the same type for the parameter.

The arguments are passed to the listeners by reference so they can modify them.

The listener methods are called in the same order they were registered using ofAddListener.

With this version the listeners also receive an event args object that can be used to send additional data to the listening class.

For instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:

~~~~{.cpp}

class SimpleEventNotifier {
	ofEvent&lt;float> notify;	// will send an event with a float

	void sendEvent() {
		ofNotifyEvent(notify, ofGetElapsedTimef()); 
	}

};

~~~~

We can listen for that in our ofApp:

~~~~{.cpp}
SimpleEventNotifier notifier;
void ofApp::setup() {
	ofAddListener(notifier.notify, this, &ofApp::haveBeenNotified);
}

void ofApp::haveBeenNotified(float &f){
    ofLog() &lt;&lt; " event at " &lt;&lt; f &lt;&lt; endl;
}

~~~~





&lt;!----------------------------------------------------------------------------->

###bool ofNotifyEvent(&event, &args, *sender)

&lt;!--
_syntax: ofNotifyEvent(&event, &args, *sender)_
_name: ofNotifyEvent_
_returns: bool_
_returns_description: _
_parameters: EventType &event, ArgumentsType &args, SenderType *sender_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

notifies an event so all the registered listeners
get called

ie:
	ofNotifyEvent(addon.newIntEvent, intArgument, this)

or in case there's no sender:
	ofNotifyEvent(addon.newIntEvent, intArgument)

@returns: true in case any listener attended the event





_description: _

Notifies an event, what makes all it's registered method listeners to be called with the same argument.

This is a templated function so the type of the parameters is not predefined and can be anything as long as the listener methods use the same type for the parameter.

The arguments are passed to the listeners by reference so they can modify them.

The listener methods are called in the same order they were registered using ofAddListener.

For instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:

~~~~{.cpp}

class SimpleEventNotifier {
	ofEvent notify;	// will send an event with no data

	void sendEvent() {
		ofNotifyEvent(notify); 
	}

};

~~~~

We can listen for that in our ofApp:

~~~~{.cpp}
SimpleEventNotifier notifier;
void ofApp::setup() {
	ofAddListener(notifier.notify, this, &ofApp::haveBeenNotified);
}

void ofApp::haveBeenNotified(){
    ofLog() &lt;&lt; " event at " &lt;&lt; ofGetElapsedTimef() &lt;&lt; endl;
}

~~~~





&lt;!----------------------------------------------------------------------------->

###bool ofNotifyEvent(&event, *sender)

&lt;!--
_syntax: ofNotifyEvent(&event, *sender)_
_name: ofNotifyEvent_
_returns: bool_
_returns_description: _
_parameters: ofEvent&lt; void > &event, SenderType *sender_
_version_started: 0.06_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _

Notifies an event, what makes all it's registered method listeners to be called with the same argument.

This is a templated function so the type of the parameters is not predefined and can be anything as long as the listener methods use the same type for the parameter.

The arguments are passed to the listeners by reference so they can modify them.

The listener methods are called in the same order they were registered using ofAddListener.

With this version the listeners also receive a pointer to the notifying class in case the listener method specifies that parameter.

For instance, borrowing from the examples/events/SimpleEventsExample, if we make a class that will broadcast an event:

~~~~{.cpp}

class SimpleEventNotifier {
	ofEvent&lt;float> notify;	// will send an event with a float

	void sendEvent() {
		ofNotifyEvent(notify, ofGetElapsedTimef(), this); 
	}

};

~~~~

We can listen for that in our ofApp:

~~~~{.cpp}
SimpleEventNotifier notifier;
void ofApp::setup() {
	ofAddListener(notifier.notify, this, &ofApp::haveBeenNotified);
}

void ofApp::haveBeenNotified(float &f){
    ofLog() &lt;&lt; " event at " &lt;&lt; f &lt;&lt; endl;
}

~~~~





&lt;!----------------------------------------------------------------------------->

###void ofRemoveListener(&event, *, listenerFunction, prio)

&lt;!--
_syntax: ofRemoveListener(&event, *, listenerFunction, prio)_
_name: ofRemoveListener_
_returns: void_
_returns_description: _
_parameters: EventType &event, void (*)(const void *, ArgumentsType &) listenerFunction, int prio_
_version_started: 0.9.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

###void ofRemoveListener(&event, *, listenerFunction, prio)

&lt;!--
_syntax: ofRemoveListener(&event, *, listenerFunction, prio)_
_name: ofRemoveListener_
_returns: void_
_returns_description: _
_parameters: EventType &event, bool (*)(const void *, ArgumentsType &) listenerFunction, int prio_
_version_started: 0.9.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

###void ofRemoveListener(&event, *listener, *, listenerMethod, prio)

&lt;!--
_syntax: ofRemoveListener(&event, *listener, *, listenerMethod, prio)_
_name: ofRemoveListener_
_returns: void_
_returns_description: _
_parameters: EventType &event, ListenerClass *listener, bool (ListenerClass::*)(const void *, ArgumentsType &) listenerMethod, int prio_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _

Removes a listener method from an event. Use it whenever you want a class to stop being notified about an event after having registered it to the method with ofAddListener.

Don't forget to call this before deleting any instance that is listening to an event, if not the event will try to notify a non existent instance and the application will crash.

The syntax is just the same as that of ofAddListener.





&lt;!----------------------------------------------------------------------------->

###void ofRemoveListener(&event, *listener, *, listenerMethod, prio)

&lt;!--
_syntax: ofRemoveListener(&event, *listener, *, listenerMethod, prio)_
_name: ofRemoveListener_
_returns: void_
_returns_description: _
_parameters: EventType &event, ListenerClass *listener, void (ListenerClass::*)(const void *, ArgumentsType &) listenerMethod, int prio_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _

unregister any method of any class to an event.

the method must provide one the following
signatures:
    void method(ArgumentsType & args)
    void method(const void * sender, ArgumentsType &args)
ie:
    ofAddListener(addon.newIntEvent, this, &Class::method)





_description: _

Removes a listener method from an event. Use it whenever you want a class to stop being notified about an event after having registered it to the method with ofAddListener.

Don't forget to call this before deleting any instance that is listening to an event, if not the event will try to notify a non existent instance and the application will crash.

The syntax is just the same as that of ofAddListener.





&lt;!----------------------------------------------------------------------------->

###void ofRemoveListener(&event, *listener, listenerMethod, prio)

&lt;!--
_syntax: ofRemoveListener(&event, *listener, listenerMethod, prio)_
_name: ofRemoveListener_
_returns: void_
_returns_description: _
_parameters: ofEvent&lt; void > &event, ListenerClass *listener, bool (ListenerClass::*)() listenerMethod, int prio_
_version_started: 0.06_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _

Removes a listener method from an event. Use it whenever you want a class to stop being notified about an event after having registered it to the method with ofAddListener.

Don't forget to call this before deleting any instance that is listening to an event, if not the event will try to notify a non existent instance and the application will crash.

The syntax is just the same as that of ofAddListener.





&lt;!----------------------------------------------------------------------------->

###void ofRemoveListener(&event, *listener, listenerMethod, prio)

&lt;!--
_syntax: ofRemoveListener(&event, *listener, listenerMethod, prio)_
_name: ofRemoveListener_
_returns: void_
_returns_description: _
_parameters: ofEvent&lt; void > &event, ListenerClass *listener, bool (ListenerClass::*)(const void *) listenerMethod, int prio_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _

Removes a listener method from an event. Use it whenever you want a class to stop being notified about an event after having registered it to the method with ofAddListener.

Don't forget to call this before deleting any instance that is listening to an event, if not the event will try to notify a non existent instance and the application will crash.

The syntax is just the same as that of ofAddListener.





&lt;!----------------------------------------------------------------------------->

###void ofRemoveListener(&event, *listener, listenerMethod, prio)

&lt;!--
_syntax: ofRemoveListener(&event, *listener, listenerMethod, prio)_
_name: ofRemoveListener_
_returns: void_
_returns_description: _
_parameters: EventType &event, ListenerClass *listener, bool (ListenerClass::*)(ArgumentsType &) listenerMethod, int prio_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _

Removes a listener method from an event. Use it whenever you want a class to stop being notified about an event after having registered it to the method with ofAddListener.

Don't forget to call this before deleting any instance that is listening to an event, if not the event will try to notify a non existent instance and the application will crash.

The syntax is just the same as that of ofAddListener.





&lt;!----------------------------------------------------------------------------->

###void ofRemoveListener(&event, *listener, listenerMethod, prio)

&lt;!--
_syntax: ofRemoveListener(&event, *listener, listenerMethod, prio)_
_name: ofRemoveListener_
_returns: void_
_returns_description: _
_parameters: ofEvent&lt; void > &event, ListenerClass *listener, void (ListenerClass::*)() listenerMethod, int prio_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _

Removes a listener method from an event. Use it whenever you want a class to stop being notified about an event after having registered it to the method with ofAddListener.

Don't forget to call this before deleting any instance that is listening to an event, if not the event will try to notify a non existent instance and the application will crash.

The syntax is just the same as that of ofAddListener.





&lt;!----------------------------------------------------------------------------->

###void ofRemoveListener(&event, *listener, listenerMethod, prio)

&lt;!--
_syntax: ofRemoveListener(&event, *listener, listenerMethod, prio)_
_name: ofRemoveListener_
_returns: void_
_returns_description: _
_parameters: ofEvent&lt; void > &event, ListenerClass *listener, void (ListenerClass::*)(const void *) listenerMethod, int prio_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _

Removes a listener method from an event. Use it whenever you want a class to stop being notified about an event after having registered it to the method with ofAddListener.

Don't forget to call this before deleting any instance that is listening to an event, if not the event will try to notify a non existent instance and the application will crash.

The syntax is just the same as that of ofAddListener.





&lt;!----------------------------------------------------------------------------->

###void ofRemoveListener(&event, *listener, listenerMethod, prio)

&lt;!--
_syntax: ofRemoveListener(&event, *listener, listenerMethod, prio)_
_name: ofRemoveListener_
_returns: void_
_returns_description: _
_parameters: EventType &event, ListenerClass *listener, void (ListenerClass::*)(ArgumentsType &) listenerMethod, int prio_
_version_started: _
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _

Removes a listener method from an event. Use it whenever you want a class to stop being notified about an event after having registered it to the method with ofAddListener.

Don't forget to call this before deleting any instance that is listening to an event, if not the event will try to notify a non existent instance and the application will crash.

The syntax is just the same as that of ofAddListener.





&lt;!----------------------------------------------------------------------------->

###void ofRemoveListener(&event, listenerFunction, prio)

&lt;!--
_syntax: ofRemoveListener(&event, listenerFunction, prio)_
_name: ofRemoveListener_
_returns: void_
_returns_description: _
_parameters: EventType &event, void (*)(ArgumentsType &) listenerFunction, int prio_
_version_started: 0.9.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

###void ofRemoveListener(&event, listenerFunction, prio)

&lt;!--
_syntax: ofRemoveListener(&event, listenerFunction, prio)_
_name: ofRemoveListener_
_returns: void_
_returns_description: _
_parameters: ofEvent&lt; void > &event, void (*)(const void *) listenerFunction, int prio_
_version_started: 0.9.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

###void ofRemoveListener(&event, listenerFunction, prio)

&lt;!--
_syntax: ofRemoveListener(&event, listenerFunction, prio)_
_name: ofRemoveListener_
_returns: void_
_returns_description: _
_parameters: ofEvent&lt; void > &event, void (*)() listenerFunction, int prio_
_version_started: 0.9.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

###void ofRemoveListener(&event, listenerFunction, prio)

&lt;!--
_syntax: ofRemoveListener(&event, listenerFunction, prio)_
_name: ofRemoveListener_
_returns: void_
_returns_description: _
_parameters: EventType &event, bool (*)(ArgumentsType &) listenerFunction, int prio_
_version_started: 0.9.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

###void ofRemoveListener(&event, listenerFunction, prio)

&lt;!--
_syntax: ofRemoveListener(&event, listenerFunction, prio)_
_name: ofRemoveListener_
_returns: void_
_returns_description: _
_parameters: ofEvent&lt; void > &event, bool (*)(const void *) listenerFunction, int prio_
_version_started: 0.9.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

###void ofRemoveListener(&event, listenerFunction, prio)

&lt;!--
_syntax: ofRemoveListener(&event, listenerFunction, prio)_
_name: ofRemoveListener_
_returns: void_
_returns_description: _
_parameters: ofEvent&lt; void > &event, bool (*)() listenerFunction, int prio_
_version_started: 0.9.0_
_version_deprecated: _
_summary: _
_constant: False_
_static: False_
_visible: True_
_advanced: False_
-->

_inlined_description: _







_description: _







&lt;!----------------------------------------------------------------------------->

</textarea></div></div></div></div></div></div><script defer src="/_nuxt/payloads/1584626286009/documentation/events/ofEventUtils_functions/payload.js"></script><script src="/_nuxt/3213b67383225fc2f59b.js" defer></script><script src="/_nuxt/d1291586b31fa28ca9d5.js" defer></script><script src="/_nuxt/5fe5bba000836bc4a25f.js" defer></script><script src="/_nuxt/f8d94d1c92ade1d8a6da.js" defer></script><script src="/_nuxt/9a7e20c23e9625feab77.js" defer></script>
  </body>
</html>
