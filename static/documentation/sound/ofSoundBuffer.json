{"entry":{"name":"ofSoundBuffer","filename":"ofSoundBuffer.markdown","absolute":"/Users/Gilbert/Code/openFrameworks/ofSite/documentation/sound/ofSoundBuffer.markdown","path":"/documentation/sound/ofSoundBuffer","route":"/documentation/sound/ofSoundBuffer.markdown","dir":"../ofSite/documentation/sound","ext":"markdown","type":"page","id":430,"parent":422,"breadcrumbs":[422,1],"siblings":[],"translations":{}},"description":{"short":"<p>/*!</p>\n<p>@brief Buffer for audio samples and associated metadata.</p>\n<p>ofSoundBuffer stores audio as an array of interleaved floating point samples, with a given sample rate for playback.</p>\n<h4>How sound recording works</h4>\n<p>Physically speaking, what we call <em>sound</em> is simply changes in air pressure perceived by a listener. These changes in sound pressure are converted\nby a microphone into changes in voltage that can be recorded, making a <em>sound recording</em>. A sound recording is therefore a recording of changes in air\npressure at a particular point in space (ie where the microphone was positioned). When it is played back through a speaker, the speaker reproduces the\nsame pattern of changes in air pressure as were recorded by the microphone, but this time at a different point in space (ie where the speaker is positioned).</p>\n<p>In digital audio these changes in air pressure are recorded as a set of discrete numbers (<em>samples</em>), each number representing a snapshot of the air pressure\nat a particular point in time. For high quality audio there are typically 44,100 snapshots recorded every second. This is called the <em>sample rate</em> and is\nexpressed in <em>Hz</em> (44100Hz) or <em>kHz</em> (44.1kHz).</p>\n<p>Because humans have two ears, rather than one, sound is usually recorded in stereo. The simplest stereo sound recording is two <em>channels</em> of sound\nrecorded by two microphones at two different points in space. More channels can also be recorded (eg with 5.1 surround sound systems or Ambisonics).</p>\n<h4>Frames, channels and samples</h4>\n<p>Data in an ofSoundBuffer is stored <em>interleaved</em> as an array of floats. Interleaved audio is analogous to how different color channels are stored side by side\nin an ofImage or ofPixels object.</p>\n<p>The functions and function arguments in ofSoundBuffer that deal with this interleaved data are based on 3 key terms:</p>\n<p><em>channels</em> refers to the number of channels or individual streams of interleaved audio samples in the buffer. A mono recording has 1 channel, a stereo\nrecording has 2 channels.</p>\n<p><em>samples</em> refers to the actual raw data. One <em>sample</em> is a single floating point number between -1 and 1, which represents a snapshot of sound pressure at\na single moment in time. A 0.1 second long buffer at 44100Hz contains 4410 <em>samples</em> if it has 1 channel, 8820 <em>samples</em> if it has 2 channels, 13230\n<em>samples</em> if it has 3 channels, and so on.</p>\n<p><em>frames</em> refers to the number of multi-channel sets of interleaved sample data there are in the buffer. A 0.1 second long buffer at 44100Hz always has\n4410 <em>frames</em>, regardless of how many channels it has. To get the number of <em>samples</em> in a buffer you multiply the number of <em>channels</em> by the number of <em>frames</em>.</p>\n<p>If I have an ofSoundBuffer with 8 <em>frames</em> of mono (1 <em>channel</em>) audio, the underlying array contains 8 <em>samples</em> (ie it is 8 floats long),\nand the samples are arranged like this:</p>\n<p>L L L L L L L L</p>\n<p>where <code>L</code> represents a single sample.</p>\n<p>If I have an ofSoundBuffer with 8 <em>frames</em> of stereo (2 <em>channel</em>) audio, then the underlying array contains 16 <em>samples</em> ((getNumFrames()<em>getNumChannels(),\nie 8</em>2) arranged in an <em>interleaved</em> pattern:</p>\n<p>L R L R L R L R L R L R L R L R</p>\n<p>where <code>L</code> represents a single sample for the left channel, and <code>R</code> represents a single sample for the right channel. Grouping the frames together for clarity:</p>\n<p>LR LR LR LR LR LR LR LR</p>\n<p>If I have an ofSoundBuffer with 8 frames of 5.1 surround (6 <em>channel</em>) audio, then the underlying array of floats contains 48 <em>samples</em> (getNumFrames()<em>getNumChannels(),\nie 8</em>6) and is usually arranged in an <em>interleaved</em> pattern like this:</p>\n<p>L C R Ls Rs Lfe L C R Ls Rs Lfe L C R Ls Rs Lfe L C R Ls Rs Lfe L C R Ls Rs Lfe L C R Ls Rs Lfe L C R Ls Rs Lfe L C R Ls Rs Lfe</p>\n<p>where <code>L</code> represents a single sample for the left channel, <code>C</code> for centre, <code>R</code> for right, <code>Ls</code> for left surround, <code>Rs</code> for right surround and <code>Lfe</code> for the subwoofer.\nGrouping the frames together for clarity:</p>\n<p>LCRLsRsLfe LCRLsRsLfe LCRLsRsLfe LCRLsRsLfe LCRLsRsLfe LCRLsRsLfe LCRLsRsLfe LCRLsRsLfe</p>\n<p>*/</p>\n","full":"<h1></h1>\n"},"config":{"visible":"True","advanced":"False","istemplated":"False","extends":null},"methods":[{"syntax":"addTo(&outBuffer, fromFrame, loop = false)","name":"addTo","returns":"void","returns_description":null,"parameters":"ofSoundBuffer <span class=\"token operator\">&amp;</span>outBuffer<span class=\"token punctuation\">,</span> size_t fromFrame<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> loop<span class=\"token operator\">=</span><span class=\"token boolean\">false</span>","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>as addTo above but reads outNumFrames and outNumChannels from outBuffer</p>\n","desc":""},{"syntax":"addTo(&outBuffer, outNumFrames, outNumChannels, fromFrame, loop = false)","name":"addTo","returns":"void","returns_description":null,"parameters":"ofSoundBuffer <span class=\"token operator\">&amp;</span>outBuffer<span class=\"token punctuation\">,</span> size_t outNumFrames<span class=\"token punctuation\">,</span> size_t outNumChannels<span class=\"token punctuation\">,</span> size_t fromFrame<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> loop<span class=\"token operator\">=</span><span class=\"token boolean\">false</span>","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>as copyTo but mixes source audio with audio in <code>outBuffer</code> by adding samples together (+), instead of overwriting.</p>\n","desc":""},{"syntax":"addTo(*outBuffer, outNumFrames, outNumChannels, fromFrame, loop = false)","name":"addTo","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> <span class=\"token operator\">*</span>outBuffer<span class=\"token punctuation\">,</span> size_t outNumFrames<span class=\"token punctuation\">,</span> size_t outNumChannels<span class=\"token punctuation\">,</span> size_t fromFrame<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> loop<span class=\"token operator\">=</span><span class=\"token boolean\">false</span>","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>as copyTo but mixes source audio with audio in <code>out</code> by adding samples together (+), instead of overwriting</p>\n","desc":""},{"syntax":"allocate(numSamples, numChannels)","name":"allocate","returns":"void","returns_description":null,"parameters":"size_t numSamples<span class=\"token punctuation\">,</span> size_t numChannels","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"append(&other)","name":"append","returns":"void","returns_description":null,"parameters":"ofSoundBuffer <span class=\"token operator\">&amp;</span>other","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"checkSizeAndChannelsConsistency(&function)","name":"checkSizeAndChannelsConsistency","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> string <span class=\"token operator\">&amp;</span>function","access":"protected","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"clear()","name":"clear","returns":"void","returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>remove all samples, preserving channel count and sample rate.</p>\n","desc":""},{"short":"","desc":""},{"short":"","desc":""},{"syntax":"copyFrom(*floatBuffer, numFrames, numChannels, sampleRate)","name":"copyFrom","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> <span class=\"token keyword\">float</span> <span class=\"token operator\">*</span>floatBuffer<span class=\"token punctuation\">,</span> size_t numFrames<span class=\"token punctuation\">,</span> size_t numChannels<span class=\"token punctuation\">,</span> <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> sampleRate","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"copyFrom(*shortBuffer, numFrames, numChannels, sampleRate)","name":"copyFrom","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> <span class=\"token keyword\">short</span> <span class=\"token operator\">*</span>shortBuffer<span class=\"token punctuation\">,</span> size_t numFrames<span class=\"token punctuation\">,</span> size_t numChannels<span class=\"token punctuation\">,</span> <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> sampleRate","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>copy length samples from shortBuffer and interpret as interleaved with the given number of channels at the given samplerate</p>\n","desc":""},{"syntax":"copyTo(&outBuffer, frameFrame, loop = false)","name":"copyTo","returns":"void","returns_description":null,"parameters":"ofSoundBuffer <span class=\"token operator\">&amp;</span>outBuffer<span class=\"token punctuation\">,</span> size_t frameFrame<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> loop<span class=\"token operator\">=</span><span class=\"token boolean\">false</span>","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>as copyTo above but reads outNumFrames and outNumChannels from outBuffer</p>\n","desc":""},{"syntax":"copyTo(&outBuffer, outNumFrames, outNumChannels, fromFrame, loop = false)","name":"copyTo","returns":"void","returns_description":null,"parameters":"ofSoundBuffer <span class=\"token operator\">&amp;</span>outBuffer<span class=\"token punctuation\">,</span> size_t outNumFrames<span class=\"token punctuation\">,</span> size_t outNumChannels<span class=\"token punctuation\">,</span> size_t fromFrame<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> loop<span class=\"token operator\">=</span><span class=\"token boolean\">false</span>","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>resize outBuffer to outNumFrames with outNumChannels, and then copy outNumFrames of data from us to outBuffer.\nfromFrame is a frame offset. if we don't have enough source data, loop with fromFrame=0 until we have filled outBuffer.\nif outBuffer has fewer channels than our buffer, just copy the first outNumChannels of our data and skip the rest.\nif outBuffer has more channels than our buffer, loop through our channels repeatedly until done.</p>\n","desc":""},{"syntax":"copyTo(*outBuffer, outNumFrames, outNumChannels, fromFrame, loop = false)","name":"copyTo","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> <span class=\"token operator\">*</span>outBuffer<span class=\"token punctuation\">,</span> size_t outNumFrames<span class=\"token punctuation\">,</span> size_t outNumChannels<span class=\"token punctuation\">,</span> size_t fromFrame<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> loop<span class=\"token operator\">=</span><span class=\"token boolean\">false</span>","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>copy sample data to out, where out is already allocated to match outNumFrames and outNumChannels (ie outNumFrames*outNumChannels samples).\nfromFrame is a frame offset. if we don't have enough source data, loop with fromFrame=0 until we have filled the out buffer.\nif out has fewer channels than our buffer, just copy the first outNumChannels of our data and skip the rest.\nif out has more channels than our buffer, loop through our channels repeatedly until done.</p>\n","desc":""},{"syntax":"fillWithNoise(amplitude = 1.0f)","name":"fillWithNoise","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> amplitude<span class=\"token operator\">=</span><span class=\"token number\">1.0f</span>","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>fills the buffer with random noise between -amplitude and amplitude. useful for debugging.</p>\n","desc":""},{"syntax":"fillWithTone(pitchHz = 440.0f, phase = 0.0f)","name":"fillWithTone","returns":"float","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> pitchHz<span class=\"token operator\">=</span><span class=\"token number\">440.0f</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> phase<span class=\"token operator\">=</span><span class=\"token number\">0.0f</span>","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>fills the buffer with a sine wave. useful for debugging.</p>\n","desc":""},{"short":"<p>return the underlying buffer. careful!</p>\n","desc":""},{"short":"","desc":""},{"syntax":"getChannel(&outBuffer, sourceChannel)","name":"getChannel","returns":"void","returns_description":null,"parameters":"ofSoundBuffer <span class=\"token operator\">&amp;</span>outBuffer<span class=\"token punctuation\">,</span> size_t sourceChannel","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>copy the requested channel of our data to outBuffer. resize outBuffer to fit.</p>\n","desc":""},{"syntax":"getDeviceID()","name":"getDeviceID","returns":"int","returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>return the ID of the device which generated this buffer</p>\n","desc":""},{"syntax":"getDurationMS()","name":"getDurationMS","returns":"uint64_t","returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>return the duration of audio in this buffer in milliseconds (==(getNumFrames()/getSampleRate())*1000)</p>\n","desc":""},{"syntax":"getDurationMicros()","name":"getDurationMicros","returns":"uint64_t","returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"getDurationNanos()","name":"getDurationNanos","returns":"uint64_t","returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"getNumChannels()","name":"getNumChannels","returns":"size_t","returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>the number of channels per frame</p>\n","desc":""},{"syntax":"getNumFrames()","name":"getNumFrames","returns":"size_t","returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>the number of frames, ie the number of sets of (getNumChannels()) samples</p>\n","desc":""},{"syntax":"getRMSAmplitude()","name":"getRMSAmplitude","returns":"float","returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"getRMSAmplitudeChannel(channel)","name":"getRMSAmplitudeChannel","returns":"float","returns_description":null,"parameters":"size_t channel","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"getSample(frameIndex, channel)","name":"getSample","returns":"float &","returns_description":null,"parameters":"size_t frameIndex<span class=\"token punctuation\">,</span> size_t channel","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>access the sample at frameIndex on a soecific channel</p>\n","desc":""},{"syntax":"getSample(frameIndex, channel)","name":"getSample","returns":"const float &","returns_description":null,"parameters":"size_t frameIndex<span class=\"token punctuation\">,</span> size_t channel","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"getSampleRate()","name":"getSampleRate","returns":"unsigned int","returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>sample rate of the audio in this buffer</p>\n","desc":""},{"syntax":"getTickCount()","name":"getTickCount","returns":"uint64_t","returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>return the tickCount that was assigned by ofSoundStream (if this buffer originated from an ofSoundStream).</p>\n","desc":""},{"syntax":"hermiteResampleTo(&buffer, fromFrame, numFrames, speed, loop)","name":"hermiteResampleTo","returns":"void","returns_description":null,"parameters":"ofSoundBuffer <span class=\"token operator\">&amp;</span>buffer<span class=\"token punctuation\">,</span> size_t fromFrame<span class=\"token punctuation\">,</span> size_t numFrames<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> speed<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> loop","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"linearResampleTo(&buffer, fromFrame, numFrames, speed, loop)","name":"linearResampleTo","returns":"void","returns_description":null,"parameters":"ofSoundBuffer <span class=\"token operator\">&amp;</span>buffer<span class=\"token punctuation\">,</span> size_t fromFrame<span class=\"token punctuation\">,</span> size_t numFrames<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> speed<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> loop","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"normalize(level)","name":"normalize","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> level","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>amplifies samples so that the maximum amplitude is equal to 'level'</p>\n","desc":""},{"syntax":"ofSoundBuffer()","name":"ofSoundBuffer","returns":null,"returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"ofSoundBuffer(*shortBuffer, numFrames, numChannels, sampleRate)","name":"ofSoundBuffer","returns":null,"returns_description":null,"parameters":"<span class=\"token keyword\">short</span> <span class=\"token operator\">*</span>shortBuffer<span class=\"token punctuation\">,</span> size_t numFrames<span class=\"token punctuation\">,</span> size_t numChannels<span class=\"token punctuation\">,</span> <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> sampleRate","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"operator*(value)","name":"operator*","returns":"ofSoundBuffer","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> value","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>return a new buffer containing the contents of this buffer multiplied by value.</p>\n","desc":""},{"syntax":"operator*=(value)","name":"operator*=","returns":"ofSoundBuffer &","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> value","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>multiply everything in this buffer by value, in-place.</p>\n","desc":""},{"syntax":"operator[](samplePos)","name":"operator[]","returns":"float &","returns_description":null,"parameters":"size_t samplePos","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>access the sample at the given position in the buffer.\nto retrieve the sample for channel channelIndex of frame frameIndex, do the following:\nofSoundBuffer myBuffer;\n...\nfloat sample = myBuffer[(frameIndex*myBuffer.getNumChannels()) + channelIndex];</p>\n","desc":""},{"syntax":"operator[](samplePos)","name":"operator[]","returns":"const float &","returns_description":null,"parameters":"size_t samplePos","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"resample(speed, algorithm)","name":"resample","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> speed<span class=\"token punctuation\">,</span> ofSoundBuffer<span class=\"token operator\">::</span>InterpolationAlgorithm algorithm","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>resample by changing the playback speed, keeping the same sampleRate</p>\n","desc":""},{"syntax":"resampleTo(&outBuffer, fromFrame, numFrames, speed, loop = false, algorithm)","name":"resampleTo","returns":"void","returns_description":null,"parameters":"ofSoundBuffer <span class=\"token operator\">&amp;</span>outBuffer<span class=\"token punctuation\">,</span> size_t fromFrame<span class=\"token punctuation\">,</span> size_t numFrames<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> speed<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> loop<span class=\"token operator\">=</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> ofSoundBuffer<span class=\"token operator\">::</span>InterpolationAlgorithm algorithm","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>resample our data to outBuffer at the given target speed, starting at fromFrame and copying numFrames of data. resize outBuffer to fit.\nspeed is relative to current speed (ie 1.0f == no change). lower speeds will give a larger outBuffer, higher speeds a smaller outBuffer.</p>\n","desc":""},{"syntax":"resize(numSamples, val)","name":"resize","returns":"void","returns_description":null,"parameters":"size_t numSamples<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> val","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>resize this buffer to exactly this many samples. it's up to you make sure samples matches the channel count.</p>\n","desc":""},{"syntax":"set(value)","name":"set","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> value","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>set everything in this buffer to value, preserving size, channel count and sample rate.</p>\n","desc":""},{"syntax":"setChannel(&inBuffer, channel)","name":"setChannel","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">const</span> ofSoundBuffer <span class=\"token operator\">&amp;</span>inBuffer<span class=\"token punctuation\">,</span> size_t channel","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>copy data from inBuffer to the given channel. resize ourselves to match inBuffer's getNumFrames().</p>\n","desc":""},{"syntax":"setDeviceID(id)","name":"setDeviceID","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">int</span> id","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"setNumChannels(channels)","name":"setNumChannels","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">int</span> channels","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>set the number of channels. does not change the underlying data, ie causes getNumFrames() to return a different result.</p>\n","desc":""},{"syntax":"setSampleRate(rate)","name":"setSampleRate","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> rate","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"setTickCount(tick)","name":"setTickCount","returns":"void","returns_description":null,"parameters":"uint64_t tick","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"size()","name":"size","returns":"size_t","returns_description":null,"parameters":null,"access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>return the total number of samples in this buffer (==getNumFrames()*getNumChannels())</p>\n","desc":""},{"syntax":"stereoPan(left, right)","name":"stereoPan","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> left<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> right","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>assuming a 2-channel buffer, apply a stereo pan by multiplying channel 0 by left and channel 1 by right.</p>\n","desc":""},{"syntax":"swap(&otherBuffer)","name":"swap","returns":"void","returns_description":null,"parameters":"ofSoundBuffer <span class=\"token operator\">&amp;</span>otherBuffer","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>swap the contents of this buffer with otherBuffer</p>\n","desc":""},{"short":"","desc":""},{"syntax":"toShortPCM(*dst)","name":"toShortPCM","returns":"void","returns_description":null,"parameters":"<span class=\"token keyword\">short</span> <span class=\"token operator\">*</span>dst","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"","desc":""},{"syntax":"trimSilence(threshold = 0.0001f, trimStart = true, trimEnd = true)","name":"trimSilence","returns":"bool","returns_description":null,"parameters":"<span class=\"token keyword\">float</span> threshold<span class=\"token operator\">=</span><span class=\"token number\">0.0001f</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> trimStart<span class=\"token operator\">=</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> trimEnd<span class=\"token operator\">=</span><span class=\"token boolean\">true</span>","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"constant":"False","static":"False","visible":"True","advanced":"False","short":"<p>removes initial / ending silence from the buffer</p>\n","desc":""},{"short":"","desc":""},{"name":"channels","type":"size_t","access":"protected","version_started":"0.9.0","version_deprecated":null,"summary":null,"visible":"True","constant":"False","advanced":"False","short":"","desc":""},{"name":"defaultAlgorithm","type":"ofSoundBuffer::InterpolationAlgorithm","access":"public","version_started":"0.9.0","version_deprecated":null,"summary":null,"visible":"True","constant":"False","advanced":"False","short":"","desc":""},{"name":"samplerate","type":"unsigned int","access":"protected","version_started":"0.9.0","version_deprecated":null,"summary":null,"visible":"True","constant":"False","advanced":"False","short":"","desc":""},{"name":"soundStreamDeviceID","type":"int","access":"protected","version_started":"0.9.0","version_deprecated":null,"summary":null,"visible":"True","constant":"False","advanced":"False","short":"","desc":""},{"name":"tickCount","type":"uint64_t","access":"protected","version_started":"0.9.0","version_deprecated":null,"summary":null,"visible":"True","constant":"False","advanced":"False","short":"","desc":""},{}],"document":"<p>#class ofSoundBuffer</p>\n<p>&lt;!--\n<em>visible: True</em>\n<em>advanced: False</em>\n<em>istemplated: False</em>\n_extends: _\n--&gt;</p>\n<p>##InlineDescription</p>\n<p>/*!</p>\n<p>@brief Buffer for audio samples and associated metadata.</p>\n<p>ofSoundBuffer stores audio as an array of interleaved floating point samples, with a given sample rate for playback.</p>\n<h4>How sound recording works</h4>\n<p>Physically speaking, what we call <em>sound</em> is simply changes in air pressure perceived by a listener. These changes in sound pressure are converted\nby a microphone into changes in voltage that can be recorded, making a <em>sound recording</em>. A sound recording is therefore a recording of changes in air\npressure at a particular point in space (ie where the microphone was positioned). When it is played back through a speaker, the speaker reproduces the\nsame pattern of changes in air pressure as were recorded by the microphone, but this time at a different point in space (ie where the speaker is positioned).</p>\n<p>In digital audio these changes in air pressure are recorded as a set of discrete numbers (<em>samples</em>), each number representing a snapshot of the air pressure\nat a particular point in time. For high quality audio there are typically 44,100 snapshots recorded every second. This is called the <em>sample rate</em> and is\nexpressed in <em>Hz</em> (44100Hz) or <em>kHz</em> (44.1kHz).</p>\n<p>Because humans have two ears, rather than one, sound is usually recorded in stereo. The simplest stereo sound recording is two <em>channels</em> of sound\nrecorded by two microphones at two different points in space. More channels can also be recorded (eg with 5.1 surround sound systems or Ambisonics).</p>\n<h4>Frames, channels and samples</h4>\n<p>Data in an ofSoundBuffer is stored <em>interleaved</em> as an array of floats. Interleaved audio is analogous to how different color channels are stored side by side\nin an ofImage or ofPixels object.</p>\n<p>The functions and function arguments in ofSoundBuffer that deal with this interleaved data are based on 3 key terms:</p>\n<p><em>channels</em> refers to the number of channels or individual streams of interleaved audio samples in the buffer. A mono recording has 1 channel, a stereo\nrecording has 2 channels.</p>\n<p><em>samples</em> refers to the actual raw data. One <em>sample</em> is a single floating point number between -1 and 1, which represents a snapshot of sound pressure at\na single moment in time. A 0.1 second long buffer at 44100Hz contains 4410 <em>samples</em> if it has 1 channel, 8820 <em>samples</em> if it has 2 channels, 13230\n<em>samples</em> if it has 3 channels, and so on.</p>\n<p><em>frames</em> refers to the number of multi-channel sets of interleaved sample data there are in the buffer. A 0.1 second long buffer at 44100Hz always has\n4410 <em>frames</em>, regardless of how many channels it has. To get the number of <em>samples</em> in a buffer you multiply the number of <em>channels</em> by the number of <em>frames</em>.</p>\n<p>If I have an ofSoundBuffer with 8 <em>frames</em> of mono (1 <em>channel</em>) audio, the underlying array contains 8 <em>samples</em> (ie it is 8 floats long),\nand the samples are arranged like this:</p>\n<p>L L L L L L L L</p>\n<p>where <code>L</code> represents a single sample.</p>\n<p>If I have an ofSoundBuffer with 8 <em>frames</em> of stereo (2 <em>channel</em>) audio, then the underlying array contains 16 <em>samples</em> ((getNumFrames()<em>getNumChannels(),\nie 8</em>2) arranged in an <em>interleaved</em> pattern:</p>\n<p>L R L R L R L R L R L R L R L R</p>\n<p>where <code>L</code> represents a single sample for the left channel, and <code>R</code> represents a single sample for the right channel. Grouping the frames together for clarity:</p>\n<p>LR LR LR LR LR LR LR LR</p>\n<p>If I have an ofSoundBuffer with 8 frames of 5.1 surround (6 <em>channel</em>) audio, then the underlying array of floats contains 48 <em>samples</em> (getNumFrames()<em>getNumChannels(),\nie 8</em>6) and is usually arranged in an <em>interleaved</em> pattern like this:</p>\n<p>L C R Ls Rs Lfe L C R Ls Rs Lfe L C R Ls Rs Lfe L C R Ls Rs Lfe L C R Ls Rs Lfe L C R Ls Rs Lfe L C R Ls Rs Lfe L C R Ls Rs Lfe</p>\n<p>where <code>L</code> represents a single sample for the left channel, <code>C</code> for centre, <code>R</code> for right, <code>Ls</code> for left surround, <code>Rs</code> for right surround and <code>Lfe</code> for the subwoofer.\nGrouping the frames together for clarity:</p>\n<p>LCRLsRsLfe LCRLsRsLfe LCRLsRsLfe LCRLsRsLfe LCRLsRsLfe LCRLsRsLfe LCRLsRsLfe LCRLsRsLfe</p>\n<p>*/</p>\n<p>##Description</p>\n<p>##Methods</p>\n<p>###void addTo(&amp;outBuffer, fromFrame, loop = false)</p>\n<p>&lt;!--\n<em>syntax: addTo(&amp;outBuffer, fromFrame, loop = false)</em>\n<em>name: addTo</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: ofSoundBuffer &amp;outBuffer, size_t fromFrame, bool loop=false</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>as addTo above but reads outNumFrames and outNumChannels from outBuffer</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void addTo(&amp;outBuffer, outNumFrames, outNumChannels, fromFrame, loop = false)</p>\n<p>&lt;!--\n<em>syntax: addTo(&amp;outBuffer, outNumFrames, outNumChannels, fromFrame, loop = false)</em>\n<em>name: addTo</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: ofSoundBuffer &amp;outBuffer, size_t outNumFrames, size_t outNumChannels, size_t fromFrame, bool loop=false</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>as copyTo but mixes source audio with audio in <code>outBuffer</code> by adding samples together (+), instead of overwriting.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void addTo(*outBuffer, outNumFrames, outNumChannels, fromFrame, loop = false)</p>\n<p>&lt;!--\n<em>syntax: addTo(*outBuffer, outNumFrames, outNumChannels, fromFrame, loop = false)</em>\n<em>name: addTo</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: float *outBuffer, size_t outNumFrames, size_t outNumChannels, size_t fromFrame, bool loop=false</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>as copyTo but mixes source audio with audio in <code>out</code> by adding samples together (+), instead of overwriting</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void allocate(numSamples, numChannels)</p>\n<p>&lt;!--\n<em>syntax: allocate(numSamples, numChannels)</em>\n<em>name: allocate</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: size_t numSamples, size_t numChannels</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void append(&amp;other)</p>\n<p>&lt;!--\n<em>syntax: append(&amp;other)</em>\n<em>name: append</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: ofSoundBuffer &amp;other</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool checkSizeAndChannelsConsistency(&amp;function)</p>\n<p>&lt;!--\n<em>syntax: checkSizeAndChannelsConsistency(&amp;function)</em>\n<em>name: checkSizeAndChannelsConsistency</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: const string &amp;function</em>\n<em>access: protected</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void clear()</p>\n<p>&lt;!--\n<em>syntax: clear()</em>\n<em>name: clear</em>\n<em>returns: void</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>remove all samples, preserving channel count and sample rate.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void copyFrom(&amp;floatBuffer, numChannels, sampleRate)</p>\n<p>&lt;!--\n<em>syntax: copyFrom(&amp;floatBuffer, numChannels, sampleRate)</em>\n<em>name: copyFrom</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const vector&lt; float &gt; &amp;floatBuffer, size_t numChannels, unsigned int sampleRate</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void copyFrom(&amp;shortBuffer, numChannels, sampleRate)</p>\n<p>&lt;!--\n<em>syntax: copyFrom(&amp;shortBuffer, numChannels, sampleRate)</em>\n<em>name: copyFrom</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const vector&lt; short &gt; &amp;shortBuffer, size_t numChannels, unsigned int sampleRate</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void copyFrom(*floatBuffer, numFrames, numChannels, sampleRate)</p>\n<p>&lt;!--\n<em>syntax: copyFrom(*floatBuffer, numFrames, numChannels, sampleRate)</em>\n<em>name: copyFrom</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const float *floatBuffer, size_t numFrames, size_t numChannels, unsigned int sampleRate</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void copyFrom(*shortBuffer, numFrames, numChannels, sampleRate)</p>\n<p>&lt;!--\n<em>syntax: copyFrom(*shortBuffer, numFrames, numChannels, sampleRate)</em>\n<em>name: copyFrom</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const short *shortBuffer, size_t numFrames, size_t numChannels, unsigned int sampleRate</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>copy length samples from shortBuffer and interpret as interleaved with the given number of channels at the given samplerate</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void copyTo(&amp;outBuffer, frameFrame, loop = false)</p>\n<p>&lt;!--\n<em>syntax: copyTo(&amp;outBuffer, frameFrame, loop = false)</em>\n<em>name: copyTo</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: ofSoundBuffer &amp;outBuffer, size_t frameFrame, bool loop=false</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>as copyTo above but reads outNumFrames and outNumChannels from outBuffer</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void copyTo(&amp;outBuffer, outNumFrames, outNumChannels, fromFrame, loop = false)</p>\n<p>&lt;!--\n<em>syntax: copyTo(&amp;outBuffer, outNumFrames, outNumChannels, fromFrame, loop = false)</em>\n<em>name: copyTo</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: ofSoundBuffer &amp;outBuffer, size_t outNumFrames, size_t outNumChannels, size_t fromFrame, bool loop=false</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>resize outBuffer to outNumFrames with outNumChannels, and then copy outNumFrames of data from us to outBuffer.\nfromFrame is a frame offset. if we don't have enough source data, loop with fromFrame=0 until we have filled outBuffer.\nif outBuffer has fewer channels than our buffer, just copy the first outNumChannels of our data and skip the rest.\nif outBuffer has more channels than our buffer, loop through our channels repeatedly until done.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void copyTo(*outBuffer, outNumFrames, outNumChannels, fromFrame, loop = false)</p>\n<p>&lt;!--\n<em>syntax: copyTo(*outBuffer, outNumFrames, outNumChannels, fromFrame, loop = false)</em>\n<em>name: copyTo</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: float *outBuffer, size_t outNumFrames, size_t outNumChannels, size_t fromFrame, bool loop=false</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>copy sample data to out, where out is already allocated to match outNumFrames and outNumChannels (ie outNumFrames*outNumChannels samples).\nfromFrame is a frame offset. if we don't have enough source data, loop with fromFrame=0 until we have filled the out buffer.\nif out has fewer channels than our buffer, just copy the first outNumChannels of our data and skip the rest.\nif out has more channels than our buffer, loop through our channels repeatedly until done.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void fillWithNoise(amplitude = 1.0f)</p>\n<p>&lt;!--\n<em>syntax: fillWithNoise(amplitude = 1.0f)</em>\n<em>name: fillWithNoise</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: float amplitude=1.0f</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>fills the buffer with random noise between -amplitude and amplitude. useful for debugging.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float fillWithTone(pitchHz = 440.0f, phase = 0.0f)</p>\n<p>&lt;!--\n<em>syntax: fillWithTone(pitchHz = 440.0f, phase = 0.0f)</em>\n<em>name: fillWithTone</em>\n<em>returns: float</em>\n_returns_description: _\n<em>parameters: float pitchHz=440.0f, float phase=0.0f</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>fills the buffer with a sine wave. useful for debugging.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###vector&lt; float &gt; &amp; getBuffer()</p>\n<p>&lt;!--\n<em>syntax: getBuffer()</em>\n<em>name: getBuffer</em>\n<em>returns: vector&lt; float &gt; &amp;</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>return the underlying buffer. careful!</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###const vector&lt; float &gt; &amp; getBuffer()</p>\n<p>&lt;!--\n<em>syntax: getBuffer()</em>\n<em>name: getBuffer</em>\n<em>returns: const vector&lt; float &gt; &amp;</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void getChannel(&amp;outBuffer, sourceChannel)</p>\n<p>&lt;!--\n<em>syntax: getChannel(&amp;outBuffer, sourceChannel)</em>\n<em>name: getChannel</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: ofSoundBuffer &amp;outBuffer, size_t sourceChannel</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>copy the requested channel of our data to outBuffer. resize outBuffer to fit.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###int getDeviceID()</p>\n<p>&lt;!--\n<em>syntax: getDeviceID()</em>\n<em>name: getDeviceID</em>\n<em>returns: int</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>return the ID of the device which generated this buffer</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###uint64_t getDurationMS()</p>\n<p>&lt;!--\n<em>syntax: getDurationMS()</em>\n<em>name: getDurationMS</em>\n<em>returns: uint64_t</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>return the duration of audio in this buffer in milliseconds (==(getNumFrames()/getSampleRate())*1000)</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###uint64_t getDurationMicros()</p>\n<p>&lt;!--\n<em>syntax: getDurationMicros()</em>\n<em>name: getDurationMicros</em>\n<em>returns: uint64_t</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###uint64_t getDurationNanos()</p>\n<p>&lt;!--\n<em>syntax: getDurationNanos()</em>\n<em>name: getDurationNanos</em>\n<em>returns: uint64_t</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###size_t getNumChannels()</p>\n<p>&lt;!--\n<em>syntax: getNumChannels()</em>\n<em>name: getNumChannels</em>\n<em>returns: size_t</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>the number of channels per frame</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###size_t getNumFrames()</p>\n<p>&lt;!--\n<em>syntax: getNumFrames()</em>\n<em>name: getNumFrames</em>\n<em>returns: size_t</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>the number of frames, ie the number of sets of (getNumChannels()) samples</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float getRMSAmplitude()</p>\n<p>&lt;!--\n<em>syntax: getRMSAmplitude()</em>\n<em>name: getRMSAmplitude</em>\n<em>returns: float</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float getRMSAmplitudeChannel(channel)</p>\n<p>&lt;!--\n<em>syntax: getRMSAmplitudeChannel(channel)</em>\n<em>name: getRMSAmplitudeChannel</em>\n<em>returns: float</em>\n_returns_description: _\n<em>parameters: size_t channel</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float &amp; getSample(frameIndex, channel)</p>\n<p>&lt;!--\n<em>syntax: getSample(frameIndex, channel)</em>\n<em>name: getSample</em>\n<em>returns: float &amp;</em>\n_returns_description: _\n<em>parameters: size_t frameIndex, size_t channel</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>access the sample at frameIndex on a soecific channel</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###const float &amp; getSample(frameIndex, channel)</p>\n<p>&lt;!--\n<em>syntax: getSample(frameIndex, channel)</em>\n<em>name: getSample</em>\n<em>returns: const float &amp;</em>\n_returns_description: _\n<em>parameters: size_t frameIndex, size_t channel</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###unsigned int getSampleRate()</p>\n<p>&lt;!--\n<em>syntax: getSampleRate()</em>\n<em>name: getSampleRate</em>\n<em>returns: unsigned int</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>sample rate of the audio in this buffer</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###uint64_t getTickCount()</p>\n<p>&lt;!--\n<em>syntax: getTickCount()</em>\n<em>name: getTickCount</em>\n<em>returns: uint64_t</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>return the tickCount that was assigned by ofSoundStream (if this buffer originated from an ofSoundStream).</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void hermiteResampleTo(&amp;buffer, fromFrame, numFrames, speed, loop)</p>\n<p>&lt;!--\n<em>syntax: hermiteResampleTo(&amp;buffer, fromFrame, numFrames, speed, loop)</em>\n<em>name: hermiteResampleTo</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: ofSoundBuffer &amp;buffer, size_t fromFrame, size_t numFrames, float speed, bool loop</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void linearResampleTo(&amp;buffer, fromFrame, numFrames, speed, loop)</p>\n<p>&lt;!--\n<em>syntax: linearResampleTo(&amp;buffer, fromFrame, numFrames, speed, loop)</em>\n<em>name: linearResampleTo</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: ofSoundBuffer &amp;buffer, size_t fromFrame, size_t numFrames, float speed, bool loop</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void normalize(level)</p>\n<p>&lt;!--\n<em>syntax: normalize(level)</em>\n<em>name: normalize</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: float level</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>amplifies samples so that the maximum amplitude is equal to 'level'</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<h3>ofSoundBuffer()</h3>\n<p>&lt;!--\n<em>syntax: ofSoundBuffer()</em>\n<em>name: ofSoundBuffer</em>\n_returns: _\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<h3>ofSoundBuffer(*shortBuffer, numFrames, numChannels, sampleRate)</h3>\n<p>&lt;!--\n<em>syntax: ofSoundBuffer(*shortBuffer, numFrames, numChannels, sampleRate)</em>\n<em>name: ofSoundBuffer</em>\n_returns: _\n_returns_description: _\n<em>parameters: short *shortBuffer, size_t numFrames, size_t numChannels, unsigned int sampleRate</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###ofSoundBuffer operator*(value)</p>\n<p>&lt;!--\n<em>syntax: operator*(value)</em>\n<em>name: operator*</em>\n<em>returns: ofSoundBuffer</em>\n_returns_description: _\n<em>parameters: float value</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>return a new buffer containing the contents of this buffer multiplied by value.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###ofSoundBuffer &amp; operator*=(value)</p>\n<p>&lt;!--\n<em>syntax: operator*=(value)</em>\n<em>name: operator*=</em>\n<em>returns: ofSoundBuffer &amp;</em>\n_returns_description: _\n<em>parameters: float value</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>multiply everything in this buffer by value, in-place.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###float &amp; operator<a href=\"samplePos\"></a></p>\n<p>&lt;!--\n<em>syntax: operator<a href=\"samplePos\"></a></em>\n<em>name: operator[]</em>\n<em>returns: float &amp;</em>\n_returns_description: _\n<em>parameters: size_t samplePos</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>access the sample at the given position in the buffer.\nto retrieve the sample for channel channelIndex of frame frameIndex, do the following:\nofSoundBuffer myBuffer;\n...\nfloat sample = myBuffer[(frameIndex*myBuffer.getNumChannels()) + channelIndex];</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###const float &amp; operator<a href=\"samplePos\"></a></p>\n<p>&lt;!--\n<em>syntax: operator<a href=\"samplePos\"></a></em>\n<em>name: operator[]</em>\n<em>returns: const float &amp;</em>\n_returns_description: _\n<em>parameters: size_t samplePos</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void resample(speed, algorithm)</p>\n<p>&lt;!--\n<em>syntax: resample(speed, algorithm)</em>\n<em>name: resample</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: float speed, ofSoundBuffer::InterpolationAlgorithm algorithm</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>resample by changing the playback speed, keeping the same sampleRate</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void resampleTo(&amp;outBuffer, fromFrame, numFrames, speed, loop = false, algorithm)</p>\n<p>&lt;!--\n<em>syntax: resampleTo(&amp;outBuffer, fromFrame, numFrames, speed, loop = false, algorithm)</em>\n<em>name: resampleTo</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: ofSoundBuffer &amp;outBuffer, size_t fromFrame, size_t numFrames, float speed, bool loop=false, ofSoundBuffer::InterpolationAlgorithm algorithm</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>resample our data to outBuffer at the given target speed, starting at fromFrame and copying numFrames of data. resize outBuffer to fit.\nspeed is relative to current speed (ie 1.0f == no change). lower speeds will give a larger outBuffer, higher speeds a smaller outBuffer.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void resize(numSamples, val)</p>\n<p>&lt;!--\n<em>syntax: resize(numSamples, val)</em>\n<em>name: resize</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: size_t numSamples, float val</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>resize this buffer to exactly this many samples. it's up to you make sure samples matches the channel count.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void set(value)</p>\n<p>&lt;!--\n<em>syntax: set(value)</em>\n<em>name: set</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: float value</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>set everything in this buffer to value, preserving size, channel count and sample rate.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setChannel(&amp;inBuffer, channel)</p>\n<p>&lt;!--\n<em>syntax: setChannel(&amp;inBuffer, channel)</em>\n<em>name: setChannel</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: const ofSoundBuffer &amp;inBuffer, size_t channel</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>copy data from inBuffer to the given channel. resize ourselves to match inBuffer's getNumFrames().</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setDeviceID(id)</p>\n<p>&lt;!--\n<em>syntax: setDeviceID(id)</em>\n<em>name: setDeviceID</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: int id</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setNumChannels(channels)</p>\n<p>&lt;!--\n<em>syntax: setNumChannels(channels)</em>\n<em>name: setNumChannels</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: int channels</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>set the number of channels. does not change the underlying data, ie causes getNumFrames() to return a different result.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setSampleRate(rate)</p>\n<p>&lt;!--\n<em>syntax: setSampleRate(rate)</em>\n<em>name: setSampleRate</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: unsigned int rate</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void setTickCount(tick)</p>\n<p>&lt;!--\n<em>syntax: setTickCount(tick)</em>\n<em>name: setTickCount</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: uint64_t tick</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###size_t size()</p>\n<p>&lt;!--\n<em>syntax: size()</em>\n<em>name: size</em>\n<em>returns: size_t</em>\n_returns_description: _\n_parameters: _\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>return the total number of samples in this buffer (==getNumFrames()*getNumChannels())</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void stereoPan(left, right)</p>\n<p>&lt;!--\n<em>syntax: stereoPan(left, right)</em>\n<em>name: stereoPan</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: float left, float right</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>assuming a 2-channel buffer, apply a stereo pan by multiplying channel 0 by left and channel 1 by right.</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void swap(&amp;otherBuffer)</p>\n<p>&lt;!--\n<em>syntax: swap(&amp;otherBuffer)</em>\n<em>name: swap</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: ofSoundBuffer &amp;otherBuffer</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>swap the contents of this buffer with otherBuffer</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void toShortPCM(&amp;dst)</p>\n<p>&lt;!--\n<em>syntax: toShortPCM(&amp;dst)</em>\n<em>name: toShortPCM</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: vector&lt; short &gt; &amp;dst</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###void toShortPCM(*dst)</p>\n<p>&lt;!--\n<em>syntax: toShortPCM(*dst)</em>\n<em>name: toShortPCM</em>\n<em>returns: void</em>\n_returns_description: _\n<em>parameters: short *dst</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###bool trimSilence(threshold = 0.0001f, trimStart = true, trimEnd = true)</p>\n<p>&lt;!--\n<em>syntax: trimSilence(threshold = 0.0001f, trimStart = true, trimEnd = true)</em>\n<em>name: trimSilence</em>\n<em>returns: bool</em>\n_returns_description: _\n<em>parameters: float threshold=0.0001f, bool trimStart=true, bool trimEnd=true</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>constant: False</em>\n<em>static: False</em>\n<em>visible: True</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>removes initial / ending silence from the buffer</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>##Variables</p>\n<p>###vector&lt; float &gt; buffer</p>\n<p>&lt;!--\n<em>name: buffer</em>\n<em>type: vector&lt; float &gt;</em>\n<em>access: protected</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>visible: True</em>\n<em>constant: False</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###size_t channels</p>\n<p>&lt;!--\n<em>name: channels</em>\n<em>type: size_t</em>\n<em>access: protected</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>visible: True</em>\n<em>constant: False</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###ofSoundBuffer::InterpolationAlgorithm defaultAlgorithm</p>\n<p>&lt;!--\n<em>name: defaultAlgorithm</em>\n<em>type: ofSoundBuffer::InterpolationAlgorithm</em>\n<em>access: public</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>visible: True</em>\n<em>constant: False</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###unsigned int samplerate</p>\n<p>&lt;!--\n<em>name: samplerate</em>\n<em>type: unsigned int</em>\n<em>access: protected</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>visible: True</em>\n<em>constant: False</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###int soundStreamDeviceID</p>\n<p>&lt;!--\n<em>name: soundStreamDeviceID</em>\n<em>type: int</em>\n<em>access: protected</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>visible: True</em>\n<em>constant: False</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n<p>###uint64_t tickCount</p>\n<p>&lt;!--\n<em>name: tickCount</em>\n<em>type: uint64_t</em>\n<em>access: protected</em>\n<em>version_started: 0.9.0</em>\n_version_deprecated: _\n_summary: _\n<em>visible: True</em>\n<em>constant: False</em>\n<em>advanced: False</em>\n--&gt;</p>\n<p>_inlined_description: _</p>\n<p>_description: _</p>\n<p>&lt;!-----------------------------------------------------------------------------&gt;</p>\n","raw":"#class ofSoundBuffer\n\n\n<!--\n_visible: True_\n_advanced: False_\n_istemplated: False_\n_extends: _\n-->\n\n##InlineDescription\n\n/*!\n\n@brief Buffer for audio samples and associated metadata.\n\nofSoundBuffer stores audio as an array of interleaved floating point samples, with a given sample rate for playback.\n\n#### How sound recording works\n\nPhysically speaking, what we call _sound_ is simply changes in air pressure perceived by a listener. These changes in sound pressure are converted\nby a microphone into changes in voltage that can be recorded, making a _sound recording_. A sound recording is therefore a recording of changes in air\npressure at a particular point in space (ie where the microphone was positioned). When it is played back through a speaker, the speaker reproduces the\nsame pattern of changes in air pressure as were recorded by the microphone, but this time at a different point in space (ie where the speaker is positioned).\n\nIn digital audio these changes in air pressure are recorded as a set of discrete numbers (_samples_), each number representing a snapshot of the air pressure\nat a particular point in time. For high quality audio there are typically 44,100 snapshots recorded every second. This is called the _sample rate_ and is\nexpressed in _Hz_ (44100Hz) or _kHz_ (44.1kHz).\n\nBecause humans have two ears, rather than one, sound is usually recorded in stereo. The simplest stereo sound recording is two _channels_ of sound\nrecorded by two microphones at two different points in space. More channels can also be recorded (eg with 5.1 surround sound systems or Ambisonics).\n\n\n#### Frames, channels and samples\n\nData in an ofSoundBuffer is stored _interleaved_ as an array of floats. Interleaved audio is analogous to how different color channels are stored side by side\nin an ofImage or ofPixels object.\n\nThe functions and function arguments in ofSoundBuffer that deal with this interleaved data are based on 3 key terms:\n\n_channels_ refers to the number of channels or individual streams of interleaved audio samples in the buffer. A mono recording has 1 channel, a stereo\nrecording has 2 channels.\n\n_samples_ refers to the actual raw data. One _sample_ is a single floating point number between -1 and 1, which represents a snapshot of sound pressure at\na single moment in time. A 0.1 second long buffer at 44100Hz contains 4410 _samples_ if it has 1 channel, 8820 _samples_ if it has 2 channels, 13230\n_samples_ if it has 3 channels, and so on.\n\n_frames_ refers to the number of multi-channel sets of interleaved sample data there are in the buffer. A 0.1 second long buffer at 44100Hz always has\n4410 _frames_, regardless of how many channels it has. To get the number of _samples_ in a buffer you multiply the number of _channels_ by the number of _frames_.\n\n\nIf I have an ofSoundBuffer with 8 _frames_ of mono (1 _channel_) audio, the underlying array contains 8 _samples_ (ie it is 8 floats long),\nand the samples are arranged like this:\n\nL L L L L L L L\n\nwhere `L` represents a single sample.\n\n\nIf I have an ofSoundBuffer with 8 _frames_ of stereo (2 _channel_) audio, then the underlying array contains 16 _samples_ ((getNumFrames()*getNumChannels(),\nie 8*2) arranged in an _interleaved_ pattern:\n\nL R L R L R L R L R L R L R L R\n\nwhere `L` represents a single sample for the left channel, and `R` represents a single sample for the right channel. Grouping the frames together for clarity:\n\nLR LR LR LR LR LR LR LR\n\n\nIf I have an ofSoundBuffer with 8 frames of 5.1 surround (6 _channel_) audio, then the underlying array of floats contains 48 _samples_ (getNumFrames()*getNumChannels(),\nie 8*6) and is usually arranged in an _interleaved_ pattern like this:\n\nL C R Ls Rs Lfe L C R Ls Rs Lfe L C R Ls Rs Lfe L C R Ls Rs Lfe L C R Ls Rs Lfe L C R Ls Rs Lfe L C R Ls Rs Lfe L C R Ls Rs Lfe\n\nwhere `L` represents a single sample for the left channel, `C` for centre, `R` for right, `Ls` for left surround, `Rs` for right surround and `Lfe` for the subwoofer.\nGrouping the frames together for clarity:\n\nLCRLsRsLfe LCRLsRsLfe LCRLsRsLfe LCRLsRsLfe LCRLsRsLfe LCRLsRsLfe LCRLsRsLfe LCRLsRsLfe\n\n*/\n\n\n\n\n\n##Description\n\n\n\n\n\n##Methods\n\n\n\n###void addTo(&outBuffer, fromFrame, loop = false)\n\n<!--\n_syntax: addTo(&outBuffer, fromFrame, loop = false)_\n_name: addTo_\n_returns: void_\n_returns_description: _\n_parameters: ofSoundBuffer &outBuffer, size_t fromFrame, bool loop=false_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nas addTo above but reads outNumFrames and outNumChannels from outBuffer\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void addTo(&outBuffer, outNumFrames, outNumChannels, fromFrame, loop = false)\n\n<!--\n_syntax: addTo(&outBuffer, outNumFrames, outNumChannels, fromFrame, loop = false)_\n_name: addTo_\n_returns: void_\n_returns_description: _\n_parameters: ofSoundBuffer &outBuffer, size_t outNumFrames, size_t outNumChannels, size_t fromFrame, bool loop=false_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nas copyTo but mixes source audio with audio in `outBuffer` by adding samples together (+), instead of overwriting.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void addTo(*outBuffer, outNumFrames, outNumChannels, fromFrame, loop = false)\n\n<!--\n_syntax: addTo(*outBuffer, outNumFrames, outNumChannels, fromFrame, loop = false)_\n_name: addTo_\n_returns: void_\n_returns_description: _\n_parameters: float *outBuffer, size_t outNumFrames, size_t outNumChannels, size_t fromFrame, bool loop=false_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nas copyTo but mixes source audio with audio in `out` by adding samples together (+), instead of overwriting\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void allocate(numSamples, numChannels)\n\n<!--\n_syntax: allocate(numSamples, numChannels)_\n_name: allocate_\n_returns: void_\n_returns_description: _\n_parameters: size_t numSamples, size_t numChannels_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void append(&other)\n\n<!--\n_syntax: append(&other)_\n_name: append_\n_returns: void_\n_returns_description: _\n_parameters: ofSoundBuffer &other_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool checkSizeAndChannelsConsistency(&function)\n\n<!--\n_syntax: checkSizeAndChannelsConsistency(&function)_\n_name: checkSizeAndChannelsConsistency_\n_returns: bool_\n_returns_description: _\n_parameters: const string &function_\n_access: protected_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void clear()\n\n<!--\n_syntax: clear()_\n_name: clear_\n_returns: void_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nremove all samples, preserving channel count and sample rate.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void copyFrom(&floatBuffer, numChannels, sampleRate)\n\n<!--\n_syntax: copyFrom(&floatBuffer, numChannels, sampleRate)_\n_name: copyFrom_\n_returns: void_\n_returns_description: _\n_parameters: const vector< float > &floatBuffer, size_t numChannels, unsigned int sampleRate_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void copyFrom(&shortBuffer, numChannels, sampleRate)\n\n<!--\n_syntax: copyFrom(&shortBuffer, numChannels, sampleRate)_\n_name: copyFrom_\n_returns: void_\n_returns_description: _\n_parameters: const vector< short > &shortBuffer, size_t numChannels, unsigned int sampleRate_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void copyFrom(*floatBuffer, numFrames, numChannels, sampleRate)\n\n<!--\n_syntax: copyFrom(*floatBuffer, numFrames, numChannels, sampleRate)_\n_name: copyFrom_\n_returns: void_\n_returns_description: _\n_parameters: const float *floatBuffer, size_t numFrames, size_t numChannels, unsigned int sampleRate_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void copyFrom(*shortBuffer, numFrames, numChannels, sampleRate)\n\n<!--\n_syntax: copyFrom(*shortBuffer, numFrames, numChannels, sampleRate)_\n_name: copyFrom_\n_returns: void_\n_returns_description: _\n_parameters: const short *shortBuffer, size_t numFrames, size_t numChannels, unsigned int sampleRate_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\ncopy length samples from shortBuffer and interpret as interleaved with the given number of channels at the given samplerate\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void copyTo(&outBuffer, frameFrame, loop = false)\n\n<!--\n_syntax: copyTo(&outBuffer, frameFrame, loop = false)_\n_name: copyTo_\n_returns: void_\n_returns_description: _\n_parameters: ofSoundBuffer &outBuffer, size_t frameFrame, bool loop=false_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nas copyTo above but reads outNumFrames and outNumChannels from outBuffer\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void copyTo(&outBuffer, outNumFrames, outNumChannels, fromFrame, loop = false)\n\n<!--\n_syntax: copyTo(&outBuffer, outNumFrames, outNumChannels, fromFrame, loop = false)_\n_name: copyTo_\n_returns: void_\n_returns_description: _\n_parameters: ofSoundBuffer &outBuffer, size_t outNumFrames, size_t outNumChannels, size_t fromFrame, bool loop=false_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nresize outBuffer to outNumFrames with outNumChannels, and then copy outNumFrames of data from us to outBuffer.\nfromFrame is a frame offset. if we don't have enough source data, loop with fromFrame=0 until we have filled outBuffer.\nif outBuffer has fewer channels than our buffer, just copy the first outNumChannels of our data and skip the rest.\nif outBuffer has more channels than our buffer, loop through our channels repeatedly until done.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void copyTo(*outBuffer, outNumFrames, outNumChannels, fromFrame, loop = false)\n\n<!--\n_syntax: copyTo(*outBuffer, outNumFrames, outNumChannels, fromFrame, loop = false)_\n_name: copyTo_\n_returns: void_\n_returns_description: _\n_parameters: float *outBuffer, size_t outNumFrames, size_t outNumChannels, size_t fromFrame, bool loop=false_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\ncopy sample data to out, where out is already allocated to match outNumFrames and outNumChannels (ie outNumFrames*outNumChannels samples).\nfromFrame is a frame offset. if we don't have enough source data, loop with fromFrame=0 until we have filled the out buffer.\nif out has fewer channels than our buffer, just copy the first outNumChannels of our data and skip the rest.\nif out has more channels than our buffer, loop through our channels repeatedly until done.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void fillWithNoise(amplitude = 1.0f)\n\n<!--\n_syntax: fillWithNoise(amplitude = 1.0f)_\n_name: fillWithNoise_\n_returns: void_\n_returns_description: _\n_parameters: float amplitude=1.0f_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nfills the buffer with random noise between -amplitude and amplitude. useful for debugging.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float fillWithTone(pitchHz = 440.0f, phase = 0.0f)\n\n<!--\n_syntax: fillWithTone(pitchHz = 440.0f, phase = 0.0f)_\n_name: fillWithTone_\n_returns: float_\n_returns_description: _\n_parameters: float pitchHz=440.0f, float phase=0.0f_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nfills the buffer with a sine wave. useful for debugging.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###vector< float > & getBuffer()\n\n<!--\n_syntax: getBuffer()_\n_name: getBuffer_\n_returns: vector< float > &_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nreturn the underlying buffer. careful!\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###const vector< float > & getBuffer()\n\n<!--\n_syntax: getBuffer()_\n_name: getBuffer_\n_returns: const vector< float > &_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void getChannel(&outBuffer, sourceChannel)\n\n<!--\n_syntax: getChannel(&outBuffer, sourceChannel)_\n_name: getChannel_\n_returns: void_\n_returns_description: _\n_parameters: ofSoundBuffer &outBuffer, size_t sourceChannel_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\ncopy the requested channel of our data to outBuffer. resize outBuffer to fit.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###int getDeviceID()\n\n<!--\n_syntax: getDeviceID()_\n_name: getDeviceID_\n_returns: int_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nreturn the ID of the device which generated this buffer\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###uint64_t getDurationMS()\n\n<!--\n_syntax: getDurationMS()_\n_name: getDurationMS_\n_returns: uint64_t_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nreturn the duration of audio in this buffer in milliseconds (==(getNumFrames()/getSampleRate())*1000)\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###uint64_t getDurationMicros()\n\n<!--\n_syntax: getDurationMicros()_\n_name: getDurationMicros_\n_returns: uint64_t_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###uint64_t getDurationNanos()\n\n<!--\n_syntax: getDurationNanos()_\n_name: getDurationNanos_\n_returns: uint64_t_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###size_t getNumChannels()\n\n<!--\n_syntax: getNumChannels()_\n_name: getNumChannels_\n_returns: size_t_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nthe number of channels per frame\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###size_t getNumFrames()\n\n<!--\n_syntax: getNumFrames()_\n_name: getNumFrames_\n_returns: size_t_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nthe number of frames, ie the number of sets of (getNumChannels()) samples\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float getRMSAmplitude()\n\n<!--\n_syntax: getRMSAmplitude()_\n_name: getRMSAmplitude_\n_returns: float_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float getRMSAmplitudeChannel(channel)\n\n<!--\n_syntax: getRMSAmplitudeChannel(channel)_\n_name: getRMSAmplitudeChannel_\n_returns: float_\n_returns_description: _\n_parameters: size_t channel_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float & getSample(frameIndex, channel)\n\n<!--\n_syntax: getSample(frameIndex, channel)_\n_name: getSample_\n_returns: float &_\n_returns_description: _\n_parameters: size_t frameIndex, size_t channel_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\naccess the sample at frameIndex on a soecific channel\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###const float & getSample(frameIndex, channel)\n\n<!--\n_syntax: getSample(frameIndex, channel)_\n_name: getSample_\n_returns: const float &_\n_returns_description: _\n_parameters: size_t frameIndex, size_t channel_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###unsigned int getSampleRate()\n\n<!--\n_syntax: getSampleRate()_\n_name: getSampleRate_\n_returns: unsigned int_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nsample rate of the audio in this buffer\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###uint64_t getTickCount()\n\n<!--\n_syntax: getTickCount()_\n_name: getTickCount_\n_returns: uint64_t_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nreturn the tickCount that was assigned by ofSoundStream (if this buffer originated from an ofSoundStream).\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void hermiteResampleTo(&buffer, fromFrame, numFrames, speed, loop)\n\n<!--\n_syntax: hermiteResampleTo(&buffer, fromFrame, numFrames, speed, loop)_\n_name: hermiteResampleTo_\n_returns: void_\n_returns_description: _\n_parameters: ofSoundBuffer &buffer, size_t fromFrame, size_t numFrames, float speed, bool loop_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void linearResampleTo(&buffer, fromFrame, numFrames, speed, loop)\n\n<!--\n_syntax: linearResampleTo(&buffer, fromFrame, numFrames, speed, loop)_\n_name: linearResampleTo_\n_returns: void_\n_returns_description: _\n_parameters: ofSoundBuffer &buffer, size_t fromFrame, size_t numFrames, float speed, bool loop_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void normalize(level)\n\n<!--\n_syntax: normalize(level)_\n_name: normalize_\n_returns: void_\n_returns_description: _\n_parameters: float level_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\namplifies samples so that the maximum amplitude is equal to 'level'\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n### ofSoundBuffer()\n\n<!--\n_syntax: ofSoundBuffer()_\n_name: ofSoundBuffer_\n_returns: _\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n### ofSoundBuffer(*shortBuffer, numFrames, numChannels, sampleRate)\n\n<!--\n_syntax: ofSoundBuffer(*shortBuffer, numFrames, numChannels, sampleRate)_\n_name: ofSoundBuffer_\n_returns: _\n_returns_description: _\n_parameters: short *shortBuffer, size_t numFrames, size_t numChannels, unsigned int sampleRate_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###ofSoundBuffer operator*(value)\n\n<!--\n_syntax: operator*(value)_\n_name: operator*_\n_returns: ofSoundBuffer_\n_returns_description: _\n_parameters: float value_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nreturn a new buffer containing the contents of this buffer multiplied by value.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###ofSoundBuffer & operator*=(value)\n\n<!--\n_syntax: operator*=(value)_\n_name: operator*=_\n_returns: ofSoundBuffer &_\n_returns_description: _\n_parameters: float value_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nmultiply everything in this buffer by value, in-place.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###float & operator[](samplePos)\n\n<!--\n_syntax: operator[](samplePos)_\n_name: operator[]_\n_returns: float &_\n_returns_description: _\n_parameters: size_t samplePos_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\naccess the sample at the given position in the buffer.\nto retrieve the sample for channel channelIndex of frame frameIndex, do the following:\nofSoundBuffer myBuffer;\n...\nfloat sample = myBuffer[(frameIndex*myBuffer.getNumChannels()) + channelIndex];\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###const float & operator[](samplePos)\n\n<!--\n_syntax: operator[](samplePos)_\n_name: operator[]_\n_returns: const float &_\n_returns_description: _\n_parameters: size_t samplePos_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void resample(speed, algorithm)\n\n<!--\n_syntax: resample(speed, algorithm)_\n_name: resample_\n_returns: void_\n_returns_description: _\n_parameters: float speed, ofSoundBuffer::InterpolationAlgorithm algorithm_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nresample by changing the playback speed, keeping the same sampleRate\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void resampleTo(&outBuffer, fromFrame, numFrames, speed, loop = false, algorithm)\n\n<!--\n_syntax: resampleTo(&outBuffer, fromFrame, numFrames, speed, loop = false, algorithm)_\n_name: resampleTo_\n_returns: void_\n_returns_description: _\n_parameters: ofSoundBuffer &outBuffer, size_t fromFrame, size_t numFrames, float speed, bool loop=false, ofSoundBuffer::InterpolationAlgorithm algorithm_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nresample our data to outBuffer at the given target speed, starting at fromFrame and copying numFrames of data. resize outBuffer to fit.\nspeed is relative to current speed (ie 1.0f == no change). lower speeds will give a larger outBuffer, higher speeds a smaller outBuffer.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void resize(numSamples, val)\n\n<!--\n_syntax: resize(numSamples, val)_\n_name: resize_\n_returns: void_\n_returns_description: _\n_parameters: size_t numSamples, float val_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nresize this buffer to exactly this many samples. it's up to you make sure samples matches the channel count.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void set(value)\n\n<!--\n_syntax: set(value)_\n_name: set_\n_returns: void_\n_returns_description: _\n_parameters: float value_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nset everything in this buffer to value, preserving size, channel count and sample rate.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setChannel(&inBuffer, channel)\n\n<!--\n_syntax: setChannel(&inBuffer, channel)_\n_name: setChannel_\n_returns: void_\n_returns_description: _\n_parameters: const ofSoundBuffer &inBuffer, size_t channel_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\ncopy data from inBuffer to the given channel. resize ourselves to match inBuffer's getNumFrames().\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setDeviceID(id)\n\n<!--\n_syntax: setDeviceID(id)_\n_name: setDeviceID_\n_returns: void_\n_returns_description: _\n_parameters: int id_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setNumChannels(channels)\n\n<!--\n_syntax: setNumChannels(channels)_\n_name: setNumChannels_\n_returns: void_\n_returns_description: _\n_parameters: int channels_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nset the number of channels. does not change the underlying data, ie causes getNumFrames() to return a different result.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setSampleRate(rate)\n\n<!--\n_syntax: setSampleRate(rate)_\n_name: setSampleRate_\n_returns: void_\n_returns_description: _\n_parameters: unsigned int rate_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void setTickCount(tick)\n\n<!--\n_syntax: setTickCount(tick)_\n_name: setTickCount_\n_returns: void_\n_returns_description: _\n_parameters: uint64_t tick_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###size_t size()\n\n<!--\n_syntax: size()_\n_name: size_\n_returns: size_t_\n_returns_description: _\n_parameters: _\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nreturn the total number of samples in this buffer (==getNumFrames()*getNumChannels())\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void stereoPan(left, right)\n\n<!--\n_syntax: stereoPan(left, right)_\n_name: stereoPan_\n_returns: void_\n_returns_description: _\n_parameters: float left, float right_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nassuming a 2-channel buffer, apply a stereo pan by multiplying channel 0 by left and channel 1 by right.\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void swap(&otherBuffer)\n\n<!--\n_syntax: swap(&otherBuffer)_\n_name: swap_\n_returns: void_\n_returns_description: _\n_parameters: ofSoundBuffer &otherBuffer_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nswap the contents of this buffer with otherBuffer\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void toShortPCM(&dst)\n\n<!--\n_syntax: toShortPCM(&dst)_\n_name: toShortPCM_\n_returns: void_\n_returns_description: _\n_parameters: vector< short > &dst_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###void toShortPCM(*dst)\n\n<!--\n_syntax: toShortPCM(*dst)_\n_name: toShortPCM_\n_returns: void_\n_returns_description: _\n_parameters: short *dst_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###bool trimSilence(threshold = 0.0001f, trimStart = true, trimEnd = true)\n\n<!--\n_syntax: trimSilence(threshold = 0.0001f, trimStart = true, trimEnd = true)_\n_name: trimSilence_\n_returns: bool_\n_returns_description: _\n_parameters: float threshold=0.0001f, bool trimStart=true, bool trimEnd=true_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_constant: False_\n_static: False_\n_visible: True_\n_advanced: False_\n-->\n\n_inlined_description: _\n\nremoves initial / ending silence from the buffer\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n##Variables\n\n\n\n###vector< float > buffer\n\n<!--\n_name: buffer_\n_type: vector< float >_\n_access: protected_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: False_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###size_t channels\n\n<!--\n_name: channels_\n_type: size_t_\n_access: protected_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: False_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###ofSoundBuffer::InterpolationAlgorithm defaultAlgorithm\n\n<!--\n_name: defaultAlgorithm_\n_type: ofSoundBuffer::InterpolationAlgorithm_\n_access: public_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: False_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###unsigned int samplerate\n\n<!--\n_name: samplerate_\n_type: unsigned int_\n_access: protected_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: False_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###int soundStreamDeviceID\n\n<!--\n_name: soundStreamDeviceID_\n_type: int_\n_access: protected_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: False_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n###uint64_t tickCount\n\n<!--\n_name: tickCount_\n_type: uint64_t_\n_access: protected_\n_version_started: 0.9.0_\n_version_deprecated: _\n_summary: _\n_visible: True_\n_constant: False_\n_advanced: False_\n-->\n\n_inlined_description: _\n\n\n\n\n\n\n\n_description: _\n\n\n\n\n\n\n\n<!----------------------------------------------------------------------------->\n\n","type":"page"}